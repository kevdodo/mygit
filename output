branch config noooo way: branch "master"
we need to push to  : origin
url: git@gitlab.caltech.edu:cs137-24sp/git-kdo.git
ref received: refs/heads/master
hash: 438b6da72a3a9cdfb9db3928f5a4a04b84b21acf
ref received: refs/heads/new-branch
hash: ce5b37f14968af64405a36c054ef90378653708f
ref received: refs/heads/start
hash: f766b27857aec02beb9ef81acddce9e30ff704ba
FILE NAME: .git/refs/remotes/origin/master
branch: master
remote_hash: 438b6da72a3a9cdfb9db3928f5a4a04b84b21acf
my hash: 438b6da72a3a9cdfb9db3928f5a4a04b84b21acf
commit c39709df0cb7cd500f93646e055ed5fbf511ba06
commit 438b6da72a3a9cdfb9db3928f5a4a04b84b21acf
hash to push: c39709df0cb7cd500f93646e055ed5fbf511ba06
filename: .gitignore

contents: 
 out/*.o
out/*.d
bin/mygit
U
filename: .gitindex

contents: 
 DIRC
filename: .gitlab-ci.yml

contents: 
 test:
    script: "/testers/cs37/git/test/test"
reveal:
    script: "/testers/cs37/git/reveal/test"
ï¿½
filename: Makefile

contents: 
 # WARNING ABOUT TESTS
# -------------------
#
# Feel free to modify this makefile for your own purposes. However, tests will
# require that when submitting:
#  - `make mygit` builds the binary
#  - All sanitizers MUST be off for the above command

CC = clang
CFLAGS = -Wall -Wextra -Iinclude -MMD -g #-fsanitize=address,undefined
LDFLAGS = -lz -lcrypto #-fsanitize=address,undefined

bin/mygit: out/mygit.o \
	out/config_io.o out/hash_table.o out/index_io.o out/linked_list.o out/object_io.o out/ref_io.o out/transport.o out/util.o \
	out/add.o out/checkout.o out/commit.o out/fetch.o out/log.o out/push.o out/status.o
	$(CC) $(LDFLAGS) $^ -o $@

include $(wildcard out/*.d)

out/%.o: src/%.c
	$(CC) $(CFLAGS) -c $< -o $@


clean:
	rm -f out/*.o out/*.d bin/mygit
5 lï¿½
filename: aaaab

contents: 
 `ï¿½ï¿½>
filename: asdfasdfasdfasdfasdf

contents: 
 @ï¿½ï¿½>
filename: bbasd

contents: 
  ï¿½ï¿½>
filename: bin

contents: 
 100755 .gitkeep
filename: .gitkeep

contents: 
 `ï¿½ï¿½>
filename: bruh

contents: 
 00000000: 4449 5243 0000 0002 0000 003a 6638 7e4a  DIRC.......:f8~J
00000010: 0928 78c4 6638 7e4a 0928 78c4 0000 0000  .(x.f8~J.(x.....
00000020: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000030: 0000 001d ec17 f0ef 9a3c 55b1 cb1b e43f  .........<U....?
00000040: 838d 8a8b 06fe cf43 000a 2e67 6974 6967  .......C...gitig
00000050: 6e6f 7265 0000 0000 0000 0000 6638 7eca  nore........f8~.
00000060: 3402 ba50 6638 7eca 34ec 055c 0000 0000  4..Pf8~.4..\....
00000070: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000080: 0000 10de 2ba1 bc6f 6b55 822d cf5e f8bd  ....+..okU.-.^..
00000090: f294 9949 d94b 929d 0009 2e67 6974 696e  ...I.K.....gitin
000000a0: 6465 7800 6638 7e4a 0946 eb4c 6638 7e4a  dex.f8~J.F.Lf8~J
000000b0: 0946 eb4c 0000 0000 0000 0000 0000 81a4  .F.L............
000000c0: 0000 0000 0000 0000 0000 0068 2b1e ecb1  ...........h+...
000000d0: 8230 8355 0dc3 2057 73d6 761f b847 d58a  .0.U.. Ws.v..G..
000000e0: 000e 2e67 6974 6c61 622d 6369 2e79 6d6c  ...gitlab-ci.yml
000000f0: 0000 0000 6638 7e4a 0946 eb4c 6639 6520  ....f8~J.F.Lf9e 
00000100: 0501 7b60 0000 0000 0000 0000 0000 81a4  ..{`............
00000110: 0000 0000 0000 0000 0000 0312 0ce5 9d52  ...............R
00000120: 00b6 8d90 c0e8 3bab 6b1e 47df 64a9 67a1  ......;.k.G.d.g.
00000130: 0008 4d61 6b65 6669 6c65 0000 6639 6232  ..Makefile..f9b2
00000140: 3516 33cc 6639 6232 3516 33cc 0000 0000  5.3.f9b25.3.....
00000150: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000160: 0000 0000 e69d e29b b2d1 d643 4b8b 29ae  ...........CK.).
00000170: 775a d8c2 e48c 5391 0014 6173 6466 6173  wZ....S...asdfas
00000180: 6466 6173 6466 6173 6466 6173 6466 0000  dfasdfasdfasdf..
00000190: 0000 0000 6639 62e3 1198 b44c 6639 62e3  ....f9b....Lf9b.
000001a0: 1198 b44c 0000 0000 0000 0000 0000 81a4  ...L............
000001b0: 0000 0000 0000 0000 0000 0000 e69d e29b  ................
000001c0: b2d1 d643 4b8b 29ae 775a d8c2 e48c 5391  ...CK.).wZ....S.
000001d0: 0005 6262 6173 6400 0000 0000 6638 7e4a  ..bbasd.....f8~J
000001e0: 0956 1298 6638 7e4a 0956 1298 0000 0000  .V..f8~J.V......
000001f0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000200: 0000 0000 e69d e29b b2d1 d643 4b8b 29ae  ...........CK.).
00000210: 775a d8c2 e48c 5391 000c 6269 6e2f 2e67  wZ....S...bin/.g
00000220: 6974 6b65 6570 0000 0000 0000 6638 7e4a  itkeep......f8~J
00000230: 0956 1298 6639 6390 2fd2 9400 0000 0000  .V..f9c./.......
00000240: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000250: 0000 283f 7d23 ba94 21b3 a580 f204 f35c  ..(?}#..!......\
00000260: 8f36 b386 9972 efa5 0004 6272 7568 0000  .6...r....bruh..
00000270: 0000 0000 6638 7e4a 0993 6ae4 6638 7e4a  ....f8~J..j.f8~J
00000280: 09a2 84e8 0000 0000 0000 0000 0000 81a4  ................
00000290: 0000 0000 0000 0000 0003 ed01 4d88 a063  ............M..c
000002a0: a8d0 a466 c3cd d755 4abe 5cd6 c8d9 b102  ...f...UJ.\.....
000002b0: 0008 6272 7568 2e65 7865 0000 6638 7e4a  ..bruh.exe..f8~J
000002c0: 09a2 84e8 6639 63fe 2949 540c 0000 0000  ....f9c.)IT.....
000002d0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000002e0: 0000 2297 1caf c675 4afe ffb3 e08e e118  .."....uJ.......
000002f0: 3dc4 de50 fd33 22da 0005 6272 7568 3200  =..P.3"...bruh2.
00000300: 0000 0000 6638 7e4a 09b1 9eec 6638 7e4a  ....f8~J....f8~J
00000310: 09b1 9eec 0000 0000 0000 0000 0000 81a4  ................
00000320: 0000 0000 0000 0000 0000 032d 6f91 3a11  ...........-o.:.
00000330: ff73 fa38 a029 33e9 675d 794f 1ae5 cf6b  .s.8.)3.g]yO...k
00000340: 0014 6578 7061 6e64 2d61 6c6c 2d70 6163  ..expand-all-pac
00000350: 6b66 696c 6573 0000 0000 0000 6638 7e4a  kfiles......f8~J
00000360: 09b1 9eec 6638 7e4a 09b1 9eec 0000 0000  ....f8~J........
00000370: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000380: 0000 00b7 661e 87d5 5a4c 835c 68ec 9259  ....f...ZL.\h..Y
00000390: 4c4c 0a5c 3659 5813 000d 696e 636c 7564  LL.\6YX...includ
000003a0: 652f 6164 642e 6800 0000 0000 6638 7e4a  e/add.h.....f8~J
000003b0: 09c0 e12c 6638 7e4a 09c0 e12c 0000 0000  ...,f8~J...,....
000003c0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000003d0: 0000 0089 b950 eeae 8aea 44e7 eb85 c11d  .....P....D.....
000003e0: fcdc b090 4c8b 90bd 0012 696e 636c 7564  ....L.....includ
000003f0: 652f 6368 6563 6b6f 7574 2e68 0000 0000  e/checkout.h....
00000400: 0000 0000 6638 7e4a 09c0 e12c 6638 7e4a  ....f8~J...,f8~J
00000410: 09c0 e12c 0000 0000 0000 0000 0000 81a4  ...,............
00000420: 0000 0000 0000 0000 0000 005a 979c c48f  ...........Z....
00000430: aea9 e840 7f48 58d6 9b37 239c 7a50 9066  ...@.HX..7#.zP.f
00000440: 0010 696e 636c 7564 652f 636f 6d6d 6974  ..include/commit
00000450: 2e68 0000 6638 7e4a 09c0 e12c 6638 7e4a  .h..f8~J...,f8~J
00000460: 09c0 e12c 0000 0000 0000 0000 0000 81a4  ...,............
00000470: 0000 0000 0000 0000 0000 0512 21dc 5a14  ............!.Z.
00000480: 662b eb22 12e6 721d b17d 95ad ae36 7185  f+."..r..}...6q.
00000490: 0013 696e 636c 7564 652f 636f 6e66 6967  ..include/config
000004a0: 5f69 6f2e 6800 0000 0000 0000 6638 7e4a  _io.h.......f8~J
000004b0: 09d0 2178 6638 7e4a 09d0 2178 0000 0000  ..!xf8~J..!x....
000004c0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000004d0: 0000 0164 a5b8 e44f 9eba 70b7 3bdc d4d3  ...d...O..p.;...
000004e0: 4ac3 5f49 5463 90fe 0013 696e 636c 7564  J._ITc....includ
000004f0: 652f 636f 6e73 7461 6e74 732e 6800 0000  e/constants.h...
00000500: 0000 0000 6638 7e4a 09d0 2178 6638 7e4a  ....f8~J..!xf8~J
00000510: 09d0 2178 0000 0000 0000 0000 0000 81a4  ..!x............
00000520: 0000 0000 0000 0000 0000 007e 648f 7b51  ...........~d.{Q
00000530: fd6e 2d13 d00a c0a3 f4da 4cbc 7a46 1317  .n-.......L.zF..
00000540: 000f 696e 636c 7564 652f 6665 7463 682e  ..include/fetch.
00000550: 6800 0000 6638 7e4a 09df 8870 6638 7e4a  h...f8~J...pf8~J
00000560: 09df 8870 0000 0000 0000 0000 0000 81a4  ...p............
00000570: 0000 0000 0000 0000 0000 02c3 8fd0 7fb3  ................
00000580: 9a87 83db 3050 b916 2327 f76f db63 64df  ....0P..#'.o.cd.
00000590: 0014 696e 636c 7564 652f 6861 7368 5f74  ..include/hash_t
000005a0: 6162 6c65 2e68 0000 0000 0000 6638 7e4a  able.h......f8~J
000005b0: 09df 8870 6638 7e4a 09df 8870 0000 0000  ...pf8~J...p....
000005c0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000005d0: 0000 025c 676c 7e72 1706 e252 853d 2eae  ...\gl~r...R.=..
000005e0: 9cd8 a79d 8793 e0d2 0012 696e 636c 7564  ..........includ
000005f0: 652f 696e 6465 785f 696f 2e68 0000 0000  e/index_io.h....
00000600: 0000 0000 6638 7e4a 09ee baac 6638 7e4a  ....f8~J....f8~J
00000610: 09ee baac 0000 0000 0000 0000 0000 81a4  ................
00000620: 0000 0000 0000 0000 0000 028b 28a5 62e9  ............(.b.
00000630: d8ab 2917 df07 1787 94d4 a6f0 03b7 3d5f  ..)...........=_
00000640: 0015 696e 636c 7564 652f 6c69 6e6b 6564  ..include/linked
00000650: 5f6c 6973 742e 6800 0000 0000 6638 7e4a  _list.h.....f8~J
00000660: 09ee baac 6638 7e4a 09ee baac 0000 0000  ....f8~J........
00000670: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000680: 0000 005d 195a e220 0c35 b38b 10e2 bae2  ...].Z. .5......
00000690: 813c 2ed4 d68c 7f46 000d 696e 636c 7564  .<.....F..includ
000006a0: 652f 6c6f 672e 6800 0000 0000 6638 7e4a  e/log.h.....f8~J
000006b0: 09fe 0bc4 6638 824c 2b4e 3524 0000 0000  ....f8.L+N5$....
000006c0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000006d0: 0000 05cb 6d94 a2d8 9d06 9936 4f43 8fb5  ....m......6OC..
000006e0: 95c7 4daa 97f4 460c 0013 696e 636c 7564  ..M...F...includ
000006f0: 652f 6f62 6a65 6374 5f69 6f2e 6800 0000  e/object_io.h...
00000700: 0000 0000 6638 7e4a 09fe 0bc4 6638 7e4a  ....f8~J....f8~J
00000710: 09fe 0bc4 0000 0000 0000 0000 0000 81a4  ................
00000720: 0000 0000 0000 0000 0000 020f 95db 7f58  ...............X
00000730: 650f 75d1 90ee 5f2c 9f54 ccb3 4e10 14e3  e.u..._,.T..N...
00000740: 000e 696e 636c 7564 652f 7075 7368 2e68  ..include/push.h
00000750: 0000 0000 6638 7e4a 09fe 0bc4 6638 7e4a  ....f8~J....f8~J
00000760: 09fe 0bc4 0000 0000 0000 0000 0000 81a4  ................
00000770: 0000 0000 0000 0000 0000 028e c508 3f38  ..............?8
00000780: 06b0 0198 d0eb a4c6 6551 f2cd 1fe3 6962  ........eQ....ib
00000790: 0010 696e 636c 7564 652f 7265 665f 696f  ..include/ref_io
000007a0: 2e68 0000 6638 7e4a 09fe 0bc4 6638 7e4a  .h..f8~J....f8~J
000007b0: 0a0d 550c 0000 0000 0000 0000 0000 81a4  ..U.............
000007c0: 0000 0000 0000 0000 0000 0058 2e76 99cc  ...........X.v..
000007d0: 5b1f 9deb d233 cee2 4b4d 014a d94b 91b5  [....3..KM.J.K..
000007e0: 0010 696e 636c 7564 652f 7374 6174 7573  ..include/status
000007f0: 2e68 0000 6638 7e4a 0a0d 550c 6638 7e4a  .h..f8~J..U.f8~J
00000800: 0a0d 550c 0000 0000 0000 0000 0000 81a4  ..U.............
00000810: 0000 0000 0000 0000 0000 2033 d2e8 378d  .......... 3..7.
00000820: ce98 eb67 cdaa 9b41 eb3f ac0e 0747 b336  ...g...A.?...G.6
00000830: 0013 696e 636c 7564 652f 7472 616e 7370  ..include/transp
00000840: 6f72 742e 6800 0000 0000 0000 6638 7e4a  ort.h.......f8~J
00000850: 0a0d 550c 6638 7e4a 0a0d 550c 0000 0000  ..U.f8~J..U.....
00000860: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000870: 0000 0394 5f12 1ca1 de30 c34f 6789 ccd7  ...._....0.Og...
00000880: 326c 1271 6585 1dd8 000e 696e 636c 7564  2l.qe.....includ
00000890: 652f 7574 696c 2e68 0000 0000 6638 7e4a  e/util.h....f8~J
000008a0: 0a1c 6eac 6638 7e4a 0a1c 6eac 0000 0000  ..n.f8~J..n.....
000008b0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000008c0: 0000 0005 e4a7 dd9d 0225 aed2 8294 d662  .........%.....b
000008d0: 45dd 544e 5006 867e 0006 6c6f 6c73 6b69  E.TNP..~..lolski
000008e0: 0000 0000 6638 7e4a 0a1c 6eac 6638 7e4a  ....f8~J..n.f8~J
000008f0: 0a1c 6eac 0000 0000 0000 0000 0000 81a4  ..n.............
00000900: 0000 0000 0000 0000 0000 0009 6b5f b247  ............k_.G
00000910: 7e1d 0f23 7869 1d22 0fa2 d80f fd3a adce  ~..#xi.".....:..
00000920: 0007 6c6f 6c73 6b69 3200 0000 6638 7e4a  ..lolski2...f8~J
00000930: 0a2b b984 6638 7e4a 0a2b b984 0000 0000  .+..f8~J.+......
00000940: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000950: 0000 0000 e69d e29b b2d1 d643 4b8b 29ae  ...........CK.).
00000960: 775a d8c2 e48c 5391 000c 6f75 742f 2e67  wZ....S...out/.g
00000970: 6974 6b65 6570 0000 0000 0000 6638 7e4a  itkeep......f8~J
00000980: 0a2b b984 6639 65d0 2d53 9724 0000 0000  .+..f9e.-S.$....
00000990: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000009a0: 0000 27ea 5b31 be68 2b21 efce 8919 abed  ..'.[1.h+!......
000009b0: 17d2 442c 9cd0 171c 0009 7372 632f 6164  ..D,......src/ad
000009c0: 642e 6300 6638 7e4a 0a3a f7dc 6638 7e4a  d.c.f8~J.:..f8~J
000009d0: 0a3a f7dc 0000 0000 0000 0000 0000 81a4  .:..............
000009e0: 0000 0000 0000 0000 0000 017a 98a5 c556  ...........z...V
000009f0: d0c6 a88c ae1a 9482 d143 46b9 e507 d670  .........CF....p
00000a00: 000a 7372 632f 6272 7568 2e63 0000 0000  ..src/bruh.c....
00000a10: 0000 0000 6638 7e4a 0a59 8ad0 6638 7e4a  ....f8~J.Y..f8~J
00000a20: 0a68 cd74 0000 0000 0000 0000 0000 81a4  .h.t............
00000a30: 0000 0000 0000 0000 0003 dc9f 68aa 3344  ............h.3D
00000a40: 1b2d 7a26 86f2 a1f3 caf9 72f6 b495 09f5  .-z&......r.....
00000a50: 000c 7372 632f 6272 7568 2e65 7865 0000  ..src/bruh.exe..
00000a60: 0000 0000 6638 7e4a 0a68 cd74 6638 7e4a  ....f8~J.h.tf8~J
00000a70: 0a78 0bcc 0000 0000 0000 0000 0000 81a4  .x..............
00000a80: 0000 0000 0000 0000 0000 00e8 c855 383c  .............U8<
00000a90: 5bab edd7 0eeb ec59 e020 c9bc 4364 62ff  [......Y. ..Cdb.
00000aa0: 000e 7372 632f 6368 6563 6b6f 7574 2e63  ..src/checkout.c
00000ab0: 0000 0000 6638 7e4a 0a78 0bcc 6639 5c7e  ....f8~J.x..f9\~
00000ac0: 11e9 3ea8 0000 0000 0000 0000 0000 81a4  ..>.............
00000ad0: 0000 0000 0000 0000 0000 1772 6948 38c1  ...........riH8.
00000ae0: cb78 6d7d 5e23 79c6 0b23 6dac 3dbb aa35  .xm}^#y..#m.=..5
00000af0: 000c 7372 632f 636f 6d6d 6974 2e63 0000  ..src/commit.c..
00000b00: 0000 0000 6638 7e4a 0a87 4894 6638 7e4a  ....f8~J..H.f8~J
00000b10: 0a87 4894 0000 0000 0000 0000 0000 81a4  ..H.............
00000b20: 0000 0000 0000 0000 0000 293c b549 1173  ..........)<.I.s
00000b30: 98f3 6f97 9a65 c013 363b 0157 910d f31d  ..o..e..6;.W....
00000b40: 000f 7372 632f 636f 6e66 6967 5f69 6f2e  ..src/config_io.
00000b50: 6300 0000 6638 7e4a 0a87 4894 6638 7e4a  c...f8~J..H.f8~J
00000b60: 0a87 4894 0000 0000 0000 0000 0000 81a4  ..H.............
00000b70: 0000 0000 0000 0000 0000 0474 c3fb 8e67  ...........t...g
00000b80: ac04 95c6 13ac 3993 f24e c791 8e8e f4ae  ......9..N......
00000b90: 000b 7372 632f 6665 7463 682e 6300 0000  ..src/fetch.c...
00000ba0: 0000 0000 6638 7e4a 0a96 85c0 6638 7e4a  ....f8~J....f8~J
00000bb0: 0a96 85c0 0000 0000 0000 0000 0000 81a4  ................
00000bc0: 0000 0000 0000 0000 0000 0f82 75a5 0392  ............u...
00000bd0: 3dfa 1abe d217 1ecf 2967 68b2 438e 6334  =.......)gh.C.c4
00000be0: 0010 7372 632f 6861 7368 5f74 6162 6c65  ..src/hash_table
00000bf0: 2e63 0000 6638 93a1 279a 9f80 6638 93a1  .c..f8..'...f8..
00000c00: 279a 9f80 0000 0000 0000 0000 0000 81a4  '...............
00000c10: 0000 0000 0000 0000 0000 0000 e69d e29b  ................
00000c20: b2d1 d643 4b8b 29ae 775a d8c2 e48c 5391  ...CK.).wZ....S.
00000c30: 0011 7372 632f 686d 6d6d 6d2f 6161 612e  ..src/hmmmm/aaa.
00000c40: 7478 7400 6638 93a9 2479 f850 6638 93a9  txt.f8..$y.Pf8..
00000c50: 2479 f850 0000 0000 0000 0000 0000 81a4  $y.P............
00000c60: 0000 0000 0000 0000 0000 0000 e69d e29b  ................
00000c70: b2d1 d643 4b8b 29ae 775a d8c2 e48c 5391  ...CK.).wZ....S.
00000c80: 0010 7372 632f 686d 6d6d 6d2f 6262 2e74  ..src/hmmmm/bb.t
00000c90: 7874 0000 6638 93fd 2714 34f4 6638 93fd  xt..f8..'.4.f8..
00000ca0: 2714 34f4 0000 0000 0000 0000 0000 81a4  '.4.............
00000cb0: 0000 0000 0000 0000 0000 0000 e69d e29b  ................
00000cc0: b2d1 d643 4b8b 29ae 775a d8c2 e48c 5391  ...CK.).wZ....S.
00000cd0: 0018 7372 632f 686d 6d6d 6d2f 6272 7568  ..src/hmmmm/bruh
00000ce0: 6868 682f 686d 2e74 7874 0000 6638 93b8  hhh/hm.txt..f8..
00000cf0: 120b 815c 6638 93b8 120b 815c 0000 0000  ...\f8.....\....
00000d00: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000d10: 0000 0000 e69d e29b b2d1 d643 4b8b 29ae  ...........CK.).
00000d20: 775a d8c2 e48c 5391 0017 7372 632f 686d  wZ....S...src/hm
00000d30: 6d6d 6d2f 6e6f 6f6f 6f2f 6363 632e 7478  mmm/noooo/ccc.tx
00000d40: 7400 0000 6638 7e4a 0a96 85c0 6639 64ba  t...f8~J....f9d.
00000d50: 1bd3 90d0 0000 0000 0000 0000 0000 81a4  ................
00000d60: 0000 0000 0000 0000 0000 1985 789e 1d3c  ............x..<
00000d70: 5ce8 cfa2 620e 7cd0 1eda 2c42 cd00 9bbe  \...b.|...,B....
00000d80: 000e 7372 632f 696e 6465 785f 696f 2e63  ..src/index_io.c
00000d90: 0000 0000 6638 7e4a 0a96 85c0 6638 7e4a  ....f8~J....f8~J
00000da0: 0aa5 c1c0 0000 0000 0000 0000 0000 81a4  ................
00000db0: 0000 0000 0000 0000 0000 0de2 27e3 27a8  ............'.'.
00000dc0: d2dc ebbb 9d4e 31dd 0649 b480 231c 6829  .....N1..I..#.h)
00000dd0: 0011 7372 632f 6c69 6e6b 6564 5f6c 6973  ..src/linked_lis
00000de0: 742e 6300 6638 7e4a 0aa5 c1c0 6638 9384  t.c.f8~J....f8..
00000df0: 1d48 0284 0000 0000 0000 0000 0000 81a4  .H..............
00000e00: 0000 0000 0000 0000 0000 012e f196 c3ba  ................
00000e10: f53d f665 0751 3f3d 4e90 0c03 a75a c3d6  .=.e.Q?=N....Z..
00000e20: 0009 7372 632f 6c6f 672e 6300 6638 7e4a  ..src/log.c.f8~J
00000e30: 0aa5 c1c0 6638 7e4a 0aa5 c1c0 0000 0000  ....f8~J........
00000e40: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000e50: 0000 0159 32a0 fd8c 8525 3a23 34d7 f74d  ...Y2....%:#4..M
00000e60: 814b ae56 6b49 36ba 000a 7372 632f 6d61  .K.VkI6...src/ma
00000e70: 696e 2e63 0000 0000 0000 0000 6638 7e4a  in.c........f8~J
00000e80: 0ab5 00e0 6638 7e4a 0ac4 4a8c 0000 0000  ....f8~J..J.....
00000e90: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000ea0: 0003 dbf0 886e 85f8 561f aa5c ee80 3eda  .....n..V..\..>.
00000eb0: 7043 f22d 5403 c29e 000c 7372 632f 6d61  pC.-T.....src/ma
00000ec0: 696e 2e65 7865 0000 0000 0000 6638 7e4a  in.exe......f8~J
00000ed0: 0ac4 4a8c 6638 8e6b 2443 c294 0000 0000  ..J.f8.k$C......
00000ee0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000ef0: 0000 1b75 ae4a 7ac7 c829 2cc9 f59a 72b7  ...u.Jz..),...r.
00000f00: afa1 bdf4 110b 7bdd 000b 7372 632f 6d79  ......{...src/my
00000f10: 6769 742e 6300 0000 0000 0000 6638 7e4a  git.c.......f8~J
00000f20: 0ad3 a054 6638 7e4a 0ad3 a054 0000 0000  ...Tf8~J...T....
00000f30: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000f40: 0000 405e 42f0 cbec 501f dfc3 b348 1416  ..@^B...P....H..
00000f50: f582 f1eb 9d19 852d 000f 7372 632f 6f62  .......-..src/ob
00000f60: 6a65 6374 5f69 6f2e 6300 0000 6638 7e4a  ject_io.c...f8~J
00000f70: 0ad3 a054 6638 7e4a 0ad3 a054 0000 0000  ...Tf8~J...T....
00000f80: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000f90: 0000 01df dd34 35e5 c0e4 0a96 7dbe f4dd  .....45.....}...
00000fa0: 26e8 d3b9 5b7c 580f 000a 7372 632f 7075  &...[|X...src/pu
00000fb0: 7368 2e63 0000 0000 0000 0000 6638 7e4a  sh.c........f8~J
00000fc0: 0ad3 a054 6638 7e4a 0ae2 dd80 0000 0000  ...Tf8~J........
00000fd0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000fe0: 0000 12c3 3c14 d2b8 3578 aebc 9c4d 880d  ....<...5x...M..
00000ff0: 70b4 60e7 3f55 045e 000c 7372 632f 7265  p.`.?U.^..src/re
00001000: 665f 696f 2e63 0000 0000 0000 6638 7e4a  f_io.c......f8~J
00001010: 0ae2 dd80 6638 7e4a 0ae2 dd80 0000 0000  ....f8~J........
00001020: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00001030: 0000 156e 9198 d74e 2819 ad48 a4fd 7f97  ...n...N(..H....
00001040: 70db fbaa abc0 5cab 000c 7372 632f 7374  p.....\...src/st
00001050: 6174 7573 2e63 0000 0000 0000 6638 7e4a  atus.c......f8~J
00001060: 0ae2 dd80 6638 7e4a 0af2 2470 0000 0000  ....f8~J..$p....
00001070: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00001080: 0000 8202 5637 785d 7573 777f 1c83 60af  ....V7x]usw...`.
00001090: a212 ff8a 076d bd08 000f 7372 632f 7472  .....m....src/tr
000010a0: 616e 7370 6f72 742e 6300 0000 6638 7e4a  ansport.c...f8~J
000010b0: 0af2 2470 6638 7e4a 0af2 2470 0000 0000  ..$pf8~J..$p....
000010c0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000010d0: 0000 0e63 3bfb 963f 6fd9 e5b7 629c 2092  ...c;..?o...b. .
000010e0: c805 519b f9a3 37ba 000a 7372 632f 7574  ..Q...7...src/ut
000010f0: 696c 2e63 0000 0000 0000 0000 6638 7e4a  il.c........f8~J
00001100: 0af2 2470 6638 7e4a 0af2 2470 0000 0000  ..$pf8~J..$p....
00001110: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00001120: 0000 2551 e0d8 cfb7 361f daae dc33 a377  ..%Q....6....3.w
00001130: 2fd4 0945 8d6b def8 000c 7372 632f 7772  /..E.k....src/wr
00001140: 6974 6572 2e63 0000 0000 0000 6638 800a  iter.c......f8..
00001150: 2ae3 342c 6639 6585 1f59 97f4 0000 0000  *.4,f9e..Y......
00001160: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00001170: 0000 1234 8883 79cb 8696 1c8b 4141 838b  ...4..y.....AA..
00001180: 4303 f9a5 b790 db9b 000d 7465 6d70 5f69  C.........temp_i
00001190: 6478 5f66 696c 6500 0000 0000 6638 7e4a  dx_file.....f8~J
000011a0: 0b01 506c 6638 7e4a 0b01 506c 0000 0000  ..Plf8~J..Pl....
000011b0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000011c0: 0000 3618 72f6 4a47 c3ec 60bc 83f2 574e  ..6.r.JG..`...WN
000011d0: a5c5 fc10 51c0 1f0a 000b 7465 6d70 5f6c  ....Q.....temp_l
000011e0: 6f6c 736b 6900 0000 0000 0000 6638 7e4a  olski.......f8~J
000011f0: 0b01 506c 6638 7e4a 0b01 506c 0000 0000  ..Plf8~J..Pl....
00001200: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00001210: 0000 0000 e69d e29b b2d1 d643 4b8b 29ae  ...........CK.).
00001220: 775a d8c2 e48c 5391 0009 7465 7374 7465  wZ....S...testte
00001230: 7374 3200 5452 4545 0000 00ec 0035 3820  st2.TREE.....58 
00001240: 340a a13e b26b 7b32 d849 bf95 2863 c8df  4..>.k{2.I..(c..
00001250: 4676 b5f0 0efb 6269 6e00 3120 300a d564  Fv....bin.1 0..d
00001260: d0bc 3dd9 1792 6892 c55e 3706 cc11 6d5b  ..=...h..^7...m[
00001270: 165e 6f75 7400 3120 300a d564 d0bc 3dd9  .^out.1 0..d..=.
00001280: 1792 6892 c55e 3706 cc11 6d5b 165e 7372  ..h..^7...m[.^sr
00001290: 6300 3235 2031 0ab1 a35b ae21 ab33 9b93  c.25 1...[.!.3..
000012a0: 9c61 bb33 8dd7 ba6f a4d0 a868 6d6d 6d6d  .a.3...o...hmmmm
000012b0: 0034 2032 0aba 5a38 062e f0a7 e1a5 a83b  .4 2..Z8.......;
000012c0: f03b df30 8b98 5c7f fa6e 6f6f 6f6f 0031  .;.0..\..noooo.1
000012d0: 2030 0a26 0993 3801 6104 b1a9 0a29 17c6   0.&..8.a....)..
000012e0: 07b1 593e 776c 7662 7275 6868 6868 0031  ..Y>wlvbruhhhh.1
000012f0: 2030 0a28 5859 f7e8 6fd5 928d a0b9 6002   0.(XY..o.....`.
00001300: f568 894b af48 5169 6e63 6c75 6465 0031  .h.K.HQinclude.1
00001310: 3620 300a 5407 73ac 6642 449c 0601 0f61  6 0.T.s.fBD....a
00001320: caa5 638a e4ec 8768 ba87 f07d 5d9e 8539  ..c....h...}]..9
00001330: abde e8c2 16f4 e73d 431f dc80            .......=C...

filename: bruh.exe

contents: 
 MZï¿½
filename: bruh2

contents: 
 00000000: 4449 5243 0000 0002 0000 003a 0000 0000  DIRC.......:....
00000010: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
00000020: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000030: 0000 001d ec17 f0ef 9a3c 55b1 cb1b e43f  .........<U....?
00000040: 838d 8a8b 06fe cf43 000a 2e67 6974 6967  .......C...gitig
00000050: 6e6f 7265 0000 0000 0000 0000 0000 0000  nore............
00000060: 0000 0000 6638 7eca 0000 0000 0000 0000  ....f8~.........
00000070: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000080: 0000 10de 2ba1 bc6f 6b55 822d cf5e f8bd  ....+..okU.-.^..
00000090: f294 9949 d94b 929d 0009 2e67 6974 696e  ...I.K.....gitin
000000a0: 6465 7800 0000 0000 0000 0000 6638 7e4a  dex.........f8~J
000000b0: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
000000c0: 0000 0000 0000 0000 0000 0068 2b1e ecb1  ...........h+...
000000d0: 8230 8355 0dc3 2057 73d6 761f b847 d58a  .0.U.. Ws.v..G..
000000e0: 000e 2e67 6974 6c61 622d 6369 2e79 6d6c  ...gitlab-ci.yml
000000f0: 0000 0000 0000 0000 0000 0000 6639 6520  ............f9e 
00000100: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000110: 0000 0000 0000 0000 0000 0312 0ce5 9d52  ...............R
00000120: 00b6 8d90 c0e8 3bab 6b1e 47df 64a9 67a1  ......;.k.G.d.g.
00000130: 0008 4d61 6b65 6669 6c65 0000 0000 0000  ..Makefile......
00000140: 0000 0000 6639 6232 0000 0000 0000 0000  ....f9b2........
00000150: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000160: 0000 0000 e69d e29b b2d1 d643 4b8b 29ae  ...........CK.).
00000170: 775a d8c2 e48c 5391 0014 6173 6466 6173  wZ....S...asdfas
00000180: 6466 6173 6466 6173 6466 6173 6466 0000  dfasdfasdfasdf..
00000190: 0000 0000 0000 0000 0000 0000 6639 62e3  ............f9b.
000001a0: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
000001b0: 0000 0000 0000 0000 0000 0000 e69d e29b  ................
000001c0: b2d1 d643 4b8b 29ae 775a d8c2 e48c 5391  ...CK.).wZ....S.
000001d0: 0005 6262 6173 6400 0000 0000 0000 0000  ..bbasd.........
000001e0: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
000001f0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000200: 0000 0000 e69d e29b b2d1 d643 4b8b 29ae  ...........CK.).
00000210: 775a d8c2 e48c 5391 000c 6269 6e2f 2e67  wZ....S...bin/.g
00000220: 6974 6b65 6570 0000 0000 0000 0000 0000  itkeep..........
00000230: 0000 0000 6639 6390 0000 0000 0000 0000  ....f9c.........
00000240: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000250: 0000 283f 7d23 ba94 21b3 a580 f204 f35c  ..(?}#..!......\
00000260: 8f36 b386 9972 efa5 0004 6272 7568 0000  .6...r....bruh..
00000270: 0000 0000 0000 0000 0000 0000 6638 7e4a  ............f8~J
00000280: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000290: 0000 0000 0000 0000 0003 ed01 4d88 a063  ............M..c
000002a0: a8d0 a466 c3cd d755 4abe 5cd6 c8d9 b102  ...f...UJ.\.....
000002b0: 0008 6272 7568 2e65 7865 0000 0000 0000  ..bruh.exe......
000002c0: 0000 0000 6639 63fe 0000 0000 0000 0000  ....f9c.........
000002d0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000002e0: 0000 2297 1caf c675 4afe ffb3 e08e e118  .."....uJ.......
000002f0: 3dc4 de50 fd33 22da 0005 6272 7568 3200  =..P.3"...bruh2.
00000300: 0000 0000 0000 0000 0000 0000 6638 7e4a  ............f8~J
00000310: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000320: 0000 0000 0000 0000 0000 032d 6f91 3a11  ...........-o.:.
00000330: ff73 fa38 a029 33e9 675d 794f 1ae5 cf6b  .s.8.)3.g]yO...k
00000340: 0014 6578 7061 6e64 2d61 6c6c 2d70 6163  ..expand-all-pac
00000350: 6b66 696c 6573 0000 0000 0000 0000 0000  kfiles..........
00000360: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
00000370: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000380: 0000 00b7 661e 87d5 5a4c 835c 68ec 9259  ....f...ZL.\h..Y
00000390: 4c4c 0a5c 3659 5813 000d 696e 636c 7564  LL.\6YX...includ
000003a0: 652f 6164 642e 6800 0000 0000 0000 0000  e/add.h.........
000003b0: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
000003c0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000003d0: 0000 0089 b950 eeae 8aea 44e7 eb85 c11d  .....P....D.....
000003e0: fcdc b090 4c8b 90bd 0012 696e 636c 7564  ....L.....includ
000003f0: 652f 6368 6563 6b6f 7574 2e68 0000 0000  e/checkout.h....
00000400: 0000 0000 0000 0000 0000 0000 6638 7e4a  ............f8~J
00000410: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000420: 0000 0000 0000 0000 0000 005a 979c c48f  ...........Z....
00000430: aea9 e840 7f48 58d6 9b37 239c 7a50 9066  ...@.HX..7#.zP.f
00000440: 0010 696e 636c 7564 652f 636f 6d6d 6974  ..include/commit
00000450: 2e68 0000 0000 0000 0000 0000 6638 7e4a  .h..........f8~J
00000460: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000470: 0000 0000 0000 0000 0000 0512 21dc 5a14  ............!.Z.
00000480: 662b eb22 12e6 721d b17d 95ad ae36 7185  f+."..r..}...6q.
00000490: 0013 696e 636c 7564 652f 636f 6e66 6967  ..include/config
000004a0: 5f69 6f2e 6800 0000 0000 0000 0000 0000  _io.h...........
000004b0: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
000004c0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000004d0: 0000 0164 a5b8 e44f 9eba 70b7 3bdc d4d3  ...d...O..p.;...
000004e0: 4ac3 5f49 5463 90fe 0013 696e 636c 7564  J._ITc....includ
000004f0: 652f 636f 6e73 7461 6e74 732e 6800 0000  e/constants.h...
00000500: 0000 0000 0000 0000 0000 0000 6638 7e4a  ............f8~J
00000510: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000520: 0000 0000 0000 0000 0000 007e 648f 7b51  ...........~d.{Q
00000530: fd6e 2d13 d00a c0a3 f4da 4cbc 7a46 1317  .n-.......L.zF..
00000540: 000f 696e 636c 7564 652f 6665 7463 682e  ..include/fetch.
00000550: 6800 0000 0000 0000 0000 0000 6638 7e4a  h...........f8~J
00000560: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000570: 0000 0000 0000 0000 0000 02c3 8fd0 7fb3  ................
00000580: 9a87 83db 3050 b916 2327 f76f db63 64df  ....0P..#'.o.cd.
00000590: 0014 696e 636c 7564 652f 6861 7368 5f74  ..include/hash_t
000005a0: 6162 6c65 2e68 0000 0000 0000 0000 0000  able.h..........
000005b0: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
000005c0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000005d0: 0000 025c 676c 7e72 1706 e252 853d 2eae  ...\gl~r...R.=..
000005e0: 9cd8 a79d 8793 e0d2 0012 696e 636c 7564  ..........includ
000005f0: 652f 696e 6465 785f 696f 2e68 0000 0000  e/index_io.h....
00000600: 0000 0000 0000 0000 0000 0000 6638 7e4a  ............f8~J
00000610: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000620: 0000 0000 0000 0000 0000 028b 28a5 62e9  ............(.b.
00000630: d8ab 2917 df07 1787 94d4 a6f0 03b7 3d5f  ..)...........=_
00000640: 0015 696e 636c 7564 652f 6c69 6e6b 6564  ..include/linked
00000650: 5f6c 6973 742e 6800 0000 0000 0000 0000  _list.h.........
00000660: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
00000670: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000680: 0000 005d 195a e220 0c35 b38b 10e2 bae2  ...].Z. .5......
00000690: 813c 2ed4 d68c 7f46 000d 696e 636c 7564  .<.....F..includ
000006a0: 652f 6c6f 672e 6800 0000 0000 0000 0000  e/log.h.........
000006b0: 0000 0000 6638 824c 0000 0000 0000 0000  ....f8.L........
000006c0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000006d0: 0000 05cb 6d94 a2d8 9d06 9936 4f43 8fb5  ....m......6OC..
000006e0: 95c7 4daa 97f4 460c 0013 696e 636c 7564  ..M...F...includ
000006f0: 652f 6f62 6a65 6374 5f69 6f2e 6800 0000  e/object_io.h...
00000700: 0000 0000 0000 0000 0000 0000 6638 7e4a  ............f8~J
00000710: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000720: 0000 0000 0000 0000 0000 020f 95db 7f58  ...............X
00000730: 650f 75d1 90ee 5f2c 9f54 ccb3 4e10 14e3  e.u..._,.T..N...
00000740: 000e 696e 636c 7564 652f 7075 7368 2e68  ..include/push.h
00000750: 0000 0000 0000 0000 0000 0000 6638 7e4a  ............f8~J
00000760: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000770: 0000 0000 0000 0000 0000 028e c508 3f38  ..............?8
00000780: 06b0 0198 d0eb a4c6 6551 f2cd 1fe3 6962  ........eQ....ib
00000790: 0010 696e 636c 7564 652f 7265 665f 696f  ..include/ref_io
000007a0: 2e68 0000 0000 0000 0000 0000 6638 7e4a  .h..........f8~J
000007b0: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
000007c0: 0000 0000 0000 0000 0000 0058 2e76 99cc  ...........X.v..
000007d0: 5b1f 9deb d233 cee2 4b4d 014a d94b 91b5  [....3..KM.J.K..
000007e0: 0010 696e 636c 7564 652f 7374 6174 7573  ..include/status
000007f0: 2e68 0000 0000 0000 0000 0000 6638 7e4a  .h..........f8~J
00000800: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000810: 0000 0000 0000 0000 0000 2033 d2e8 378d  .......... 3..7.
00000820: ce98 eb67 cdaa 9b41 eb3f ac0e 0747 b336  ...g...A.?...G.6
00000830: 0013 696e 636c 7564 652f 7472 616e 7370  ..include/transp
00000840: 6f72 742e 6800 0000 0000 0000 0000 0000  ort.h...........
00000850: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
00000860: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000870: 0000 0394 5f12 1ca1 de30 c34f 6789 ccd7  ...._....0.Og...
00000880: 326c 1271 6585 1dd8 000e 696e 636c 7564  2l.qe.....includ
00000890: 652f 7574 696c 2e68 0000 0000 0000 0000  e/util.h........
000008a0: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
000008b0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000008c0: 0000 0005 e4a7 dd9d 0225 aed2 8294 d662  .........%.....b
000008d0: 45dd 544e 5006 867e 0006 6c6f 6c73 6b69  E.TNP..~..lolski
000008e0: 0000 0000 0000 0000 0000 0000 6638 7e4a  ............f8~J
000008f0: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000900: 0000 0000 0000 0000 0000 0009 6b5f b247  ............k_.G
00000910: 7e1d 0f23 7869 1d22 0fa2 d80f fd3a adce  ~..#xi.".....:..
00000920: 0007 6c6f 6c73 6b69 3200 0000 0000 0000  ..lolski2.......
00000930: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
00000940: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000950: 0000 0000 e69d e29b b2d1 d643 4b8b 29ae  ...........CK.).
00000960: 775a d8c2 e48c 5391 000c 6f75 742f 2e67  wZ....S...out/.g
00000970: 6974 6b65 6570 0000 0000 0000 0000 0000  itkeep..........
00000980: 0000 0000 6639 650c 0000 0000 0000 0000  ....f9e.........
00000990: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000009a0: 0000 27e9 e762 c6d6 567d 0733 60e6 67b0  ..'..b..V}.3`.g.
000009b0: 50fd cc38 3502 4487 0009 7372 632f 6164  P..85.D...src/ad
000009c0: 642e 6300 0000 0000 0000 0000 6638 7e4a  d.c.........f8~J
000009d0: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
000009e0: 0000 0000 0000 0000 0000 017a 98a5 c556  ...........z...V
000009f0: d0c6 a88c ae1a 9482 d143 46b9 e507 d670  .........CF....p
00000a00: 000a 7372 632f 6272 7568 2e63 0000 0000  ..src/bruh.c....
00000a10: 0000 0000 0000 0000 0000 0000 6638 7e4a  ............f8~J
00000a20: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000a30: 0000 0000 0000 0000 0003 dc9f 68aa 3344  ............h.3D
00000a40: 1b2d 7a26 86f2 a1f3 caf9 72f6 b495 09f5  .-z&......r.....
00000a50: 000c 7372 632f 6272 7568 2e65 7865 0000  ..src/bruh.exe..
00000a60: 0000 0000 0000 0000 0000 0000 6638 7e4a  ............f8~J
00000a70: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000a80: 0000 0000 0000 0000 0000 00e8 c855 383c  .............U8<
00000a90: 5bab edd7 0eeb ec59 e020 c9bc 4364 62ff  [......Y. ..Cdb.
00000aa0: 000e 7372 632f 6368 6563 6b6f 7574 2e63  ..src/checkout.c
00000ab0: 0000 0000 0000 0000 0000 0000 6639 5c7e  ............f9\~
00000ac0: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000ad0: 0000 0000 0000 0000 0000 1772 6948 38c1  ...........riH8.
00000ae0: cb78 6d7d 5e23 79c6 0b23 6dac 3dbb aa35  .xm}^#y..#m.=..5
00000af0: 000c 7372 632f 636f 6d6d 6974 2e63 0000  ..src/commit.c..
00000b00: 0000 0000 0000 0000 0000 0000 6638 7e4a  ............f8~J
00000b10: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000b20: 0000 0000 0000 0000 0000 293c b549 1173  ..........)<.I.s
00000b30: 98f3 6f97 9a65 c013 363b 0157 910d f31d  ..o..e..6;.W....
00000b40: 000f 7372 632f 636f 6e66 6967 5f69 6f2e  ..src/config_io.
00000b50: 6300 0000 0000 0000 0000 0000 6638 7e4a  c...........f8~J
00000b60: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000b70: 0000 0000 0000 0000 0000 0474 c3fb 8e67  ...........t...g
00000b80: ac04 95c6 13ac 3993 f24e c791 8e8e f4ae  ......9..N......
00000b90: 000b 7372 632f 6665 7463 682e 6300 0000  ..src/fetch.c...
00000ba0: 0000 0000 0000 0000 0000 0000 6638 7e4a  ............f8~J
00000bb0: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000bc0: 0000 0000 0000 0000 0000 0f82 75a5 0392  ............u...
00000bd0: 3dfa 1abe d217 1ecf 2967 68b2 438e 6334  =.......)gh.C.c4
00000be0: 0010 7372 632f 6861 7368 5f74 6162 6c65  ..src/hash_table
00000bf0: 2e63 0000 0000 0000 0000 0000 6638 93a1  .c..........f8..
00000c00: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000c10: 0000 0000 0000 0000 0000 0000 e69d e29b  ................
00000c20: b2d1 d643 4b8b 29ae 775a d8c2 e48c 5391  ...CK.).wZ....S.
00000c30: 0011 7372 632f 686d 6d6d 6d2f 6161 612e  ..src/hmmmm/aaa.
00000c40: 7478 7400 0000 0000 0000 0000 6638 93a9  txt.........f8..
00000c50: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000c60: 0000 0000 0000 0000 0000 0000 e69d e29b  ................
00000c70: b2d1 d643 4b8b 29ae 775a d8c2 e48c 5391  ...CK.).wZ....S.
00000c80: 0010 7372 632f 686d 6d6d 6d2f 6262 2e74  ..src/hmmmm/bb.t
00000c90: 7874 0000 0000 0000 0000 0000 6638 93fd  xt..........f8..
00000ca0: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000cb0: 0000 0000 0000 0000 0000 0000 e69d e29b  ................
00000cc0: b2d1 d643 4b8b 29ae 775a d8c2 e48c 5391  ...CK.).wZ....S.
00000cd0: 0018 7372 632f 686d 6d6d 6d2f 6272 7568  ..src/hmmmm/bruh
00000ce0: 6868 682f 686d 2e74 7874 0000 0000 0000  hhh/hm.txt......
00000cf0: 0000 0000 6638 93b8 0000 0000 0000 0000  ....f8..........
00000d00: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000d10: 0000 0000 e69d e29b b2d1 d643 4b8b 29ae  ...........CK.).
00000d20: 775a d8c2 e48c 5391 0017 7372 632f 686d  wZ....S...src/hm
00000d30: 6d6d 6d2f 6e6f 6f6f 6f2f 6363 632e 7478  mmm/noooo/ccc.tx
00000d40: 7400 0000 0000 0000 0000 0000 6639 64ba  t...........f9d.
00000d50: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000d60: 0000 0000 0000 0000 0000 1985 789e 1d3c  ............x..<
00000d70: 5ce8 cfa2 620e 7cd0 1eda 2c42 cd00 9bbe  \...b.|...,B....
00000d80: 000e 7372 632f 696e 6465 785f 696f 2e63  ..src/index_io.c
00000d90: 0000 0000 0000 0000 0000 0000 6638 7e4a  ............f8~J
00000da0: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000db0: 0000 0000 0000 0000 0000 0de2 27e3 27a8  ............'.'.
00000dc0: d2dc ebbb 9d4e 31dd 0649 b480 231c 6829  .....N1..I..#.h)
00000dd0: 0011 7372 632f 6c69 6e6b 6564 5f6c 6973  ..src/linked_lis
00000de0: 742e 6300 0000 0000 0000 0000 6638 9384  t.c.........f8..
00000df0: 0000 0000 0000 0000 0000 0000 0000 81a4  ................
00000e00: 0000 0000 0000 0000 0000 012e f196 c3ba  ................
00000e10: f53d f665 0751 3f3d 4e90 0c03 a75a c3d6  .=.e.Q?=N....Z..
00000e20: 0009 7372 632f 6c6f 672e 6300 0000 0000  ..src/log.c.....
00000e30: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
00000e40: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000e50: 0000 0159 32a0 fd8c 8525 3a23 34d7 f74d  ...Y2....%:#4..M
00000e60: 814b ae56 6b49 36ba 000a 7372 632f 6d61  .K.VkI6...src/ma
00000e70: 696e 2e63 0000 0000 0000 0000 0000 0000  in.c............
00000e80: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
00000e90: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000ea0: 0003 dbf0 886e 85f8 561f aa5c ee80 3eda  .....n..V..\..>.
00000eb0: 7043 f22d 5403 c29e 000c 7372 632f 6d61  pC.-T.....src/ma
00000ec0: 696e 2e65 7865 0000 0000 0000 0000 0000  in.exe..........
00000ed0: 0000 0000 6638 8e6b 0000 0000 0000 0000  ....f8.k........
00000ee0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000ef0: 0000 1b75 ae4a 7ac7 c829 2cc9 f59a 72b7  ...u.Jz..),...r.
00000f00: afa1 bdf4 110b 7bdd 000b 7372 632f 6d79  ......{...src/my
00000f10: 6769 742e 6300 0000 0000 0000 0000 0000  git.c...........
00000f20: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
00000f30: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000f40: 0000 405e 42f0 cbec 501f dfc3 b348 1416  ..@^B...P....H..
00000f50: f582 f1eb 9d19 852d 000f 7372 632f 6f62  .......-..src/ob
00000f60: 6a65 6374 5f69 6f2e 6300 0000 0000 0000  ject_io.c.......
00000f70: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
00000f80: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000f90: 0000 01df dd34 35e5 c0e4 0a96 7dbe f4dd  .....45.....}...
00000fa0: 26e8 d3b9 5b7c 580f 000a 7372 632f 7075  &...[|X...src/pu
00000fb0: 7368 2e63 0000 0000 0000 0000 0000 0000  sh.c............
00000fc0: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
00000fd0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00000fe0: 0000 12c3 3c14 d2b8 3578 aebc 9c4d 880d  ....<...5x...M..
00000ff0: 70b4 60e7 3f55 045e 000c 7372 632f 7265  p.`.?U.^..src/re
00001000: 665f 696f 2e63 0000 0000 0000 0000 0000  f_io.c..........
00001010: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
00001020: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00001030: 0000 156e 9198 d74e 2819 ad48 a4fd 7f97  ...n...N(..H....
00001040: 70db fbaa abc0 5cab 000c 7372 632f 7374  p.....\...src/st
00001050: 6174 7573 2e63 0000 0000 0000 0000 0000  atus.c..........
00001060: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
00001070: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00001080: 0000 8202 5637 785d 7573 777f 1c83 60af  ....V7x]usw...`.
00001090: a212 ff8a 076d bd08 000f 7372 632f 7472  .....m....src/tr
000010a0: 616e 7370 6f72 742e 6300 0000 0000 0000  ansport.c.......
000010b0: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
000010c0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000010d0: 0000 0e63 3bfb 963f 6fd9 e5b7 629c 2092  ...c;..?o...b. .
000010e0: c805 519b f9a3 37ba 000a 7372 632f 7574  ..Q...7...src/ut
000010f0: 696c 2e63 0000 0000 0000 0000 0000 0000  il.c............
00001100: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
00001110: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00001120: 0000 2551 e0d8 cfb7 361f daae dc33 a377  ..%Q....6....3.w
00001130: 2fd4 0945 8d6b def8 000c 7372 632f 7772  /..E.k....src/wr
00001140: 6974 6572 2e63 0000 0000 0000 0000 0000  iter.c..........
00001150: 0000 0000 6639 6585 0000 0000 0000 0000  ....f9e.........
00001160: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00001170: 0000 1234 73a3 5c47 d72d 359d 77d6 6cf6  ...4s.\G.-5.w.l.
00001180: e174 a8fc b0d1 fe6a 000d 7465 6d70 5f69  .t.....j..temp_i
00001190: 6478 5f66 696c 6500 0000 0000 0000 0000  dx_file.........
000011a0: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
000011b0: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
000011c0: 0000 3618 72f6 4a47 c3ec 60bc 83f2 574e  ..6.r.JG..`...WN
000011d0: a5c5 fc10 51c0 1f0a 000b 7465 6d70 5f6c  ....Q.....temp_l
000011e0: 6f6c 736b 6900 0000 0000 0000 0000 0000  olski...........
000011f0: 0000 0000 6638 7e4a 0000 0000 0000 0000  ....f8~J........
00001200: 0000 0000 0000 81a4 0000 0000 0000 0000  ................
00001210: 0000 0000 e69d e29b b2d1 d643 4b8b 29ae  ...........CK.).
00001220: 775a d8c2 e48c 5391 0009 7465 7374 7465  wZ....S...testte
00001230: 7374 3200                                st2.
ï¿½
filename: bruh3

contents: 
 100644 ec17f0ef9a3c55b1cb1be43f838d8a8b06fecf43 0	.gitignore
  ctime: 1715044282:842332700
  mtime: 1715044282:842332700
  dev: 83	ino: 1646398
  uid: 1000	gid: 1000
  size: 29	flags: 0
100644 2b1eecb1823083550dc3205773d6761fb847d58a 0	.gitlab-ci.yml
  ctime: 1715044282:843371100
  mtime: 1715044282:843371100
  dev: 83	ino: 1665716
  uid: 1000	gid: 1000
  size: 104	flags: 0
100644 d755861c4c925380399a468a5a41f6ddfb0ebcef 0	Makefile
  ctime: 1715046019:345372500
  mtime: 1715046019:345372500
  dev: 83	ino: 1665729
  uid: 1000	gid: 1000
  size: 786	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	bin/.gitkeep
  ctime: 1715044223:777468300
  mtime: 1715044223:777468300
  dev: 83	ino: 1665774
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 9fcf3de803c87def9c440094e401160b52416161 0	bruh
  ctime: 1715046163:284691600
  mtime: 1715046163:284691600
  dev: 83	ino: 1458822
  uid: 1000	gid: 1000
  size: 7284	flags: 0
100644 9fcf3de803c87def9c440094e401160b52416161 0	bruh2
  ctime: 1715046243:715942000
  mtime: 1715046243:715942000
  dev: 83	ino: 73107
  uid: 1000	gid: 1000
  size: 7284	flags: 0
100644 860f7b0a002c7cc715c8aa1ef48aa0c6b687b22e 0	bruh3
  ctime: 1715046507:351630300
  mtime: 1715046507:351630300
  dev: 83	ino: 1684586
  uid: 1000	gid: 1000
  size: 7548	flags: 0
100644 6f913a11ff73fa38a02933e9675d794f1ae5cf6b 0	expand-all-packfiles
  ctime: 1715044282:845337600
  mtime: 1715044282:845337600
  dev: 83	ino: 1665730
  uid: 1000	gid: 1000
  size: 813	flags: 0
100644 661e87d55a4c835c68ec92594c4c0a5c36595813 0	include/add.h
  ctime: 1715044282:846325000
  mtime: 1715044282:846325000
  dev: 83	ino: 1665745
  uid: 1000	gid: 1000
  size: 183	flags: 0
100644 b950eeae8aea44e7eb85c11dfcdcb0904c8b90bd 0	include/checkout.h
  ctime: 1715044282:847404100
  mtime: 1715044282:847404100
  dev: 83	ino: 1665748
  uid: 1000	gid: 1000
  size: 137	flags: 0
100644 979cc48faea9e8407f4858d69b37239c7a509066 0	include/commit.h
  ctime: 1715044282:848323800
  mtime: 1715044282:848323800
  dev: 83	ino: 1665776
  uid: 1000	gid: 1000
  size: 90	flags: 0
100644 21dc5a14662beb2212e6721db17d95adae367185 0	include/config_io.h
  ctime: 1715044282:849330500
  mtime: 1715044282:849330500
  dev: 83	ino: 1665778
  uid: 1000	gid: 1000
  size: 1298	flags: 0
100644 a5b8e44f9eba70b73bdcd4d34ac35f49546390fe 0	include/constants.h
  ctime: 1715044282:850326700
  mtime: 1715044282:850326700
  dev: 83	ino: 1665780
  uid: 1000	gid: 1000
  size: 356	flags: 0
100644 648f7b51fd6e2d13d00ac0a3f4da4cbc7a461317 0	include/fetch.h
  ctime: 1715044282:850326700
  mtime: 1715044282:850326700
  dev: 83	ino: 1665794
  uid: 1000	gid: 1000
  size: 126	flags: 0
100644 8fd07fb39a8783db3050b9162327f76fdb6364df 0	include/hash_table.h
  ctime: 1715044282:851330500
  mtime: 1715044282:851330500
  dev: 83	ino: 1665799
  uid: 1000	gid: 1000
  size: 707	flags: 0
100644 676c7e721706e252853d2eae9cd8a79d8793e0d2 0	include/index_io.h
  ctime: 1715044282:852332200
  mtime: 1715044282:852332200
  dev: 83	ino: 1665821
  uid: 1000	gid: 1000
  size: 604	flags: 0
100644 28a562e9d8ab2917df07178794d4a6f003b73d5f 0	include/linked_list.h
  ctime: 1715044282:853330000
  mtime: 1715044282:853330000
  dev: 83	ino: 1665824
  uid: 1000	gid: 1000
  size: 651	flags: 0
100644 195ae2200c35b38b10e2bae2813c2ed4d68c7f46 0	include/log.h
  ctime: 1715044282:854352300
  mtime: 1715044282:854352300
  dev: 83	ino: 1665827
  uid: 1000	gid: 1000
  size: 93	flags: 0
100644 6d94a2d89d0699364f438fb595c74daa97f4460c 0	include/object_io.h
  ctime: 1715044282:855357800
  mtime: 1715044282:855357800
  dev: 83	ino: 1665830
  uid: 1000	gid: 1000
  size: 1483	flags: 0
100644 95db7f58650f75d190ee5f2c9f54ccb34e1014e3 0	include/push.h
  ctime: 1715044282:857330700
  mtime: 1715044282:857330700
  dev: 83	ino: 1665834
  uid: 1000	gid: 1000
  size: 527	flags: 0
100644 c5083f3806b00198d0eba4c66551f2cd1fe36962 0	include/ref_io.h
  ctime: 1715044282:857330700
  mtime: 1715044282:857330700
  dev: 83	ino: 1665835
  uid: 1000	gid: 1000
  size: 654	flags: 0
100644 2e7699cc5b1f9debd233cee24b4d014ad94b91b5 0	include/status.h
  ctime: 1715044282:858326100
  mtime: 1715044282:858326100
  dev: 83	ino: 1665841
  uid: 1000	gid: 1000
  size: 88	flags: 0
100644 deabb843000c504714074bc3e4dc8626fdee303f 0	include/transport.h
  ctime: 1715044282:859333500
  mtime: 1715044282:859333500
  dev: 83	ino: 1665853
  uid: 1000	gid: 1000
  size: 8272	flags: 0
100644 87c718a897681171bb729e75170ad3f925a9c121 0	include/util.h
  ctime: 1715045811:983921300
  mtime: 1715045811:983921300
  dev: 83	ino: 1665857
  uid: 1000	gid: 1000
  size: 914	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	out/.gitkeep
  ctime: 1715044223:787455800
  mtime: 1715044223:787455800
  dev: 83	ino: 1666214
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 fa417e90e36aba88b7416873f77f521161f4950c 0	src/add.c
  ctime: 1715046462:776237900
  mtime: 1715046462:776237900
  dev: 83	ino: 1665860
  uid: 1000	gid: 1000
  size: 10714	flags: 0
100644 c855383c5babedd70eebec59e020c9bc436462ff 0	src/checkout.c
  ctime: 1715044282:861338300
  mtime: 1715044282:861338300
  dev: 83	ino: 1665874
  uid: 1000	gid: 1000
  size: 232	flags: 0
100644 694838c1cb786d7d5e2379c60b236dac3dbbaa35 0	src/commit.c
  ctime: 1715044844:219331900
  mtime: 1715044844:219331900
  dev: 83	ino: 1665880
  uid: 1000	gid: 1000
  size: 6002	flags: 0
100644 b549117398f36f979a65c013363b0157910df31d 0	src/config_io.c
  ctime: 1715044282:862331000
  mtime: 1715044282:862331000
  dev: 83	ino: 1665890
  uid: 1000	gid: 1000
  size: 10556	flags: 0
100644 c3fb8e67ac0495c613ac3993f24ec7918e8ef4ae 0	src/fetch.c
  ctime: 1715044282:863345000
  mtime: 1715044282:863345000
  dev: 83	ino: 1665893
  uid: 1000	gid: 1000
  size: 1140	flags: 0
100644 dce7d7d36a3ce4adcb1f59da9dc1a990aba70f42 0	src/hash_table.c
  ctime: 1715044282:864333800
  mtime: 1715044282:864333800
  dev: 83	ino: 1665897
  uid: 1000	gid: 1000
  size: 3962	flags: 0
100644 acede9a565efdc636f98acd2521c3daa28b4b793 0	src/index_io.c
  ctime: 1715046316:980951400
  mtime: 1715046316:980951400
  dev: 83	ino: 1665911
  uid: 1000	gid: 1000
  size: 6530	flags: 0
100644 27e327a8d2dcebbb9d4e31dd0649b480231c6829 0	src/linked_list.c
  ctime: 1715044282:865323700
  mtime: 1715044282:865323700
  dev: 83	ino: 1666212
  uid: 1000	gid: 1000
  size: 3554	flags: 0
100644 3e3c3cd5093ab5791a6786d4790618ec99fa91bc 0	src/log.c
  ctime: 1715044282:866332800
  mtime: 1715044282:866332800
  dev: 83	ino: 1666216
  uid: 1000	gid: 1000
  size: 272	flags: 0
100644 ae4a7ac7c8292cc9f59a72b7afa1bdf4110b7bdd 0	src/mygit.c
  ctime: 1715044282:867337700
  mtime: 1715044282:867337700
  dev: 83	ino: 1666217
  uid: 1000	gid: 1000
  size: 7029	flags: 0
100644 42f0cbec501fdfc3b3481416f582f1eb9d19852d 0	src/object_io.c
  ctime: 1715044282:868372300
  mtime: 1715044282:868372300
  dev: 83	ino: 1666218
  uid: 1000	gid: 1000
  size: 16478	flags: 0
100644 dd3435e5c0e40a967dbef4dd26e8d3b95b7c580f 0	src/push.c
  ctime: 1715044282:869336300
  mtime: 1715044282:869336300
  dev: 83	ino: 1666219
  uid: 1000	gid: 1000
  size: 479	flags: 0
100644 74b8416bc59144fd0084c6d25759e96cefdc8e25 0	src/ref_io.c
  ctime: 1715044282:869336300
  mtime: 1715044282:869336300
  dev: 83	ino: 1666220
  uid: 1000	gid: 1000
  size: 4799	flags: 0
100644 9198d74e2819ad48a4fd7f9770dbfbaaabc05cab 0	src/status.c
  ctime: 1715044888:458847900
  mtime: 1715044888:458847900
  dev: 83	ino: 1666221
  uid: 1000	gid: 1000
  size: 5486	flags: 0
100644 5637785d7573777f1c8360afa212ff8a076dbd08 0	src/transport.c
  ctime: 1715044282:872335500
  mtime: 1715044282:872335500
  dev: 83	ino: 1666222
  uid: 1000	gid: 1000
  size: 33282	flags: 0
100644 f5f803f928f16d6ebfad595086169958fe8feb1c 0	src/util.c
  ctime: 1715045839:144237100
  mtime: 1715045839:144237100
  dev: 83	ino: 1666223
  uid: 1000	gid: 1000
  size: 3689	flags: 0
100644 224984169ad2d5dc9dd80b232bb1fbd65aeecde3 0	temp_idx_file
  ctime: 1715046450:984062800
  mtime: 1715046450:982081600
  dev: 83	ino: 1458536
  uid: 1000	gid: 1000
  size: 3336	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	temp_idx_file.lock
  ctime: 1715046555:79534200
  mtime: 1715046555:79534200
  dev: 83	ino: 1682143
  uid: 1000	gid: 1000
  size: 0	flags: 0
ï¿½
filename: bruhasdfasdv

contents: 
 vvvvvvvvvvvvvvvvvvvv
filename: bruhnahhh

contents: 
 100755 ec17f0ef9a3c55b1cb1be43f838d8a8b06fecf43 0	.gitignore
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 29	flags: 0
100644 2b1eecb1823083550dc3205773d6761fb847d58a 0	.gitlab-ci.yml
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 104	flags: 0
100644 0ce59d5200b68d90c0e83bab6b1e47df64a967a1 0	Makefile
  ctime: 0:0
  mtime: 1715049368:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 786	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	aaaa
  ctime: 0:0
  mtime: 1715048757:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	bin/.gitkeep
  ctime: 0:0
  mtime: 1715044223:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100644 9c08f7c143e58bceece73486a9ad1d135714cdb5 0	bruh3
  ctime: 0:0
  mtime: 1715046566:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 8214	flags: 0
100644 152d8460f36f6e69720b9b6abf60437ae5679dd5 0	bruhnahhh
  ctime: 0:0
  mtime: 1715051356:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 6885	flags: 0
100644 2dd2507d16cc1180249f242d59324bcec7784238 0	bruhnahhh1
  ctime: 0:0
  mtime: 1715051229:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 7452	flags: 0
100644 07e816b7f8edea6b0c47ac2ac65bb5774887ff19 0	bruhnahhh2
  ctime: 0:0
  mtime: 1715051246:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 9314	flags: 0
100644 4bfea11dfac252c5a15a1b2a4489a0c98703b81b 0	bruhnahhh3
  ctime: 0:0
  mtime: 1715047010:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 7426	flags: 0
100644 6f913a11ff73fa38a02933e9675d794f1ae5cf6b 0	expand-all-packfiles
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 813	flags: 0
100644 661e87d55a4c835c68ec92594c4c0a5c36595813 0	include/add.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 183	flags: 0
100644 b950eeae8aea44e7eb85c11dfcdcb0904c8b90bd 0	include/checkout.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 137	flags: 0
100644 979cc48faea9e8407f4858d69b37239c7a509066 0	include/commit.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 90	flags: 0
100644 21dc5a14662beb2212e6721db17d95adae367185 0	include/config_io.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 1298	flags: 0
100644 a5b8e44f9eba70b73bdcd4d34ac35f49546390fe 0	include/constants.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 356	flags: 0
100644 648f7b51fd6e2d13d00ac0a3f4da4cbc7a461317 0	include/fetch.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 126	flags: 0
100644 8fd07fb39a8783db3050b9162327f76fdb6364df 0	include/hash_table.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 707	flags: 0
100644 3472d69ef508e2d49431f967665e00e85f33cbb6 0	include/index_io.h
  ctime: 0:0
  mtime: 1715049911:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 624	flags: 0
100644 28a562e9d8ab2917df07178794d4a6f003b73d5f 0	include/linked_list.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 651	flags: 0
100644 195ae2200c35b38b10e2bae2813c2ed4d68c7f46 0	include/log.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 93	flags: 0
100644 6d94a2d89d0699364f438fb595c74daa97f4460c 0	include/object_io.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 1483	flags: 0
100644 95db7f58650f75d190ee5f2c9f54ccb34e1014e3 0	include/push.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 527	flags: 0
100644 c5083f3806b00198d0eba4c66551f2cd1fe36962 0	include/ref_io.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 654	flags: 0
100644 2e7699cc5b1f9debd233cee24b4d014ad94b91b5 0	include/status.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 88	flags: 0
100644 deabb843000c504714074bc3e4dc8626fdee303f 0	include/transport.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 8272	flags: 0
100644 87c718a897681171bb729e75170ad3f925a9c121 0	include/util.h
  ctime: 0:0
  mtime: 1715045811:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 914	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	newbrodie
  ctime: 0:0
  mtime: 1715051280:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	out/.gitkeep
  ctime: 0:0
  mtime: 1715044223:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100644 238a49c3f82d1e9aaf8109232d71422a823fe617 0	src/add.c
  ctime: 0:0
  mtime: 1715051319:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 10555	flags: 0
100644 c855383c5babedd70eebec59e020c9bc436462ff 0	src/checkout.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 232	flags: 0
100644 694838c1cb786d7d5e2379c60b236dac3dbbaa35 0	src/commit.c
  ctime: 0:0
  mtime: 1715044844:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 6002	flags: 0
100644 b549117398f36f979a65c013363b0157910df31d 0	src/config_io.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 10556	flags: 0
100644 c3fb8e67ac0495c613ac3993f24ec7918e8ef4ae 0	src/fetch.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 1140	flags: 0
100644 dce7d7d36a3ce4adcb1f59da9dc1a990aba70f42 0	src/hash_table.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 3962	flags: 0
100644 88e8ba1fcf33e92bc370e9515eb798d4e07c39a7 0	src/index_io.c
  ctime: 0:0
  mtime: 1715050747:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 6639	flags: 0
100644 27e327a8d2dcebbb9d4e31dd0649b480231c6829 0	src/linked_list.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 3554	flags: 0
100644 3e3c3cd5093ab5791a6786d4790618ec99fa91bc 0	src/log.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 272	flags: 0
100644 ae4a7ac7c8292cc9f59a72b7afa1bdf4110b7bdd 0	src/mygit.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 7029	flags: 0
100644 42f0cbec501fdfc3b3481416f582f1eb9d19852d 0	src/object_io.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 16478	flags: 0
100644 dd3435e5c0e40a967dbef4dd26e8d3b95b7c580f 0	src/push.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 479	flags: 0
100644 74b8416bc59144fd0084c6d25759e96cefdc8e25 0	src/ref_io.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 4799	flags: 0
100644 9198d74e2819ad48a4fd7f9770dbfbaaabc05cab 0	src/status.c
  ctime: 0:0
  mtime: 1715044888:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 5486	flags: 0
100644 5637785d7573777f1c8360afa212ff8a076dbd08 0	src/transport.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 33282	flags: 0
100644 f5f803f928f16d6ebfad595086169958fe8feb1c 0	src/util.c
  ctime: 0:0
  mtime: 1715045839:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 3689	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	temp2
  ctime: 0:0
  mtime: 1715050946:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100644 df3fceece9dae0f3f0daaebc7bf7dcdab37b06b7 0	temp_idx_file
  ctime: 0:0
  mtime: 1715051315:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 4092	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	temp_idx_file.lock
  ctime: 0:0
  mtime: 0:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	tet
  ctime: 0:0
  mtime: 1715050774:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100644 7c4a013e52c76442ab80ee5572399a30373600a2 0	trippin
  ctime: 0:0
  mtime: 1715050874:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 3	flags: 0

filename: bruhnahhh1

contents: 
 100755 ec17f0ef9a3c55b1cb1be43f838d8a8b06fecf43 0	.gitignore
  ctime: 1715044282:842332700
  mtime: 1715044282:842332700
  dev: 83	ino: 1646398
  uid: 1000	gid: 1000
  size: 29	flags: 0
100644 2b1eecb1823083550dc3205773d6761fb847d58a 0	.gitlab-ci.yml
  ctime: 1715044282:843371100
  mtime: 1715044282:843371100
  dev: 83	ino: 1665716
  uid: 1000	gid: 1000
  size: 104	flags: 0
100644 0ce59d5200b68d90c0e83bab6b1e47df64a967a1 0	Makefile
  ctime: 1715049368:326735200
  mtime: 1715049368:326735200
  dev: 83	ino: 1665729
  uid: 1000	gid: 1000
  size: 786	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	aaaa
  ctime: 1715048757:990945600
  mtime: 1715048757:990945600
  dev: 83	ino: 1684924
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	bin/.gitkeep
  ctime: 1715044223:777468300
  mtime: 1715044223:777468300
  dev: 83	ino: 1665774
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 9c08f7c143e58bceece73486a9ad1d135714cdb5 0	bruh3
  ctime: 1715046566:294560100
  mtime: 1715046566:294560100
  dev: 83	ino: 1684586
  uid: 1000	gid: 1000
  size: 8214	flags: 0
100644 152d8460f36f6e69720b9b6abf60437ae5679dd5 0	bruhnahhh
  ctime: 1715048911:77553800
  mtime: 1715048911:77553800
  dev: 83	ino: 1684613
  uid: 1000	gid: 1000
  size: 6885	flags: 0
100644 2dd2507d16cc1180249f242d59324bcec7784238 0	bruhnahhh1
  ctime: 1715050999:338284600
  mtime: 1715050999:338284600
  dev: 83	ino: 76889
  uid: 1000	gid: 1000
  size: 7452	flags: 0
100644 07e816b7f8edea6b0c47ac2ac65bb5774887ff19 0	bruhnahhh2
  ctime: 1715051172:587574000
  mtime: 1715051172:587574000
  dev: 83	ino: 1682401
  uid: 1000	gid: 1000
  size: 9314	flags: 0
100644 4bfea11dfac252c5a15a1b2a4489a0c98703b81b 0	bruhnahhh3
  ctime: 1715047010:318949700
  mtime: 1715047010:318949700
  dev: 83	ino: 208196
  uid: 1000	gid: 1000
  size: 7426	flags: 0
100644 6f913a11ff73fa38a02933e9675d794f1ae5cf6b 0	expand-all-packfiles
  ctime: 1715044282:845337600
  mtime: 1715044282:845337600
  dev: 83	ino: 1665730
  uid: 1000	gid: 1000
  size: 813	flags: 0
100644 661e87d55a4c835c68ec92594c4c0a5c36595813 0	include/add.h
  ctime: 1715044282:846325000
  mtime: 1715044282:846325000
  dev: 83	ino: 1665745
  uid: 1000	gid: 1000
  size: 183	flags: 0
100644 b950eeae8aea44e7eb85c11dfcdcb0904c8b90bd 0	include/checkout.h
  ctime: 1715044282:847404100
  mtime: 1715044282:847404100
  dev: 83	ino: 1665748
  uid: 1000	gid: 1000
  size: 137	flags: 0
100644 979cc48faea9e8407f4858d69b37239c7a509066 0	include/commit.h
  ctime: 1715044282:848323800
  mtime: 1715044282:848323800
  dev: 83	ino: 1665776
  uid: 1000	gid: 1000
  size: 90	flags: 0
100644 21dc5a14662beb2212e6721db17d95adae367185 0	include/config_io.h
  ctime: 1715044282:849330500
  mtime: 1715044282:849330500
  dev: 83	ino: 1665778
  uid: 1000	gid: 1000
  size: 1298	flags: 0
100644 a5b8e44f9eba70b73bdcd4d34ac35f49546390fe 0	include/constants.h
  ctime: 1715044282:850326700
  mtime: 1715044282:850326700
  dev: 83	ino: 1665780
  uid: 1000	gid: 1000
  size: 356	flags: 0
100644 648f7b51fd6e2d13d00ac0a3f4da4cbc7a461317 0	include/fetch.h
  ctime: 1715044282:850326700
  mtime: 1715044282:850326700
  dev: 83	ino: 1665794
  uid: 1000	gid: 1000
  size: 126	flags: 0
100644 8fd07fb39a8783db3050b9162327f76fdb6364df 0	include/hash_table.h
  ctime: 1715044282:851330500
  mtime: 1715044282:851330500
  dev: 83	ino: 1665799
  uid: 1000	gid: 1000
  size: 707	flags: 0
100644 3472d69ef508e2d49431f967665e00e85f33cbb6 0	include/index_io.h
  ctime: 1715049911:590020500
  mtime: 1715049911:590020500
  dev: 83	ino: 1665821
  uid: 1000	gid: 1000
  size: 624	flags: 0
100644 28a562e9d8ab2917df07178794d4a6f003b73d5f 0	include/linked_list.h
  ctime: 1715044282:853330000
  mtime: 1715044282:853330000
  dev: 83	ino: 1665824
  uid: 1000	gid: 1000
  size: 651	flags: 0
100644 195ae2200c35b38b10e2bae2813c2ed4d68c7f46 0	include/log.h
  ctime: 1715044282:854352300
  mtime: 1715044282:854352300
  dev: 83	ino: 1665827
  uid: 1000	gid: 1000
  size: 93	flags: 0
100644 6d94a2d89d0699364f438fb595c74daa97f4460c 0	include/object_io.h
  ctime: 1715044282:855357800
  mtime: 1715044282:855357800
  dev: 83	ino: 1665830
  uid: 1000	gid: 1000
  size: 1483	flags: 0
100644 95db7f58650f75d190ee5f2c9f54ccb34e1014e3 0	include/push.h
  ctime: 1715044282:857330700
  mtime: 1715044282:857330700
  dev: 83	ino: 1665834
  uid: 1000	gid: 1000
  size: 527	flags: 0
100644 c5083f3806b00198d0eba4c66551f2cd1fe36962 0	include/ref_io.h
  ctime: 1715044282:857330700
  mtime: 1715044282:857330700
  dev: 83	ino: 1665835
  uid: 1000	gid: 1000
  size: 654	flags: 0
100644 2e7699cc5b1f9debd233cee24b4d014ad94b91b5 0	include/status.h
  ctime: 1715044282:858326100
  mtime: 1715044282:858326100
  dev: 83	ino: 1665841
  uid: 1000	gid: 1000
  size: 88	flags: 0
100644 deabb843000c504714074bc3e4dc8626fdee303f 0	include/transport.h
  ctime: 1715044282:859333500
  mtime: 1715044282:859333500
  dev: 83	ino: 1665853
  uid: 1000	gid: 1000
  size: 8272	flags: 0
100644 87c718a897681171bb729e75170ad3f925a9c121 0	include/util.h
  ctime: 1715045811:983921300
  mtime: 1715045811:983921300
  dev: 83	ino: 1665857
  uid: 1000	gid: 1000
  size: 914	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	out/.gitkeep
  ctime: 1715044223:787455800
  mtime: 1715044223:787455800
  dev: 83	ino: 1666214
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 238a49c3f82d1e9aaf8109232d71422a823fe617 0	src/add.c
  ctime: 1715050749:760125400
  mtime: 1715050749:760125400
  dev: 83	ino: 1665860
  uid: 1000	gid: 1000
  size: 10555	flags: 0
100644 c855383c5babedd70eebec59e020c9bc436462ff 0	src/checkout.c
  ctime: 1715044282:861338300
  mtime: 1715044282:861338300
  dev: 83	ino: 1665874
  uid: 1000	gid: 1000
  size: 232	flags: 0
100644 694838c1cb786d7d5e2379c60b236dac3dbbaa35 0	src/commit.c
  ctime: 1715044844:219331900
  mtime: 1715044844:219331900
  dev: 83	ino: 1665880
  uid: 1000	gid: 1000
  size: 6002	flags: 0
100644 b549117398f36f979a65c013363b0157910df31d 0	src/config_io.c
  ctime: 1715044282:862331000
  mtime: 1715044282:862331000
  dev: 83	ino: 1665890
  uid: 1000	gid: 1000
  size: 10556	flags: 0
100644 c3fb8e67ac0495c613ac3993f24ec7918e8ef4ae 0	src/fetch.c
  ctime: 1715044282:863345000
  mtime: 1715044282:863345000
  dev: 83	ino: 1665893
  uid: 1000	gid: 1000
  size: 1140	flags: 0
100644 dce7d7d36a3ce4adcb1f59da9dc1a990aba70f42 0	src/hash_table.c
  ctime: 1715044282:864333800
  mtime: 1715044282:864333800
  dev: 83	ino: 1665897
  uid: 1000	gid: 1000
  size: 3962	flags: 0
100644 88e8ba1fcf33e92bc370e9515eb798d4e07c39a7 0	src/index_io.c
  ctime: 1715050747:709306300
  mtime: 1715050747:709306300
  dev: 83	ino: 1665911
  uid: 1000	gid: 1000
  size: 6639	flags: 0
100644 27e327a8d2dcebbb9d4e31dd0649b480231c6829 0	src/linked_list.c
  ctime: 1715044282:865323700
  mtime: 1715044282:865323700
  dev: 83	ino: 1666212
  uid: 1000	gid: 1000
  size: 3554	flags: 0
100644 3e3c3cd5093ab5791a6786d4790618ec99fa91bc 0	src/log.c
  ctime: 1715044282:866332800
  mtime: 1715044282:866332800
  dev: 83	ino: 1666216
  uid: 1000	gid: 1000
  size: 272	flags: 0
100644 ae4a7ac7c8292cc9f59a72b7afa1bdf4110b7bdd 0	src/mygit.c
  ctime: 1715044282:867337700
  mtime: 1715044282:867337700
  dev: 83	ino: 1666217
  uid: 1000	gid: 1000
  size: 7029	flags: 0
100644 42f0cbec501fdfc3b3481416f582f1eb9d19852d 0	src/object_io.c
  ctime: 1715044282:868372300
  mtime: 1715044282:868372300
  dev: 83	ino: 1666218
  uid: 1000	gid: 1000
  size: 16478	flags: 0
100644 dd3435e5c0e40a967dbef4dd26e8d3b95b7c580f 0	src/push.c
  ctime: 1715044282:869336300
  mtime: 1715044282:869336300
  dev: 83	ino: 1666219
  uid: 1000	gid: 1000
  size: 479	flags: 0
100644 74b8416bc59144fd0084c6d25759e96cefdc8e25 0	src/ref_io.c
  ctime: 1715044282:869336300
  mtime: 1715044282:869336300
  dev: 83	ino: 1666220
  uid: 1000	gid: 1000
  size: 4799	flags: 0
100644 9198d74e2819ad48a4fd7f9770dbfbaaabc05cab 0	src/status.c
  ctime: 1715044888:458847900
  mtime: 1715044888:458847900
  dev: 83	ino: 1666221
  uid: 1000	gid: 1000
  size: 5486	flags: 0
100644 5637785d7573777f1c8360afa212ff8a076dbd08 0	src/transport.c
  ctime: 1715044282:872335500
  mtime: 1715044282:872335500
  dev: 83	ino: 1666222
  uid: 1000	gid: 1000
  size: 33282	flags: 0
100644 f5f803f928f16d6ebfad595086169958fe8feb1c 0	src/util.c
  ctime: 1715045839:144237100
  mtime: 1715045839:144237100
  dev: 83	ino: 1666223
  uid: 1000	gid: 1000
  size: 3689	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	temp2
  ctime: 1715050946:926043500
  mtime: 1715050946:926043500
  dev: 83	ino: 1685168
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 df3fceece9dae0f3f0daaebc7bf7dcdab37b06b7 0	temp_idx_file
  ctime: 1715051165:763331800
  mtime: 1715051165:759328600
  dev: 83	ino: 1666229
  uid: 1000	gid: 1000
  size: 4092	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	temp_idx_file.lock
  ctime: 1715051218:513426100
  mtime: 1715051218:513426100
  dev: 83	ino: 1685217
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	tet
  ctime: 1715050778:612038300
  mtime: 1715050774:183857000
  dev: 83	ino: 1685194
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 7c4a013e52c76442ab80ee5572399a30373600a2 0	trippin
  ctime: 1715050874:2790600
  mtime: 1715050874:2790600
  dev: 83	ino: 1500092
  uid: 1000	gid: 1000
  size: 3	flags: 0
Qï¿½
filename: bruhnahhh2

contents: 
 100755 ec17f0ef9a3c55b1cb1be43f838d8a8b06fecf43 0	.gitignore
  ctime: 1715044282:842332700
  mtime: 1715044282:842332700
  dev: 83	ino: 1646398
  uid: 1000	gid: 1000
  size: 29	flags: 0
100644 2b1eecb1823083550dc3205773d6761fb847d58a 0	.gitlab-ci.yml
  ctime: 1715044282:843371100
  mtime: 1715044282:843371100
  dev: 83	ino: 1665716
  uid: 1000	gid: 1000
  size: 104	flags: 0
100644 0ce59d5200b68d90c0e83bab6b1e47df64a967a1 0	Makefile
  ctime: 1715049368:326735200
  mtime: 1715049368:326735200
  dev: 83	ino: 1665729
  uid: 1000	gid: 1000
  size: 786	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	aaaa
  ctime: 1715048757:990945600
  mtime: 1715048757:990945600
  dev: 83	ino: 1684924
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	bin/.gitkeep
  ctime: 1715044223:777468300
  mtime: 1715044223:777468300
  dev: 83	ino: 1665774
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 9c08f7c143e58bceece73486a9ad1d135714cdb5 0	bruh3
  ctime: 1715046566:294560100
  mtime: 1715046566:294560100
  dev: 83	ino: 1684586
  uid: 1000	gid: 1000
  size: 8214	flags: 0
100644 152d8460f36f6e69720b9b6abf60437ae5679dd5 0	bruhnahhh
  ctime: 0:0
  mtime: 1715051379:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 6885	flags: 0
100644 2dd2507d16cc1180249f242d59324bcec7784238 0	bruhnahhh1
  ctime: 0:0
  mtime: 1715051229:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 7452	flags: 0
100644 07e816b7f8edea6b0c47ac2ac65bb5774887ff19 0	bruhnahhh2
  ctime: 0:0
  mtime: 1715051246:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 9314	flags: 0
100644 4bfea11dfac252c5a15a1b2a4489a0c98703b81b 0	bruhnahhh3
  ctime: 1715047010:318949700
  mtime: 1715047010:318949700
  dev: 83	ino: 208196
  uid: 1000	gid: 1000
  size: 7426	flags: 0
100644 6f913a11ff73fa38a02933e9675d794f1ae5cf6b 0	expand-all-packfiles
  ctime: 1715044282:845337600
  mtime: 1715044282:845337600
  dev: 83	ino: 1665730
  uid: 1000	gid: 1000
  size: 813	flags: 0
100644 661e87d55a4c835c68ec92594c4c0a5c36595813 0	include/add.h
  ctime: 1715044282:846325000
  mtime: 1715044282:846325000
  dev: 83	ino: 1665745
  uid: 1000	gid: 1000
  size: 183	flags: 0
100644 b950eeae8aea44e7eb85c11dfcdcb0904c8b90bd 0	include/checkout.h
  ctime: 1715044282:847404100
  mtime: 1715044282:847404100
  dev: 83	ino: 1665748
  uid: 1000	gid: 1000
  size: 137	flags: 0
100644 979cc48faea9e8407f4858d69b37239c7a509066 0	include/commit.h
  ctime: 1715044282:848323800
  mtime: 1715044282:848323800
  dev: 83	ino: 1665776
  uid: 1000	gid: 1000
  size: 90	flags: 0
100644 21dc5a14662beb2212e6721db17d95adae367185 0	include/config_io.h
  ctime: 1715044282:849330500
  mtime: 1715044282:849330500
  dev: 83	ino: 1665778
  uid: 1000	gid: 1000
  size: 1298	flags: 0
100644 a5b8e44f9eba70b73bdcd4d34ac35f49546390fe 0	include/constants.h
  ctime: 1715044282:850326700
  mtime: 1715044282:850326700
  dev: 83	ino: 1665780
  uid: 1000	gid: 1000
  size: 356	flags: 0
100644 648f7b51fd6e2d13d00ac0a3f4da4cbc7a461317 0	include/fetch.h
  ctime: 1715044282:850326700
  mtime: 1715044282:850326700
  dev: 83	ino: 1665794
  uid: 1000	gid: 1000
  size: 126	flags: 0
100644 8fd07fb39a8783db3050b9162327f76fdb6364df 0	include/hash_table.h
  ctime: 1715044282:851330500
  mtime: 1715044282:851330500
  dev: 83	ino: 1665799
  uid: 1000	gid: 1000
  size: 707	flags: 0
100644 3472d69ef508e2d49431f967665e00e85f33cbb6 0	include/index_io.h
  ctime: 1715049911:590020500
  mtime: 1715049911:590020500
  dev: 83	ino: 1665821
  uid: 1000	gid: 1000
  size: 624	flags: 0
100644 28a562e9d8ab2917df07178794d4a6f003b73d5f 0	include/linked_list.h
  ctime: 1715044282:853330000
  mtime: 1715044282:853330000
  dev: 83	ino: 1665824
  uid: 1000	gid: 1000
  size: 651	flags: 0
100644 195ae2200c35b38b10e2bae2813c2ed4d68c7f46 0	include/log.h
  ctime: 1715044282:854352300
  mtime: 1715044282:854352300
  dev: 83	ino: 1665827
  uid: 1000	gid: 1000
  size: 93	flags: 0
100644 6d94a2d89d0699364f438fb595c74daa97f4460c 0	include/object_io.h
  ctime: 1715044282:855357800
  mtime: 1715044282:855357800
  dev: 83	ino: 1665830
  uid: 1000	gid: 1000
  size: 1483	flags: 0
100644 95db7f58650f75d190ee5f2c9f54ccb34e1014e3 0	include/push.h
  ctime: 1715044282:857330700
  mtime: 1715044282:857330700
  dev: 83	ino: 1665834
  uid: 1000	gid: 1000
  size: 527	flags: 0
100644 c5083f3806b00198d0eba4c66551f2cd1fe36962 0	include/ref_io.h
  ctime: 1715044282:857330700
  mtime: 1715044282:857330700
  dev: 83	ino: 1665835
  uid: 1000	gid: 1000
  size: 654	flags: 0
100644 2e7699cc5b1f9debd233cee24b4d014ad94b91b5 0	include/status.h
  ctime: 1715044282:858326100
  mtime: 1715044282:858326100
  dev: 83	ino: 1665841
  uid: 1000	gid: 1000
  size: 88	flags: 0
100644 deabb843000c504714074bc3e4dc8626fdee303f 0	include/transport.h
  ctime: 1715044282:859333500
  mtime: 1715044282:859333500
  dev: 83	ino: 1665853
  uid: 1000	gid: 1000
  size: 8272	flags: 0
100644 87c718a897681171bb729e75170ad3f925a9c121 0	include/util.h
  ctime: 1715045811:983921300
  mtime: 1715045811:983921300
  dev: 83	ino: 1665857
  uid: 1000	gid: 1000
  size: 914	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	newbrodie
  ctime: 1715051280:352536400
  mtime: 1715051280:352536400
  dev: 83	ino: 807739
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	out/.gitkeep
  ctime: 1715044223:787455800
  mtime: 1715044223:787455800
  dev: 83	ino: 1666214
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 238a49c3f82d1e9aaf8109232d71422a823fe617 0	src/add.c
  ctime: 1715051395:48603400
  mtime: 1715051395:48603400
  dev: 83	ino: 1665860
  uid: 1000	gid: 1000
  size: 10555	flags: 0
100644 c855383c5babedd70eebec59e020c9bc436462ff 0	src/checkout.c
  ctime: 1715044282:861338300
  mtime: 1715044282:861338300
  dev: 83	ino: 1665874
  uid: 1000	gid: 1000
  size: 232	flags: 0
100644 694838c1cb786d7d5e2379c60b236dac3dbbaa35 0	src/commit.c
  ctime: 1715044844:219331900
  mtime: 1715044844:219331900
  dev: 83	ino: 1665880
  uid: 1000	gid: 1000
  size: 6002	flags: 0
100644 b549117398f36f979a65c013363b0157910df31d 0	src/config_io.c
  ctime: 1715044282:862331000
  mtime: 1715044282:862331000
  dev: 83	ino: 1665890
  uid: 1000	gid: 1000
  size: 10556	flags: 0
100644 c3fb8e67ac0495c613ac3993f24ec7918e8ef4ae 0	src/fetch.c
  ctime: 1715044282:863345000
  mtime: 1715044282:863345000
  dev: 83	ino: 1665893
  uid: 1000	gid: 1000
  size: 1140	flags: 0
100644 dce7d7d36a3ce4adcb1f59da9dc1a990aba70f42 0	src/hash_table.c
  ctime: 1715044282:864333800
  mtime: 1715044282:864333800
  dev: 83	ino: 1665897
  uid: 1000	gid: 1000
  size: 3962	flags: 0
100644 88e8ba1fcf33e92bc370e9515eb798d4e07c39a7 0	src/index_io.c
  ctime: 1715050747:709306300
  mtime: 1715050747:709306300
  dev: 83	ino: 1665911
  uid: 1000	gid: 1000
  size: 6639	flags: 0
100644 27e327a8d2dcebbb9d4e31dd0649b480231c6829 0	src/linked_list.c
  ctime: 1715044282:865323700
  mtime: 1715044282:865323700
  dev: 83	ino: 1666212
  uid: 1000	gid: 1000
  size: 3554	flags: 0
100644 3e3c3cd5093ab5791a6786d4790618ec99fa91bc 0	src/log.c
  ctime: 1715044282:866332800
  mtime: 1715044282:866332800
  dev: 83	ino: 1666216
  uid: 1000	gid: 1000
  size: 272	flags: 0
100644 ae4a7ac7c8292cc9f59a72b7afa1bdf4110b7bdd 0	src/mygit.c
  ctime: 1715044282:867337700
  mtime: 1715044282:867337700
  dev: 83	ino: 1666217
  uid: 1000	gid: 1000
  size: 7029	flags: 0
100644 42f0cbec501fdfc3b3481416f582f1eb9d19852d 0	src/object_io.c
  ctime: 1715044282:868372300
  mtime: 1715044282:868372300
  dev: 83	ino: 1666218
  uid: 1000	gid: 1000
  size: 16478	flags: 0
100644 dd3435e5c0e40a967dbef4dd26e8d3b95b7c580f 0	src/push.c
  ctime: 1715044282:869336300
  mtime: 1715044282:869336300
  dev: 83	ino: 1666219
  uid: 1000	gid: 1000
  size: 479	flags: 0
100644 74b8416bc59144fd0084c6d25759e96cefdc8e25 0	src/ref_io.c
  ctime: 1715044282:869336300
  mtime: 1715044282:869336300
  dev: 83	ino: 1666220
  uid: 1000	gid: 1000
  size: 4799	flags: 0
100644 9198d74e2819ad48a4fd7f9770dbfbaaabc05cab 0	src/status.c
  ctime: 1715044888:458847900
  mtime: 1715044888:458847900
  dev: 83	ino: 1666221
  uid: 1000	gid: 1000
  size: 5486	flags: 0
100644 5637785d7573777f1c8360afa212ff8a076dbd08 0	src/transport.c
  ctime: 1715044282:872335500
  mtime: 1715044282:872335500
  dev: 83	ino: 1666222
  uid: 1000	gid: 1000
  size: 33282	flags: 0
100644 f5f803f928f16d6ebfad595086169958fe8feb1c 0	src/util.c
  ctime: 1715045839:144237100
  mtime: 1715045839:144237100
  dev: 83	ino: 1666223
  uid: 1000	gid: 1000
  size: 3689	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	temp2
  ctime: 1715050946:926043500
  mtime: 1715050946:926043500
  dev: 83	ino: 1685168
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 df3fceece9dae0f3f0daaebc7bf7dcdab37b06b7 0	temp_idx_file
  ctime: 0:0
  mtime: 1715051408:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 4092	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	temp_idx_file.lock
  ctime: 0:0
  mtime: 0:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	tet
  ctime: 1715050778:612038300
  mtime: 1715050774:183857000
  dev: 83	ino: 1685194
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 7c4a013e52c76442ab80ee5572399a30373600a2 0	trippin
  ctime: 1715050874:2790600
  mtime: 1715050874:2790600
  dev: 83	ino: 1500092
  uid: 1000	gid: 1000
  size: 3	flags: 0

filename: bruhnahhh3

contents: 
 100644 ec17f0ef9a3c55b1cb1be43f838d8a8b06fecf43 0	.gitignore
  ctime: 1715044282:842332700
  mtime: 1715044282:842332700
  dev: 83	ino: 1646398
  uid: 1000	gid: 1000
  size: 29	flags: 0
100644 2b1eecb1823083550dc3205773d6761fb847d58a 0	.gitlab-ci.yml
  ctime: 1715044282:843371100
  mtime: 1715044282:843371100
  dev: 83	ino: 1665716
  uid: 1000	gid: 1000
  size: 104	flags: 0
100644 0ce59d5200b68d90c0e83bab6b1e47df64a967a1 0	Makefile
  ctime: 0:0
  mtime: 1715046576:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 786	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	bin/.gitkeep
  ctime: 1715044223:777468300
  mtime: 1715044223:777468300
  dev: 83	ino: 1665774
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 9c08f7c143e58bceece73486a9ad1d135714cdb5 0	bruh3
  ctime: 1715046566:294560100
  mtime: 1715046566:294560100
  dev: 83	ino: 1684586
  uid: 1000	gid: 1000
  size: 8214	flags: 0
100644 9f1fa68ddf5c5b4db64b93e90541970c490b627b 0	bruhnahhh
  ctime: 1715046930:556537900
  mtime: 1715046930:556537900
  dev: 83	ino: 1684613
  uid: 1000	gid: 1000
  size: 5840	flags: 0
100644 6f913a11ff73fa38a02933e9675d794f1ae5cf6b 0	expand-all-packfiles
  ctime: 1715044282:845337600
  mtime: 1715044282:845337600
  dev: 83	ino: 1665730
  uid: 1000	gid: 1000
  size: 813	flags: 0
100644 661e87d55a4c835c68ec92594c4c0a5c36595813 0	include/add.h
  ctime: 1715044282:846325000
  mtime: 1715044282:846325000
  dev: 83	ino: 1665745
  uid: 1000	gid: 1000
  size: 183	flags: 0
100644 b950eeae8aea44e7eb85c11dfcdcb0904c8b90bd 0	include/checkout.h
  ctime: 1715044282:847404100
  mtime: 1715044282:847404100
  dev: 83	ino: 1665748
  uid: 1000	gid: 1000
  size: 137	flags: 0
100644 979cc48faea9e8407f4858d69b37239c7a509066 0	include/commit.h
  ctime: 1715044282:848323800
  mtime: 1715044282:848323800
  dev: 83	ino: 1665776
  uid: 1000	gid: 1000
  size: 90	flags: 0
100644 21dc5a14662beb2212e6721db17d95adae367185 0	include/config_io.h
  ctime: 1715044282:849330500
  mtime: 1715044282:849330500
  dev: 83	ino: 1665778
  uid: 1000	gid: 1000
  size: 1298	flags: 0
100644 a5b8e44f9eba70b73bdcd4d34ac35f49546390fe 0	include/constants.h
  ctime: 1715044282:850326700
  mtime: 1715044282:850326700
  dev: 83	ino: 1665780
  uid: 1000	gid: 1000
  size: 356	flags: 0
100644 648f7b51fd6e2d13d00ac0a3f4da4cbc7a461317 0	include/fetch.h
  ctime: 1715044282:850326700
  mtime: 1715044282:850326700
  dev: 83	ino: 1665794
  uid: 1000	gid: 1000
  size: 126	flags: 0
100644 8fd07fb39a8783db3050b9162327f76fdb6364df 0	include/hash_table.h
  ctime: 1715044282:851330500
  mtime: 1715044282:851330500
  dev: 83	ino: 1665799
  uid: 1000	gid: 1000
  size: 707	flags: 0
100644 676c7e721706e252853d2eae9cd8a79d8793e0d2 0	include/index_io.h
  ctime: 1715044282:852332200
  mtime: 1715044282:852332200
  dev: 83	ino: 1665821
  uid: 1000	gid: 1000
  size: 604	flags: 0
100644 28a562e9d8ab2917df07178794d4a6f003b73d5f 0	include/linked_list.h
  ctime: 1715044282:853330000
  mtime: 1715044282:853330000
  dev: 83	ino: 1665824
  uid: 1000	gid: 1000
  size: 651	flags: 0
100644 195ae2200c35b38b10e2bae2813c2ed4d68c7f46 0	include/log.h
  ctime: 1715044282:854352300
  mtime: 1715044282:854352300
  dev: 83	ino: 1665827
  uid: 1000	gid: 1000
  size: 93	flags: 0
100644 6d94a2d89d0699364f438fb595c74daa97f4460c 0	include/object_io.h
  ctime: 1715044282:855357800
  mtime: 1715044282:855357800
  dev: 83	ino: 1665830
  uid: 1000	gid: 1000
  size: 1483	flags: 0
100644 95db7f58650f75d190ee5f2c9f54ccb34e1014e3 0	include/push.h
  ctime: 1715044282:857330700
  mtime: 1715044282:857330700
  dev: 83	ino: 1665834
  uid: 1000	gid: 1000
  size: 527	flags: 0
100644 c5083f3806b00198d0eba4c66551f2cd1fe36962 0	include/ref_io.h
  ctime: 1715044282:857330700
  mtime: 1715044282:857330700
  dev: 83	ino: 1665835
  uid: 1000	gid: 1000
  size: 654	flags: 0
100644 2e7699cc5b1f9debd233cee24b4d014ad94b91b5 0	include/status.h
  ctime: 1715044282:858326100
  mtime: 1715044282:858326100
  dev: 83	ino: 1665841
  uid: 1000	gid: 1000
  size: 88	flags: 0
100644 deabb843000c504714074bc3e4dc8626fdee303f 0	include/transport.h
  ctime: 1715044282:859333500
  mtime: 1715044282:859333500
  dev: 83	ino: 1665853
  uid: 1000	gid: 1000
  size: 8272	flags: 0
100644 3c2a552249d1455a5417ae0e534fd77c7aa11eee 0	include/util.h
  ctime: 0:0
  mtime: 1715045811:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 863	flags: 0
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	out/.gitkeep
  ctime: 1715044223:787455800
  mtime: 1715044223:787455800
  dev: 83	ino: 1666214
  uid: 1000	gid: 1000
  size: 0	flags: 0
100644 7f4de6ae348c9b2f5895ffe9e8e82dc305ad42de 0	src/add.c
  ctime: 0:0
  mtime: 1715046966:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 10345	flags: 0
100644 c855383c5babedd70eebec59e020c9bc436462ff 0	src/checkout.c
  ctime: 1715044282:861338300
  mtime: 1715044282:861338300
  dev: 83	ino: 1665874
  uid: 1000	gid: 1000
  size: 232	flags: 0
100644 a48a35580241b4814456f4e79c81a92d6eaf9d93 0	src/commit.c
  ctime: 0:0
  mtime: 1715044844:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 382	flags: 0
100644 b549117398f36f979a65c013363b0157910df31d 0	src/config_io.c
  ctime: 1715044282:862331000
  mtime: 1715044282:862331000
  dev: 83	ino: 1665890
  uid: 1000	gid: 1000
  size: 10556	flags: 0
100644 c3fb8e67ac0495c613ac3993f24ec7918e8ef4ae 0	src/fetch.c
  ctime: 1715044282:863345000
  mtime: 1715044282:863345000
  dev: 83	ino: 1665893
  uid: 1000	gid: 1000
  size: 1140	flags: 0
100644 dce7d7d36a3ce4adcb1f59da9dc1a990aba70f42 0	src/hash_table.c
  ctime: 1715044282:864333800
  mtime: 1715044282:864333800
  dev: 83	ino: 1665897
  uid: 1000	gid: 1000
  size: 3962	flags: 0
100644 8754accc4f67be37d0e9dde4356a99a3cdf9e2af 0	src/index_io.c
  ctime: 0:0
  mtime: 1715046801:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 3641	flags: 0
100644 27e327a8d2dcebbb9d4e31dd0649b480231c6829 0	src/linked_list.c
  ctime: 1715044282:865323700
  mtime: 1715044282:865323700
  dev: 83	ino: 1666212
  uid: 1000	gid: 1000
  size: 3554	flags: 0
100644 3e3c3cd5093ab5791a6786d4790618ec99fa91bc 0	src/log.c
  ctime: 1715044282:866332800
  mtime: 1715044282:866332800
  dev: 83	ino: 1666216
  uid: 1000	gid: 1000
  size: 272	flags: 0
100644 ae4a7ac7c8292cc9f59a72b7afa1bdf4110b7bdd 0	src/mygit.c
  ctime: 1715044282:867337700
  mtime: 1715044282:867337700
  dev: 83	ino: 1666217
  uid: 1000	gid: 1000
  size: 7029	flags: 0
100644 42f0cbec501fdfc3b3481416f582f1eb9d19852d 0	src/object_io.c
  ctime: 1715044282:868372300
  mtime: 1715044282:868372300
  dev: 83	ino: 1666218
  uid: 1000	gid: 1000
  size: 16478	flags: 0
100644 dd3435e5c0e40a967dbef4dd26e8d3b95b7c580f 0	src/push.c
  ctime: 1715044282:869336300
  mtime: 1715044282:869336300
  dev: 83	ino: 1666219
  uid: 1000	gid: 1000
  size: 479	flags: 0
100644 74b8416bc59144fd0084c6d25759e96cefdc8e25 0	src/ref_io.c
  ctime: 1715044282:869336300
  mtime: 1715044282:869336300
  dev: 83	ino: 1666220
  uid: 1000	gid: 1000
  size: 4799	flags: 0
100644 e5b20fa14289e6853711a3d52d4b8a63cd8bb2ee 0	src/status.c
  ctime: 0:0
  mtime: 1715044888:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 268	flags: 0
100644 5637785d7573777f1c8360afa212ff8a076dbd08 0	src/transport.c
  ctime: 1715044282:872335500
  mtime: 1715044282:872335500
  dev: 83	ino: 1666222
  uid: 1000	gid: 1000
  size: 33282	flags: 0
100644 f5f803f928f16d6ebfad595086169958fe8feb1c 0	src/util.c
  ctime: 1715045839:144237100
  mtime: 1715045839:144237100
  dev: 83	ino: 1666223
  uid: 1000	gid: 1000
  size: 3689	flags: 0

filename: debuggy

contents: 
 100755 ec17f0ef9a3c55b1cb1be43f838d8a8b06fecf43 0	.gitignore
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 29	flags: 0
100755 2b1eecb1823083550dc3205773d6761fb847d58a 0	.gitlab-ci.yml
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 104	flags: 0
100755 0ce59d5200b68d90c0e83bab6b1e47df64a967a1 0	Makefile
  ctime: 0:0
  mtime: 1715049368:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 786	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	aaaa
  ctime: 0:0
  mtime: 1715048757:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	bin/.gitkeep
  ctime: 0:0
  mtime: 1715044223:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100755 9c08f7c143e58bceece73486a9ad1d135714cdb5 0	bruh3
  ctime: 0:0
  mtime: 1715046566:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 8214	flags: 0
100755 c6d40d221621fbb49a6c6a2bd57415864aa0cfe3 0	bruhasdfasdv
  ctime: 0:0
  mtime: 1715055198:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 20	flags: 0
100755 a831ad706360fa0db6782617b9fd4e5cb4eb7d92 0	bruhnahhh
  ctime: 0:0
  mtime: 1715051379:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 7598	flags: 0
100755 540b0654c4584fbb1a583e449928b44c7c4ab9a6 0	bruhnahhh1
  ctime: 0:0
  mtime: 1715051229:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 9314	flags: 0
100755 c66e59454e7114d8748d995d15d829c7f17768ad 0	bruhnahhh2
  ctime: 0:0
  mtime: 1715051483:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 9300	flags: 0
100755 4bfea11dfac252c5a15a1b2a4489a0c98703b81b 0	bruhnahhh3
  ctime: 0:0
  mtime: 1715047010:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 7426	flags: 0
100755 ecfdda06e2bd604a23ae9ca28851a2ebb9404fbb 0	debuggy
  ctime: 0:0
  mtime: 1715055917:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 8039	flags: 0
100755 23822db8d72f44223265ed1dd04343378d18f369 0	debuggy2
  ctime: 0:0
  mtime: 1715055934:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 8112	flags: 0
100755 6f913a11ff73fa38a02933e9675d794f1ae5cf6b 0	expand-all-packfiles
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 813	flags: 0
100755 661e87d55a4c835c68ec92594c4c0a5c36595813 0	include/add.h
  ctime: 0:0
  mtime: 1715054570:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 183	flags: 0
100755 b950eeae8aea44e7eb85c11dfcdcb0904c8b90bd 0	include/checkout.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 137	flags: 0
100755 979cc48faea9e8407f4858d69b37239c7a509066 0	include/commit.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 90	flags: 0
100755 21dc5a14662beb2212e6721db17d95adae367185 0	include/config_io.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 1298	flags: 0
100755 a5b8e44f9eba70b73bdcd4d34ac35f49546390fe 0	include/constants.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 356	flags: 0
100755 648f7b51fd6e2d13d00ac0a3f4da4cbc7a461317 0	include/fetch.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 126	flags: 0
100755 8fd07fb39a8783db3050b9162327f76fdb6364df 0	include/hash_table.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 707	flags: 0
100755 3472d69ef508e2d49431f967665e00e85f33cbb6 0	include/index_io.h
  ctime: 0:0
  mtime: 1715049911:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 624	flags: 0
100755 28a562e9d8ab2917df07178794d4a6f003b73d5f 0	include/linked_list.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 651	flags: 0
100755 195ae2200c35b38b10e2bae2813c2ed4d68c7f46 0	include/log.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 93	flags: 0
100755 6d94a2d89d0699364f438fb595c74daa97f4460c 0	include/object_io.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 1483	flags: 0
100755 95db7f58650f75d190ee5f2c9f54ccb34e1014e3 0	include/push.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 527	flags: 0
100755 c5083f3806b00198d0eba4c66551f2cd1fe36962 0	include/ref_io.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 654	flags: 0
100755 2e7699cc5b1f9debd233cee24b4d014ad94b91b5 0	include/status.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 88	flags: 0
100755 deabb843000c504714074bc3e4dc8626fdee303f 0	include/transport.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 8272	flags: 0
100755 87c718a897681171bb729e75170ad3f925a9c121 0	include/util.h
  ctime: 0:0
  mtime: 1715045811:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 914	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	newbrodie
  ctime: 0:0
  mtime: 1715051280:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	out/.gitkeep
  ctime: 0:0
  mtime: 1715044223:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	revealfile
  ctime: 0:0
  mtime: 1715053387:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100755 5bb6fa16e4277e5921e5edb69157e942ae4e3396 0	src/add.c
  ctime: 0:0
  mtime: 1715055817:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 9776	flags: 0
100755 c855383c5babedd70eebec59e020c9bc436462ff 0	src/checkout.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 232	flags: 0
100755 85643cbf09e0bea81c6cc837f249c18adf85cd63 0	src/commit.c
  ctime: 0:0
  mtime: 1715052552:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 6040	flags: 0
100755 b549117398f36f979a65c013363b0157910df31d 0	src/config_io.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 10556	flags: 0
100755 c3fb8e67ac0495c613ac3993f24ec7918e8ef4ae 0	src/fetch.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 1140	flags: 0
100755 dce7d7d36a3ce4adcb1f59da9dc1a990aba70f42 0	src/hash_table.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 3962	flags: 0
100755 c3d6b98b186971edff511b5118ff13d55494f25b 0	src/index_io.c
  ctime: 0:0
  mtime: 1715055894:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 6639	flags: 0
100755 27e327a8d2dcebbb9d4e31dd0649b480231c6829 0	src/linked_list.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 3554	flags: 0
100755 3e3c3cd5093ab5791a6786d4790618ec99fa91bc 0	src/log.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 272	flags: 0
100755 ae4a7ac7c8292cc9f59a72b7afa1bdf4110b7bdd 0	src/mygit.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 7029	flags: 0
100755 42f0cbec501fdfc3b3481416f582f1eb9d19852d 0	src/object_io.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 16478	flags: 0
100755 dd3435e5c0e40a967dbef4dd26e8d3b95b7c580f 0	src/push.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 479	flags: 0
100755 74b8416bc59144fd0084c6d25759e96cefdc8e25 0	src/ref_io.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 4799	flags: 0
100755 9198d74e2819ad48a4fd7f9770dbfbaaabc05cab 0	src/status.c
  ctime: 0:0
  mtime: 1715044888:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 5486	flags: 0
100755 5637785d7573777f1c8360afa212ff8a076dbd08 0	src/transport.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 33282	flags: 0
100755 f5f803f928f16d6ebfad595086169958fe8feb1c 0	src/util.c
  ctime: 0:0
  mtime: 1715045839:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 3689	flags: 0
100755 01f02e32ce8a128dd7b1d16a45f2eff66ec23c2d 0	temp2
  ctime: 0:0
  mtime: 1715055052:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 3	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	temp3
  ctime: 0:0
  mtime: 1715055846:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100755 f162bc2140b667ac441e67597cdb149bde6722de 0	temp_idx_file
  ctime: 0:0
  mtime: 1715055901:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 4228	flags: 0
100755 8fc4b731e0e30d8b1e821f3f8196e5eb4f59a878 0	temp_idx_file2
  ctime: 0:0
  mtime: 1715051373:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 4012	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	tet
  ctime: 0:0
  mtime: 1715050774:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100755 7c4a013e52c76442ab80ee5572399a30373600a2 0	trippin
  ctime: 0:0
  mtime: 1715050874:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 3	flags: 0
100755 8aeed6ff2e38c6de09d06f5eea289bbb6fdd8768 0	try4asdfas
  ctime: 0:0
  mtime: 1715056240:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 28	flags: 0

filename: debuggy2

contents: 
 100755 ec17f0ef9a3c55b1cb1be43f838d8a8b06fecf43 0	.gitignore
  ctime: 1715044282:842332700
  mtime: 1715044282:842332700
  dev: 83	ino: 1646398
  uid: 1000	gid: 1000
  size: 29	flags: 0
100755 2b1eecb1823083550dc3205773d6761fb847d58a 0	.gitlab-ci.yml
  ctime: 1715044282:843371100
  mtime: 1715044282:843371100
  dev: 83	ino: 1665716
  uid: 1000	gid: 1000
  size: 104	flags: 0
100755 0ce59d5200b68d90c0e83bab6b1e47df64a967a1 0	Makefile
  ctime: 1715049368:326735200
  mtime: 1715049368:326735200
  dev: 83	ino: 1665729
  uid: 1000	gid: 1000
  size: 786	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	aaaa
  ctime: 1715048757:990945600
  mtime: 1715048757:990945600
  dev: 83	ino: 1684924
  uid: 1000	gid: 1000
  size: 0	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	bin/.gitkeep
  ctime: 1715044223:777468300
  mtime: 1715044223:777468300
  dev: 83	ino: 1665774
  uid: 1000	gid: 1000
  size: 0	flags: 0
100755 9c08f7c143e58bceece73486a9ad1d135714cdb5 0	bruh3
  ctime: 1715046566:294560100
  mtime: 1715046566:294560100
  dev: 83	ino: 1684586
  uid: 1000	gid: 1000
  size: 8214	flags: 0
100755 c6d40d221621fbb49a6c6a2bd57415864aa0cfe3 0	bruhasdfasdv
  ctime: 1715055198:381510700
  mtime: 1715055198:381510700
  dev: 83	ino: 47027
  uid: 1000	gid: 1000
  size: 20	flags: 0
100755 a831ad706360fa0db6782617b9fd4e5cb4eb7d92 0	bruhnahhh
  ctime: 1715051379:929194100
  mtime: 1715051379:929194100
  dev: 83	ino: 1684613
  uid: 1000	gid: 1000
  size: 7598	flags: 0
100755 540b0654c4584fbb1a583e449928b44c7c4ab9a6 0	bruhnahhh1
  ctime: 1715051229:856943700
  mtime: 1715051229:856943700
  dev: 83	ino: 76889
  uid: 1000	gid: 1000
  size: 9314	flags: 0
100755 c66e59454e7114d8748d995d15d829c7f17768ad 0	bruhnahhh2
  ctime: 1715051483:592234700
  mtime: 1715051483:592234700
  dev: 83	ino: 1682401
  uid: 1000	gid: 1000
  size: 9300	flags: 0
100755 4bfea11dfac252c5a15a1b2a4489a0c98703b81b 0	bruhnahhh3
  ctime: 1715047010:318949700
  mtime: 1715047010:318949700
  dev: 83	ino: 208196
  uid: 1000	gid: 1000
  size: 7426	flags: 0
100755 1b8153328935a7c1061055518c152397b4cfb20b 0	debuggy
  ctime: 1715056273:742586800
  mtime: 1715056273:742586800
  dev: 83	ino: 1685547
  uid: 1000	gid: 1000
  size: 8487	flags: 0
100755 33f42495b1e5cb93ba6b8ab65272d3b46acc521d 0	debuggy2
  ctime: 1715056326:103374900
  mtime: 1715056326:103374900
  dev: 83	ino: 1685495
  uid: 1000	gid: 1000
  size: 10596	flags: 0
100755 6f913a11ff73fa38a02933e9675d794f1ae5cf6b 0	expand-all-packfiles
  ctime: 1715044282:845337600
  mtime: 1715044282:845337600
  dev: 83	ino: 1665730
  uid: 1000	gid: 1000
  size: 813	flags: 0
100755 661e87d55a4c835c68ec92594c4c0a5c36595813 0	include/add.h
  ctime: 1715054570:433137400
  mtime: 1715054570:433137400
  dev: 83	ino: 1665745
  uid: 1000	gid: 1000
  size: 183	flags: 0
100755 b950eeae8aea44e7eb85c11dfcdcb0904c8b90bd 0	include/checkout.h
  ctime: 1715044282:847404100
  mtime: 1715044282:847404100
  dev: 83	ino: 1665748
  uid: 1000	gid: 1000
  size: 137	flags: 0
100755 979cc48faea9e8407f4858d69b37239c7a509066 0	include/commit.h
  ctime: 1715044282:848323800
  mtime: 1715044282:848323800
  dev: 83	ino: 1665776
  uid: 1000	gid: 1000
  size: 90	flags: 0
100755 21dc5a14662beb2212e6721db17d95adae367185 0	include/config_io.h
  ctime: 1715044282:849330500
  mtime: 1715044282:849330500
  dev: 83	ino: 1665778
  uid: 1000	gid: 1000
  size: 1298	flags: 0
100755 a5b8e44f9eba70b73bdcd4d34ac35f49546390fe 0	include/constants.h
  ctime: 1715044282:850326700
  mtime: 1715044282:850326700
  dev: 83	ino: 1665780
  uid: 1000	gid: 1000
  size: 356	flags: 0
100755 648f7b51fd6e2d13d00ac0a3f4da4cbc7a461317 0	include/fetch.h
  ctime: 1715044282:850326700
  mtime: 1715044282:850326700
  dev: 83	ino: 1665794
  uid: 1000	gid: 1000
  size: 126	flags: 0
100755 8fd07fb39a8783db3050b9162327f76fdb6364df 0	include/hash_table.h
  ctime: 1715044282:851330500
  mtime: 1715044282:851330500
  dev: 83	ino: 1665799
  uid: 1000	gid: 1000
  size: 707	flags: 0
100755 3472d69ef508e2d49431f967665e00e85f33cbb6 0	include/index_io.h
  ctime: 1715049911:590020500
  mtime: 1715049911:590020500
  dev: 83	ino: 1665821
  uid: 1000	gid: 1000
  size: 624	flags: 0
100755 28a562e9d8ab2917df07178794d4a6f003b73d5f 0	include/linked_list.h
  ctime: 1715044282:853330000
  mtime: 1715044282:853330000
  dev: 83	ino: 1665824
  uid: 1000	gid: 1000
  size: 651	flags: 0
100755 195ae2200c35b38b10e2bae2813c2ed4d68c7f46 0	include/log.h
  ctime: 1715044282:854352300
  mtime: 1715044282:854352300
  dev: 83	ino: 1665827
  uid: 1000	gid: 1000
  size: 93	flags: 0
100755 6d94a2d89d0699364f438fb595c74daa97f4460c 0	include/object_io.h
  ctime: 1715044282:855357800
  mtime: 1715044282:855357800
  dev: 83	ino: 1665830
  uid: 1000	gid: 1000
  size: 1483	flags: 0
100755 95db7f58650f75d190ee5f2c9f54ccb34e1014e3 0	include/push.h
  ctime: 1715044282:857330700
  mtime: 1715044282:857330700
  dev: 83	ino: 1665834
  uid: 1000	gid: 1000
  size: 527	flags: 0
100755 c5083f3806b00198d0eba4c66551f2cd1fe36962 0	include/ref_io.h
  ctime: 1715044282:857330700
  mtime: 1715044282:857330700
  dev: 83	ino: 1665835
  uid: 1000	gid: 1000
  size: 654	flags: 0
100755 2e7699cc5b1f9debd233cee24b4d014ad94b91b5 0	include/status.h
  ctime: 1715044282:858326100
  mtime: 1715044282:858326100
  dev: 83	ino: 1665841
  uid: 1000	gid: 1000
  size: 88	flags: 0
100755 deabb843000c504714074bc3e4dc8626fdee303f 0	include/transport.h
  ctime: 1715044282:859333500
  mtime: 1715044282:859333500
  dev: 83	ino: 1665853
  uid: 1000	gid: 1000
  size: 8272	flags: 0
100755 87c718a897681171bb729e75170ad3f925a9c121 0	include/util.h
  ctime: 1715045811:983921300
  mtime: 1715045811:983921300
  dev: 83	ino: 1665857
  uid: 1000	gid: 1000
  size: 914	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	newbrodie
  ctime: 1715051280:352536400
  mtime: 1715051280:352536400
  dev: 83	ino: 807739
  uid: 1000	gid: 1000
  size: 0	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	out/.gitkeep
  ctime: 1715044223:787455800
  mtime: 1715044223:787455800
  dev: 83	ino: 1666214
  uid: 1000	gid: 1000
  size: 0	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	revealfile
  ctime: 1715053387:807567400
  mtime: 1715053387:807567400
  dev: 83	ino: 368315
  uid: 1000	gid: 1000
  size: 0	flags: 0
100755 5bb6fa16e4277e5921e5edb69157e942ae4e3396 0	src/add.c
  ctime: 1715055817:547135000
  mtime: 1715055817:547135000
  dev: 83	ino: 1665860
  uid: 1000	gid: 1000
  size: 9776	flags: 0
100755 c855383c5babedd70eebec59e020c9bc436462ff 0	src/checkout.c
  ctime: 1715044282:861338300
  mtime: 1715044282:861338300
  dev: 83	ino: 1665874
  uid: 1000	gid: 1000
  size: 232	flags: 0
100755 85643cbf09e0bea81c6cc837f249c18adf85cd63 0	src/commit.c
  ctime: 1715052552:849990000
  mtime: 1715052552:849990000
  dev: 83	ino: 1665880
  uid: 1000	gid: 1000
  size: 6040	flags: 0
100755 b549117398f36f979a65c013363b0157910df31d 0	src/config_io.c
  ctime: 1715044282:862331000
  mtime: 1715044282:862331000
  dev: 83	ino: 1665890
  uid: 1000	gid: 1000
  size: 10556	flags: 0
100755 c3fb8e67ac0495c613ac3993f24ec7918e8ef4ae 0	src/fetch.c
  ctime: 1715044282:863345000
  mtime: 1715044282:863345000
  dev: 83	ino: 1665893
  uid: 1000	gid: 1000
  size: 1140	flags: 0
100755 dce7d7d36a3ce4adcb1f59da9dc1a990aba70f42 0	src/hash_table.c
  ctime: 1715044282:864333800
  mtime: 1715044282:864333800
  dev: 83	ino: 1665897
  uid: 1000	gid: 1000
  size: 3962	flags: 0
100755 c3d6b98b186971edff511b5118ff13d55494f25b 0	src/index_io.c
  ctime: 1715055894:591369100
  mtime: 1715055894:591369100
  dev: 83	ino: 1665911
  uid: 1000	gid: 1000
  size: 6639	flags: 0
100755 27e327a8d2dcebbb9d4e31dd0649b480231c6829 0	src/linked_list.c
  ctime: 1715044282:865323700
  mtime: 1715044282:865323700
  dev: 83	ino: 1666212
  uid: 1000	gid: 1000
  size: 3554	flags: 0
100755 3e3c3cd5093ab5791a6786d4790618ec99fa91bc 0	src/log.c
  ctime: 1715044282:866332800
  mtime: 1715044282:866332800
  dev: 83	ino: 1666216
  uid: 1000	gid: 1000
  size: 272	flags: 0
100755 ae4a7ac7c8292cc9f59a72b7afa1bdf4110b7bdd 0	src/mygit.c
  ctime: 1715044282:867337700
  mtime: 1715044282:867337700
  dev: 83	ino: 1666217
  uid: 1000	gid: 1000
  size: 7029	flags: 0
100755 42f0cbec501fdfc3b3481416f582f1eb9d19852d 0	src/object_io.c
  ctime: 1715044282:868372300
  mtime: 1715044282:868372300
  dev: 83	ino: 1666218
  uid: 1000	gid: 1000
  size: 16478	flags: 0
100755 dd3435e5c0e40a967dbef4dd26e8d3b95b7c580f 0	src/push.c
  ctime: 1715044282:869336300
  mtime: 1715044282:869336300
  dev: 83	ino: 1666219
  uid: 1000	gid: 1000
  size: 479	flags: 0
100755 74b8416bc59144fd0084c6d25759e96cefdc8e25 0	src/ref_io.c
  ctime: 1715044282:869336300
  mtime: 1715044282:869336300
  dev: 83	ino: 1666220
  uid: 1000	gid: 1000
  size: 4799	flags: 0
100755 9198d74e2819ad48a4fd7f9770dbfbaaabc05cab 0	src/status.c
  ctime: 1715044888:458847900
  mtime: 1715044888:458847900
  dev: 83	ino: 1666221
  uid: 1000	gid: 1000
  size: 5486	flags: 0
100755 5637785d7573777f1c8360afa212ff8a076dbd08 0	src/transport.c
  ctime: 1715044282:872335500
  mtime: 1715044282:872335500
  dev: 83	ino: 1666222
  uid: 1000	gid: 1000
  size: 33282	flags: 0
100755 f5f803f928f16d6ebfad595086169958fe8feb1c 0	src/util.c
  ctime: 1715045839:144237100
  mtime: 1715045839:144237100
  dev: 83	ino: 1666223
  uid: 1000	gid: 1000
  size: 3689	flags: 0
100755 01f02e32ce8a128dd7b1d16a45f2eff66ec23c2d 0	temp2
  ctime: 1715055052:954655200
  mtime: 1715055052:954655200
  dev: 83	ino: 1685168
  uid: 1000	gid: 1000
  size: 3	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	temp3
  ctime: 1715055846:953735700
  mtime: 1715055846:953735700
  dev: 83	ino: 260134
  uid: 1000	gid: 1000
  size: 0	flags: 0
100755 41196caa77708da3d2fa4049a39e046566a1f48a 0	temp_idx_file
  ctime: 1715056259:179100800
  mtime: 1715056259:179100800
  dev: 83	ino: 1685399
  uid: 1000	gid: 1000
  size: 4460	flags: 0
100755 8fc4b731e0e30d8b1e821f3f8196e5eb4f59a878 0	temp_idx_file2
  ctime: 1715051373:74845200
  mtime: 1715051373:74845200
  dev: 83	ino: 1684823
  uid: 1000	gid: 1000
  size: 4012	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	tet
  ctime: 1715050778:612038300
  mtime: 1715050774:183857000
  dev: 83	ino: 1685194
  uid: 1000	gid: 1000
  size: 0	flags: 0
100755 7c4a013e52c76442ab80ee5572399a30373600a2 0	trippin
  ctime: 1715050874:2790600
  mtime: 1715050874:2790600
  dev: 83	ino: 1500092
  uid: 1000	gid: 1000
  size: 3	flags: 0
100755 8aeed6ff2e38c6de09d06f5eea289bbb6fdd8768 0	try4asdfas
  ctime: 1715056240:319025200
  mtime: 1715056240:319025200
  dev: 83	ino: 956189
  uid: 1000	gid: 1000
  size: 28	flags: 0

filename: expand-all-packfiles

contents: 
 #!/usr/bin/env bash

set -euo pipefail

git_dir="$(git rev-parse --show-toplevel)/.git"

tmp_dir=$(mktemp -d)

shopt -s nullglob
for f in "$git_dir/objects/pack/"pack-*.pack
do
    echo "Unpacking $f"
    mv "$f" "$tmp_dir/packfile"
    git unpack-objects < "$tmp_dir/packfile"
done
shopt -u nullglob

echo "Cleaning up packfile indexes"
# Cleanup all index files, we just removed all the packfiles
rm -f "$git_dir/objects/pack/pack-*.idx"

# Cleanup references to the old packfiles
echo "Running git fsck"
git fsck


exit 0 # not sure if ref expansion is needed yet

echo "Expanding refs"
while read -r line
do
    sha="$(echo $line | cut -c1-40)"
    path="$(echo $line | cut -c42-)"
    echo "Writing $sha to $path"
    echo "$sha" > "$git_dir/$path"
done < <(git show-ref)

filename: foo

contents: 
 `ï¿½ï¿½>
filename: hello.txt

contents: 
 ï¿½ï¿½h
filename: hello2.txt

contents: 
 hello

filename: include

contents: 
 100755 add.h
filename: add.h

contents: 
 #ifndef ADD_H
#define ADD_H

#include <stddef.h>

// stage changes to files to index, add object to store
void add_files(const char **file_paths, size_t file_count);

#endif

filename: checkout.h

contents: 
 #ifndef CHECKOUT_H
#define CHECKOUT_H

#include <stdbool.h>

void checkout(const char *checkout_name, bool make_branch);

#endif
 
filename: commit.h

contents: 
 #ifndef COMMIT_H
#define COMMIT_H

void commit(const char *commit_message);

#endif

filename: config_io.h

contents: 
 #ifndef CONFIG_IO_H
#define CONFIG_IO_H

#include <stdbool.h>
#include <stddef.h>

extern const char MERGE_KEY[];
extern const char REMOTE_KEY[];
extern const char URL_KEY[];

typedef struct {
    char *key;
    char *value;
} config_property_t;

typedef struct {
    char *name;
    size_t property_count;
    config_property_t *properties;
} config_section_t;

typedef struct {
    size_t section_count;
    config_section_t sections[];
} config_t;

config_t *read_config(void);
config_t *read_global_config(void);
void write_config(const config_t *);
void free_config(config_t *);

config_section_t *get_section(const config_t *, const char *name);
char *get_branch_section_name(const char *branch_name);
config_section_t *get_branch_section(const config_t *, const char *branch_name);
config_section_t *get_remote_section(const config_t *, const char *remote_name);
bool is_branch_section(const config_section_t *);
bool is_remote_section(const config_section_t *);
char *get_branch_name(const config_section_t *);
char *get_remote_name(const config_section_t *);
char *get_property_value(const config_section_t *, const char *key);
void set_property_value(const config_section_t *, const char *key, const char *value);

#endif // #ifndef CONFIG_IO_H
f
filename: constants.h

contents: 
 #ifndef CONSTANTS_H
#define CONSTANTS_H

#define HASH_BYTES 20
#define HASH_STRING_LENGTH (HASH_BYTES * 2)

/**
 * A full object (i.e. blob, commit, tag, or tree) hash,
 * e.g. "028d95a21de1a2351f1e47154e93bf69128e9a12",
 * including the null terminator.
 */
typedef char object_hash_t[HASH_STRING_LENGTH + 1];

#endif // #define CONSTANTS_H
ï¿½ï¿½
filename: fetch.h

contents: 
 #ifndef FETCH_H
#define FETCH_H

void fetch(const char *remote_name);
void fetch_all(void);

#endif // #ifndef FETCH_H
1
filename: hash_table.h

contents: 
 #ifndef HASH_TABLE_H
#define HASH_TABLE_H

#include <stdbool.h>
#include <stddef.h>
#include "linked_list.h"

typedef struct hash_table hash_table_t;
typedef struct key_value key_value_t;

void *value_of(const key_value_t *);
char *key_of(const key_value_t *);

hash_table_t *hash_table_init(void);
void free_hash_table(hash_table_t *, free_func_t);

void *hash_table_add(hash_table_t *, const char *key, void *value);
void *hash_table_get(const hash_table_t *, const char *key);
bool hash_table_contains(const hash_table_t *, const char *key);
size_t hash_table_size(const hash_table_t *);
void hash_table_sort(hash_table_t *);

list_node_t *key_set(const hash_table_t *);

#endif

filename: index_io.h

contents: 
 #ifndef INDEX_IO_H
#define INDEX_IO_H

#include <stdint.h>
#include <time.h>
#include "constants.h"
#include "hash_table.h"
#include "object_io.h"

typedef struct index_entry {
    uint32_t size;
    object_hash_t sha1;
    char *fname;
    uint32_t fname_length;
    time_t mtime;
    uint32_t mode;
} index_entry_t;

typedef struct index_file {
    // Maps filenames to their index_entry
    hash_table_t *entries;
} index_file_t;

index_file_t *empty_index_file(void);
index_file_t *read_index_file(void);
void free_index_file(index_file_t *);
void free_index_entry(index_entry_t *);

#endif

filename: linked_list.h

contents: 
 #ifndef LINKED_LIST_H
#define LINKED_LIST_H

typedef struct list_node list_node_t;
typedef struct linked_list linked_list_t;

typedef void (*free_func_t)(void *);

linked_list_t *init_linked_list(void);
void free_linked_list(linked_list_t *, free_func_t freer);

void *list_pop_front(linked_list_t *list);
void list_push_back(linked_list_t *, void *value);

typedef int (*compare_func_t)(void *, void *);
void list_sort(linked_list_t *, compare_func_t cmp);

// List traversal functions

list_node_t *list_head(const linked_list_t *);
list_node_t *node_next(const list_node_t *);
void *node_value(const list_node_t *);

#endif

filename: log.h

contents: 
 #ifndef LOG_H
#define LOG_H

void mygit_log(const char *ref);

#endif // #ifndef LOG_H

filename: object_io.h

contents: 
 #ifndef OBJECT_IO_H
#define OBJECT_IO_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <time.h>
#include "transport.h"

void *read_object(const object_hash_t hash, object_type_t *type, size_t *length);

typedef struct {
    object_hash_t tree_hash;
    size_t parents;
    object_hash_t *parent_hashes;
    char *author;
    time_t author_time;
    char *committer;
    time_t commit_time;
    char *message;
} commit_t;

commit_t *read_commit(const object_hash_t hash);
void free_commit(commit_t *);

typedef enum {
    MODE_DIRECTORY  = 0040000,
    MODE_FILE       = 0100644,
    MODE_EXECUTABLE = 0100755,
    MODE_SYMLINK    = 0120000
} file_mode_t;

typedef struct {
    file_mode_t mode;
    char *name; // file or directory name
    object_hash_t hash; // blob (for files) or tree (for directories)
} tree_entry_t;

typedef struct {
    size_t entry_count;
    tree_entry_t *entries;
} tree_t;

tree_t *read_tree(const object_hash_t hash);
void free_tree(tree_t *);

typedef struct {
    size_t length;
    uint8_t *contents;
} blob_t;

blob_t *read_blob(const object_hash_t hash);
void free_blob(blob_t *);

void apply_ref_delta(
    const object_hash_t base_hash,
    const uint8_t *data,
    size_t length,
    object_hash_t hash
);

void write_object(
    object_type_t type,
    const void *contents,
    size_t length,
    object_hash_t hash
);

void get_object_hash(
    object_type_t type,
    const void *contents,
    size_t length,
    object_hash_t hash
);

void *read_object(const object_hash_t hash, object_type_t *type, size_t *length);

void free_tree_entry(tree_entry_t *tree_entry);
void free_tree_mine(tree_t *tree);

#endif // #ifndef OBJECT_IO_H
 x
filename: push.h

contents: 
 #ifndef PUSH_H
#define PUSH_H

#include <stddef.h>

/**
 * Pushes the specified branch names to their respective remotes.
 * If `branch_count` is 0 and `branches` is NULL, pushes all local branches.
 *
 * @param branch_count the number of branches to push
 * @param branches the names of all the branches to push
 * @param set_remote if non-NULL, the remote to configure these branches to be pushed to
 */
void push(size_t branch_count, const char **branches, const char *set_remote);

#endif // #ifndef PUSH_H

filename: ref_io.h

contents: 
 #ifndef REF_IO_H
#define REF_IO_H

#include <stdbool.h>
#include "constants.h"
#include "linked_list.h"

char *read_head_file(bool *detached);
void write_head_file(const char *contents, bool detached);
bool head_to_hash(const char *head, bool detached, object_hash_t hash);

bool get_branch_ref(const char *branch, object_hash_t hash);
void set_branch_ref(const char *branch, const object_hash_t hash);

bool get_remote_ref(const char *remote, const char *ref, object_hash_t hash);
void set_remote_ref(const char *remote, const char *ref, const object_hash_t hash);

bool branch_exists(const char *branch_name);

linked_list_t *list_branch_refs(void);

#endif // #ifndef REF_IO_H

filename: status.h

contents: 
 #ifndef STATUS_H
#define STATUS_H

void status(void);

#endif // #ifndef STATUS_H
Q
filename: transport.h

contents: 
 /*
 * The git protocol is described at https://github.com/git/git/blob/master/Documentation/gitprotocol-pack.txt
 * Fetching consists of several stages:
 * - The client opens an SSH connection to the server.
 *   Call open_transport(FETCH, ...) to initiate this SSH connection.
 * - The server sends a list of "refs" it knows about,
 *   i.e. branches and tags and their corresponding commit hashes.
 *   Call receive_refs() to handle each ref received from the server.
 * - The client chooses zero or more of these commit hashes that it wants to fetch.
 *   Call send_want() on each commit hash you want to receive.
 *   Call finish_wants() once the commit hashes have been sent.
 *   If no commit hashes were requested, STOP and call close_transport()!
 * - The client tells the server which commits hashes it already has,
 *   so the server can minimize the amount of data sent.
 *   There are different ways the server can decide the oldest commit it needs to send;
 *   we are using the basic strategy: the server chooses
 *   the first commit hash sent by the client that the server also has.
 *   This means that if you want to fetch the newest `master`, for example,
 *   the client should send the commit hash of `master` locally, then its parent,
 *   and so on, until it reaches a commit hash that the server also has.
 *   Call send_have() to send each local commit hash to the server.
 *   Call check_have_acks() periodically to check whether the server
 *   knows any of the commit hashes sent since the last check_have_acks().
 *   But don't call it after every commit hash, since it waits for the server to respond.
 *   Once the server returns that it is ready (or the client knows no more of its commits
 *   are common with the server), call finish_haves().
 * - The server figures out what needs to be sent to the client and sends a PACK file.
 *   This format is documented at https://github.com/git/git/blob/master/Documentation/gitformat-pack.txt
 *   The file contains all the new objects (commits, trees, etc.) that the client needs.
 *   Call receive_pack() to handle each object received from the server.
 *
 * Pushing is a bit simpler since the client must already know the state of the remote:
 * - The client opens an SSH connection using open_transport(PUSH, ...)
 * - The server sends its current refs, just like at the start of a fetch.
 *   Call receive_refs() to receive these remote refs.
 *   If any ref that is going to be pushed points to a different commit on the remote
 *   than what the client thinks is on the remote, the push should be aborted.
 *   The client will need to run a fetch and merge in the remote's changes.
 * - The client sends a list of refs it wants the server to update.
 *   An update can create, delete, or change a branch.
 *   Call send_update() for each update and finish_updates() once all updates are sent.
 *   If no updates were requested, STOP and call close_transport()!
 * - The client sends all the new objects that the server needs in a PACK file.
 *   If no branches were requested to be created or changed, do not send a PACK file!
 *   Call start_pack() to send the header of the PACK file.
 *   Call send_pack_object() for each object (commit, tree, or blob) in the PACK file.
 *   Call finish_pack() once all objects have been sent.
 * - The server tells the client which updates were successful.
 *   Call check_updates() to receive each successfully updated ref.
 */

#ifndef TRANSPORT_H
#define TRANSPORT_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include "constants.h"

extern const char BRANCH_REF_PREFIX[];

typedef enum {
    FETCH,
    PUSH
} transport_direction_t;

typedef struct transport transport_t;

/**
 * Opens a git connection over SSH
 *
 * @param direction whether performing a fetch or a push
 * @param url the SSH login and project, e.g. "git@gitlab.caltech.edu:cs24-19fa/project07"
 * @return a handle to the SSH process that can be used by the functions below
 */
transport_t *open_transport(transport_direction_t direction, char *url);
/** Closes a transport_t obtained from open_transport() */
void close_transport(transport_t *);

/**
 * A callback function called for each ref received from the server.
 * Both `ref` and `hash` may not be used after the callback returns.
 *
 * @param ref the name of the reference, e.g. "refs/heads/master" or "refs/tags/v1.0"
 * @param hash the commit hash, e.g. "00ef4ec3fd981d4e5020634ead3349633dd8ec5a"
 * @param aux an auxiliary value
 */
typedef void (*ref_receiver_t)(char *ref, object_hash_t hash, void *aux);

/**
 * Discovers all refs in the remote repository.
 * Calls the callback on each discovered ref.
 * This should be the first operation performed on a RECEIVE transport.
 */
void receive_refs(transport_t *, ref_receiver_t receiver, void *aux);

// FETCH OPERATIONS

void send_want(transport_t *, const object_hash_t hash);
void finish_wants(transport_t *);

/**
 * A callback function called on a commit that the client and server have in common.
 * `hash` may not be used after the callback returns.
 *
 * @param hash the commit hash
 * @param aux an auxiliary value
 */
typedef void (*ack_receiver_t)(object_hash_t hash, void *aux);

void send_have(transport_t *, const object_hash_t hash);
/**
 * Checks with the server which of the haves sent
 * since the last check_have_acks() are also on the server.
 * Calls `receiver` on each common commit hash.
 * Returns whether the server is ready to send the PACK file.
 * Once the server says it is ready, or the client knows no more commits
 * can be common with the server, finish_haves() must be called.
 */
bool check_have_acks(transport_t *, ack_receiver_t receiver, void *aux);
void finish_haves(transport_t *);

/**
 * The types of objects which can be received in a PACK file.
 * See https://github.com/git/git/blob/master/Documentation/gitformat-pack.txt
 *
 * `OBJ_REF_DELTA` is a special type indicating an object that is constructed
 * from sections of another object. See the link above for the format.
 */
typedef enum {
    COMMIT = 1,
    TREE = 2,
    BLOB = 3,
    OBJ_REF_DELTA = 7
} object_type_t;

/**
 * A callback function called when an object is received from the server
 *
 * @param type the type of object that was received
 * @param base_hash if `type == OBJ_REF_DELTA`, the hash of the base object
 *   this object will be constructed from (see "Deltified representation").
 *   Otherwise, NULL. This may not be used after the callback returns.
 * @param contents the bytes that make up this object, or in the `OBJ_REF_DELTA` case,
 *   the instructions to construct the object from the base object.
 *   This is heap-allocated and should be free()d by the callback.
 * @param length the number of bytes in `contents`
 * @param aux an auxiliary value
 */
typedef void (*object_receiver_t)(
    object_type_t type,
    object_hash_t base_hash,
    uint8_t *contents,
    size_t length,
    void *aux
);

void receive_pack(transport_t *, object_receiver_t receiver, void *aux);

// PUSH OPERATIONS

/**
 * Requests that the server update the given ref (e.g. "refs/heads/master")
 * from an old commit hash to a new one.
 * Set `old_hash` to NULL to create a new ref; set `new_hash` to NULL to delete the ref.
 */
void send_update(
    transport_t *,
    const char *ref,
    const object_hash_t old_hash,
    const object_hash_t new_hash
);
void finish_updates(transport_t *);

void start_pack(transport_t *, size_t object_count);
void send_pack_object(
    transport_t *,
    object_type_t type,
    const uint8_t *contents,
    size_t length
);
void finish_pack(transport_t *);

/**
 * A callback function called when a remote ref is updated successfully.
 * `ref` may not be used after the callback returns.
 *
 * @param ref the ref that was updated, e.g. "refs/heads/master"
 * @param aux an auxiliary value
 */
typedef void (*updated_ref_receiver_t)(char *ref, void *aux);

void check_updates(transport_t *, updated_ref_receiver_t receiver, void *aux);

#endif // #ifndef TRANSPORT_H
>ï¿½<
filename: util.h

contents: 
 #ifndef UTIL_H
#define UTIL_H

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "constants.h"
#include "hash_table.h"

#include "config_io.h"

struct list_node {
   list_node_t *next;
   void *value;
};
struct linked_list {
    list_node_t *head;
    list_node_t **tail;
};


uint8_t from_octal(char c);
uint8_t from_decimal(char c);
uint8_t from_hex(char c);

char to_hex(uint8_t value);

void hash_to_hex(const uint8_t hash_bytes[HASH_BYTES], object_hash_t hash_string);
void hex_to_hash(const object_hash_t hash_string, uint8_t hash_bytes[HASH_BYTES]);

// Reads a big-endian unsigned integer with the given number of bytes
size_t read_be(const uint8_t *bytes, size_t length);

// Writes a big-endian unsigned integer with the given number of bytes
void write_be(size_t value, uint8_t *bytes, size_t length);

bool starts_with(const char *string, const char *prefix);

void make_dirs(char *path);
void make_parent_dirs(char *path);

size_t get_file_size(FILE *f);
char *get_file_contents(const char *file_path);

void expand_tree(object_hash_t tree_hash, hash_table_t* hash_table, char *curr_chars);
bool is_valid_commit_hash(const char *hash);

char *get_url(config_section_t *remote);
char *get_last_dir(char *file_dir_name);
char **split_path_into_directories(char *path);


#endif // #ifndef UTIL_H
}a7
filename: lll

contents: 
 100755 ec17f0ef9a3c55b1cb1be43f838d8a8b06fecf43 0	.gitignore
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 29	flags: 0
100755 2b1eecb1823083550dc3205773d6761fb847d58a 0	.gitlab-ci.yml
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 104	flags: 0
100755 fd1b7e93724b52179d5db87a206d3142ebb5ac01 0	Makefile
  ctime: 0:0
  mtime: 3200171710:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 784	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	aaaa
  ctime: 0:0
  mtime: 1715048757:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	aaaab
  ctime: 0:0
  mtime: 1715048757:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	bin/.gitkeep
  ctime: 0:0
  mtime: 1715044223:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100755 9c08f7c143e58bceece73486a9ad1d135714cdb5 0	bruh3
  ctime: 0:0
  mtime: 1715046566:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 8214	flags: 0
100755 c6d40d221621fbb49a6c6a2bd57415864aa0cfe3 0	bruhasdfasdv
  ctime: 0:0
  mtime: 1715055198:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 20	flags: 0
100755 a831ad706360fa0db6782617b9fd4e5cb4eb7d92 0	bruhnahhh
  ctime: 0:0
  mtime: 1715051379:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 7598	flags: 0
100755 540b0654c4584fbb1a583e449928b44c7c4ab9a6 0	bruhnahhh1
  ctime: 0:0
  mtime: 1715051229:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 9314	flags: 0
100755 c66e59454e7114d8748d995d15d829c7f17768ad 0	bruhnahhh2
  ctime: 0:0
  mtime: 1715051483:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 9300	flags: 0
100755 4bfea11dfac252c5a15a1b2a4489a0c98703b81b 0	bruhnahhh3
  ctime: 0:0
  mtime: 1715047010:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 7426	flags: 0
100755 1b8153328935a7c1061055518c152397b4cfb20b 0	debuggy
  ctime: 0:0
  mtime: 1715056273:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 8487	flags: 0
100755 e2a9f425a14176b989410dc84fdf93599f58d9a2 0	debuggy2
  ctime: 0:0
  mtime: 1715056358:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 10601	flags: 0
100755 6f913a11ff73fa38a02933e9675d794f1ae5cf6b 0	expand-all-packfiles
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 813	flags: 0
100755 661e87d55a4c835c68ec92594c4c0a5c36595813 0	include/add.h
  ctime: 0:0
  mtime: 1715054570:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 183	flags: 0
100755 b950eeae8aea44e7eb85c11dfcdcb0904c8b90bd 0	include/checkout.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 137	flags: 0
100755 979cc48faea9e8407f4858d69b37239c7a509066 0	include/commit.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 90	flags: 0
100755 21dc5a14662beb2212e6721db17d95adae367185 0	include/config_io.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 1298	flags: 0
100755 a5b8e44f9eba70b73bdcd4d34ac35f49546390fe 0	include/constants.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 356	flags: 0
100755 648f7b51fd6e2d13d00ac0a3f4da4cbc7a461317 0	include/fetch.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 126	flags: 0
100755 8fd07fb39a8783db3050b9162327f76fdb6364df 0	include/hash_table.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 707	flags: 0
100755 3472d69ef508e2d49431f967665e00e85f33cbb6 0	include/index_io.h
  ctime: 0:0
  mtime: 1715049911:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 624	flags: 0
100755 28a562e9d8ab2917df07178794d4a6f003b73d5f 0	include/linked_list.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 651	flags: 0
100755 195ae2200c35b38b10e2bae2813c2ed4d68c7f46 0	include/log.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 93	flags: 0
100755 6d94a2d89d0699364f438fb595c74daa97f4460c 0	include/object_io.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 1483	flags: 0
100755 95db7f58650f75d190ee5f2c9f54ccb34e1014e3 0	include/push.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 527	flags: 0
100755 c5083f3806b00198d0eba4c66551f2cd1fe36962 0	include/ref_io.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 654	flags: 0
100755 2e7699cc5b1f9debd233cee24b4d014ad94b91b5 0	include/status.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 88	flags: 0
100755 deabb843000c504714074bc3e4dc8626fdee303f 0	include/transport.h
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 8272	flags: 0
100755 87c718a897681171bb729e75170ad3f925a9c121 0	include/util.h
  ctime: 0:0
  mtime: 1715045811:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 914	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	newbrodie
  ctime: 0:0
  mtime: 1715051280:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	out/.gitkeep
  ctime: 0:0
  mtime: 1715044223:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	revealfile
  ctime: 0:0
  mtime: 1715053387:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100755 cbfc8455e057ff29b8bc0857c124b3ecf9041dbf 0	src/add.c
  ctime: 0:0
  mtime: 1715139218:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 9776	flags: 0
100755 c855383c5babedd70eebec59e020c9bc436462ff 0	src/checkout.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 232	flags: 0
100755 85643cbf09e0bea81c6cc837f249c18adf85cd63 0	src/commit.c
  ctime: 0:0
  mtime: 1715052552:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 6040	flags: 0
100755 b549117398f36f979a65c013363b0157910df31d 0	src/config_io.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 10556	flags: 0
100755 c3fb8e67ac0495c613ac3993f24ec7918e8ef4ae 0	src/fetch.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 1140	flags: 0
100755 dce7d7d36a3ce4adcb1f59da9dc1a990aba70f42 0	src/hash_table.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 3962	flags: 0
100755 c3d6b98b186971edff511b5118ff13d55494f25b 0	src/index_io.c
  ctime: 0:0
  mtime: 1715055894:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 6639	flags: 0
100755 27e327a8d2dcebbb9d4e31dd0649b480231c6829 0	src/linked_list.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 3554	flags: 0
100755 3e3c3cd5093ab5791a6786d4790618ec99fa91bc 0	src/log.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 272	flags: 0
100755 83a38a6caec94c8a0565504b11389e15502d41bc 0	src/main.c
  ctime: 0:0
  mtime: 1715140017:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 698	flags: 0
100755 ae4a7ac7c8292cc9f59a72b7afa1bdf4110b7bdd 0	src/mygit.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 7029	flags: 0
100755 42f0cbec501fdfc3b3481416f582f1eb9d19852d 0	src/object_io.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 16478	flags: 0
100755 dd3435e5c0e40a967dbef4dd26e8d3b95b7c580f 0	src/push.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 479	flags: 0
100755 74b8416bc59144fd0084c6d25759e96cefdc8e25 0	src/ref_io.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 4799	flags: 0
100755 9198d74e2819ad48a4fd7f9770dbfbaaabc05cab 0	src/status.c
  ctime: 0:0
  mtime: 1715044888:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 5486	flags: 0
100755 5637785d7573777f1c8360afa212ff8a076dbd08 0	src/transport.c
  ctime: 0:0
  mtime: 1715044282:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 33282	flags: 0
100755 f5f803f928f16d6ebfad595086169958fe8feb1c 0	src/util.c
  ctime: 0:0
  mtime: 1715045839:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 3689	flags: 0
100755 01f02e32ce8a128dd7b1d16a45f2eff66ec23c2d 0	temp2
  ctime: 0:0
  mtime: 1715055052:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 3	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	temp3
  ctime: 0:0
  mtime: 1715055846:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100755 41196caa77708da3d2fa4049a39e046566a1f48a 0	temp_idx_file
  ctime: 0:0
  mtime: 1715056259:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 4460	flags: 0
100755 8fc4b731e0e30d8b1e821f3f8196e5eb4f59a878 0	temp_idx_file2
  ctime: 0:0
  mtime: 1715051373:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 4012	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	tet
  ctime: 0:0
  mtime: 1715050774:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 0	flags: 0
100755 7c4a013e52c76442ab80ee5572399a30373600a2 0	trippin
  ctime: 0:0
  mtime: 1715050874:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 3	flags: 0
100755 8aeed6ff2e38c6de09d06f5eea289bbb6fdd8768 0	try4asdfas
  ctime: 0:0
  mtime: 1715056240:0
  dev: 0	ino: 0
  uid: 0	gid: 0
  size: 28	flags: 0
ï¿½
filename: lll2

contents: 
 100755 ec17f0ef9a3c55b1cb1be43f838d8a8b06fecf43 0	.gitignore
  ctime: 1715044282:842332700
  mtime: 1715044282:842332700
  dev: 83	ino: 1646398
  uid: 1000	gid: 1000
  size: 29	flags: 0
100755 2b1eecb1823083550dc3205773d6761fb847d58a 0	.gitlab-ci.yml
  ctime: 1715044282:843371100
  mtime: 1715044282:843371100
  dev: 83	ino: 1665716
  uid: 1000	gid: 1000
  size: 104	flags: 0
100755 fd1b7e93724b52179d5db87a206d3142ebb5ac01 0	Makefile
  ctime: 1715142004:653971100
  mtime: 1715142004:653971100
  dev: 83	ino: 1665729
  uid: 1000	gid: 1000
  size: 784	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	aaaab
  ctime: 1715143244:984544800
  mtime: 1715048757:990945600
  dev: 83	ino: 1684924
  uid: 1000	gid: 1000
  size: 0	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	bin/.gitkeep
  ctime: 1715044223:777468300
  mtime: 1715044223:777468300
  dev: 83	ino: 1665774
  uid: 1000	gid: 1000
  size: 0	flags: 0
100755 9c08f7c143e58bceece73486a9ad1d135714cdb5 0	bruh3
  ctime: 1715046566:294560100
  mtime: 1715046566:294560100
  dev: 83	ino: 1684586
  uid: 1000	gid: 1000
  size: 8214	flags: 0
100755 c6d40d221621fbb49a6c6a2bd57415864aa0cfe3 0	bruhasdfasdv
  ctime: 1715055198:381510700
  mtime: 1715055198:381510700
  dev: 83	ino: 47027
  uid: 1000	gid: 1000
  size: 20	flags: 0
100755 a831ad706360fa0db6782617b9fd4e5cb4eb7d92 0	bruhnahhh
  ctime: 1715051379:929194100
  mtime: 1715051379:929194100
  dev: 83	ino: 1684613
  uid: 1000	gid: 1000
  size: 7598	flags: 0
100755 540b0654c4584fbb1a583e449928b44c7c4ab9a6 0	bruhnahhh1
  ctime: 1715051229:856943700
  mtime: 1715051229:856943700
  dev: 83	ino: 76889
  uid: 1000	gid: 1000
  size: 9314	flags: 0
100755 c66e59454e7114d8748d995d15d829c7f17768ad 0	bruhnahhh2
  ctime: 1715051483:592234700
  mtime: 1715051483:592234700
  dev: 83	ino: 1682401
  uid: 1000	gid: 1000
  size: 9300	flags: 0
100755 4bfea11dfac252c5a15a1b2a4489a0c98703b81b 0	bruhnahhh3
  ctime: 1715047010:318949700
  mtime: 1715047010:318949700
  dev: 83	ino: 208196
  uid: 1000	gid: 1000
  size: 7426	flags: 0
100755 1b8153328935a7c1061055518c152397b4cfb20b 0	debuggy
  ctime: 1715056273:742586800
  mtime: 1715056273:742586800
  dev: 83	ino: 1685547
  uid: 1000	gid: 1000
  size: 8487	flags: 0
100755 e2a9f425a14176b989410dc84fdf93599f58d9a2 0	debuggy2
  ctime: 1715056358:718091900
  mtime: 1715056358:718091900
  dev: 83	ino: 1685495
  uid: 1000	gid: 1000
  size: 10601	flags: 0
100755 6f913a11ff73fa38a02933e9675d794f1ae5cf6b 0	expand-all-packfiles
  ctime: 1715044282:845337600
  mtime: 1715044282:845337600
  dev: 83	ino: 1665730
  uid: 1000	gid: 1000
  size: 813	flags: 0
100755 661e87d55a4c835c68ec92594c4c0a5c36595813 0	include/add.h
  ctime: 1715054570:433137400
  mtime: 1715054570:433137400
  dev: 83	ino: 1665745
  uid: 1000	gid: 1000
  size: 183	flags: 0
100755 b950eeae8aea44e7eb85c11dfcdcb0904c8b90bd 0	include/checkout.h
  ctime: 1715044282:847404100
  mtime: 1715044282:847404100
  dev: 83	ino: 1665748
  uid: 1000	gid: 1000
  size: 137	flags: 0
100755 979cc48faea9e8407f4858d69b37239c7a509066 0	include/commit.h
  ctime: 1715044282:848323800
  mtime: 1715044282:848323800
  dev: 83	ino: 1665776
  uid: 1000	gid: 1000
  size: 90	flags: 0
100755 21dc5a14662beb2212e6721db17d95adae367185 0	include/config_io.h
  ctime: 1715044282:849330500
  mtime: 1715044282:849330500
  dev: 83	ino: 1665778
  uid: 1000	gid: 1000
  size: 1298	flags: 0
100755 a5b8e44f9eba70b73bdcd4d34ac35f49546390fe 0	include/constants.h
  ctime: 1715044282:850326700
  mtime: 1715044282:850326700
  dev: 83	ino: 1665780
  uid: 1000	gid: 1000
  size: 356	flags: 0
100755 648f7b51fd6e2d13d00ac0a3f4da4cbc7a461317 0	include/fetch.h
  ctime: 1715044282:850326700
  mtime: 1715044282:850326700
  dev: 83	ino: 1665794
  uid: 1000	gid: 1000
  size: 126	flags: 0
100755 8fd07fb39a8783db3050b9162327f76fdb6364df 0	include/hash_table.h
  ctime: 1715044282:851330500
  mtime: 1715044282:851330500
  dev: 83	ino: 1665799
  uid: 1000	gid: 1000
  size: 707	flags: 0
100755 3472d69ef508e2d49431f967665e00e85f33cbb6 0	include/index_io.h
  ctime: 1715049911:590020500
  mtime: 1715049911:590020500
  dev: 83	ino: 1665821
  uid: 1000	gid: 1000
  size: 624	flags: 0
100755 28a562e9d8ab2917df07178794d4a6f003b73d5f 0	include/linked_list.h
  ctime: 1715044282:853330000
  mtime: 1715044282:853330000
  dev: 83	ino: 1665824
  uid: 1000	gid: 1000
  size: 651	flags: 0
100755 195ae2200c35b38b10e2bae2813c2ed4d68c7f46 0	include/log.h
  ctime: 1715044282:854352300
  mtime: 1715044282:854352300
  dev: 83	ino: 1665827
  uid: 1000	gid: 1000
  size: 93	flags: 0
100755 6d94a2d89d0699364f438fb595c74daa97f4460c 0	include/object_io.h
  ctime: 1715044282:855357800
  mtime: 1715044282:855357800
  dev: 83	ino: 1665830
  uid: 1000	gid: 1000
  size: 1483	flags: 0
100755 95db7f58650f75d190ee5f2c9f54ccb34e1014e3 0	include/push.h
  ctime: 1715044282:857330700
  mtime: 1715044282:857330700
  dev: 83	ino: 1665834
  uid: 1000	gid: 1000
  size: 527	flags: 0
100755 c5083f3806b00198d0eba4c66551f2cd1fe36962 0	include/ref_io.h
  ctime: 1715044282:857330700
  mtime: 1715044282:857330700
  dev: 83	ino: 1665835
  uid: 1000	gid: 1000
  size: 654	flags: 0
100755 2e7699cc5b1f9debd233cee24b4d014ad94b91b5 0	include/status.h
  ctime: 1715044282:858326100
  mtime: 1715044282:858326100
  dev: 83	ino: 1665841
  uid: 1000	gid: 1000
  size: 88	flags: 0
100755 deabb843000c504714074bc3e4dc8626fdee303f 0	include/transport.h
  ctime: 1715044282:859333500
  mtime: 1715044282:859333500
  dev: 83	ino: 1665853
  uid: 1000	gid: 1000
  size: 8272	flags: 0
100755 87c718a897681171bb729e75170ad3f925a9c121 0	include/util.h
  ctime: 1715045811:983921300
  mtime: 1715045811:983921300
  dev: 83	ino: 1665857
  uid: 1000	gid: 1000
  size: 914	flags: 0
100755 d1f74a4b283bb24fc0f108fa1b3da9fcd4f3558d 0	lll
  ctime: 1715143279:514210900
  mtime: 1715143279:514210900
  dev: 83	ino: 1701033
  uid: 1000	gid: 1000
  size: 8779	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	newbrodie
  ctime: 1715051280:352536400
  mtime: 1715051280:352536400
  dev: 83	ino: 807739
  uid: 1000	gid: 1000
  size: 0	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	out/.gitkeep
  ctime: 1715044223:787455800
  mtime: 1715044223:787455800
  dev: 83	ino: 1666214
  uid: 1000	gid: 1000
  size: 0	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	revealfile
  ctime: 1715053387:807567400
  mtime: 1715053387:807567400
  dev: 83	ino: 368315
  uid: 1000	gid: 1000
  size: 0	flags: 0
100755 cbfc8455e057ff29b8bc0857c124b3ecf9041dbf 0	src/add.c
  ctime: 1715143210:350594000
  mtime: 1715143210:350594000
  dev: 83	ino: 1665860
  uid: 1000	gid: 1000
  size: 9776	flags: 0
100755 c855383c5babedd70eebec59e020c9bc436462ff 0	src/checkout.c
  ctime: 1715044282:861338300
  mtime: 1715044282:861338300
  dev: 83	ino: 1665874
  uid: 1000	gid: 1000
  size: 232	flags: 0
100755 f174467be5f4d561d44cbb40ab8bc4b80ca12540 0	src/commit.c
  ctime: 1715142277:111103800
  mtime: 1715142277:111103800
  dev: 83	ino: 1665880
  uid: 1000	gid: 1000
  size: 5299	flags: 0
100755 b549117398f36f979a65c013363b0157910df31d 0	src/config_io.c
  ctime: 1715044282:862331000
  mtime: 1715044282:862331000
  dev: 83	ino: 1665890
  uid: 1000	gid: 1000
  size: 10556	flags: 0
100755 c3fb8e67ac0495c613ac3993f24ec7918e8ef4ae 0	src/fetch.c
  ctime: 1715044282:863345000
  mtime: 1715044282:863345000
  dev: 83	ino: 1665893
  uid: 1000	gid: 1000
  size: 1140	flags: 0
100755 dce7d7d36a3ce4adcb1f59da9dc1a990aba70f42 0	src/hash_table.c
  ctime: 1715044282:864333800
  mtime: 1715044282:864333800
  dev: 83	ino: 1665897
  uid: 1000	gid: 1000
  size: 3962	flags: 0
100755 c3d6b98b186971edff511b5118ff13d55494f25b 0	src/index_io.c
  ctime: 1715055894:591369100
  mtime: 1715055894:591369100
  dev: 83	ino: 1665911
  uid: 1000	gid: 1000
  size: 6639	flags: 0
100755 27e327a8d2dcebbb9d4e31dd0649b480231c6829 0	src/linked_list.c
  ctime: 1715044282:865323700
  mtime: 1715044282:865323700
  dev: 83	ino: 1666212
  uid: 1000	gid: 1000
  size: 3554	flags: 0
100755 3e3c3cd5093ab5791a6786d4790618ec99fa91bc 0	src/log.c
  ctime: 1715044282:866332800
  mtime: 1715044282:866332800
  dev: 83	ino: 1666216
  uid: 1000	gid: 1000
  size: 272	flags: 0
100755 83a38a6caec94c8a0565504b11389e15502d41bc 0	src/main.c
  ctime: 1715140017:531552700
  mtime: 1715140017:531552700
  dev: 83	ino: 809287
  uid: 1000	gid: 1000
  size: 698	flags: 0
100755 8b022c487e2cd2d98c542584b373dfea56281be8 0	src/main.exe
  ctime: 1715139947:742374100
  mtime: 1715139947:742374100
  dev: 83	ino: 1701337
  uid: 1000	gid: 1000
  size: 121021	flags: 0
100755 ae4a7ac7c8292cc9f59a72b7afa1bdf4110b7bdd 0	src/mygit.c
  ctime: 1715044282:867337700
  mtime: 1715044282:867337700
  dev: 83	ino: 1666217
  uid: 1000	gid: 1000
  size: 7029	flags: 0
100755 42f0cbec501fdfc3b3481416f582f1eb9d19852d 0	src/object_io.c
  ctime: 1715044282:868372300
  mtime: 1715044282:868372300
  dev: 83	ino: 1666218
  uid: 1000	gid: 1000
  size: 16478	flags: 0
100755 dd3435e5c0e40a967dbef4dd26e8d3b95b7c580f 0	src/push.c
  ctime: 1715044282:869336300
  mtime: 1715044282:869336300
  dev: 83	ino: 1666219
  uid: 1000	gid: 1000
  size: 479	flags: 0
100755 74b8416bc59144fd0084c6d25759e96cefdc8e25 0	src/ref_io.c
  ctime: 1715044282:869336300
  mtime: 1715044282:869336300
  dev: 83	ino: 1666220
  uid: 1000	gid: 1000
  size: 4799	flags: 0
100755 9198d74e2819ad48a4fd7f9770dbfbaaabc05cab 0	src/status.c
  ctime: 1715044888:458847900
  mtime: 1715044888:458847900
  dev: 83	ino: 1666221
  uid: 1000	gid: 1000
  size: 5486	flags: 0
100755 5637785d7573777f1c8360afa212ff8a076dbd08 0	src/transport.c
  ctime: 1715044282:872335500
  mtime: 1715044282:872335500
  dev: 83	ino: 1666222
  uid: 1000	gid: 1000
  size: 33282	flags: 0
100755 f5f803f928f16d6ebfad595086169958fe8feb1c 0	src/util.c
  ctime: 1715045839:144237100
  mtime: 1715045839:144237100
  dev: 83	ino: 1666223
  uid: 1000	gid: 1000
  size: 3689	flags: 0
100755 01f02e32ce8a128dd7b1d16a45f2eff66ec23c2d 0	temp2
  ctime: 1715055052:954655200
  mtime: 1715055052:954655200
  dev: 83	ino: 1685168
  uid: 1000	gid: 1000
  size: 3	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	temp3
  ctime: 1715055846:953735700
  mtime: 1715055846:953735700
  dev: 83	ino: 260134
  uid: 1000	gid: 1000
  size: 0	flags: 0
100755 41196caa77708da3d2fa4049a39e046566a1f48a 0	temp_idx_file
  ctime: 1715056259:179100800
  mtime: 1715056259:179100800
  dev: 83	ino: 1685399
  uid: 1000	gid: 1000
  size: 4460	flags: 0
100755 8fc4b731e0e30d8b1e821f3f8196e5eb4f59a878 0	temp_idx_file2
  ctime: 1715051373:74845200
  mtime: 1715051373:74845200
  dev: 83	ino: 1684823
  uid: 1000	gid: 1000
  size: 4012	flags: 0
100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0	tet
  ctime: 1715050778:612038300
  mtime: 1715050774:183857000
  dev: 83	ino: 1685194
  uid: 1000	gid: 1000
  size: 0	flags: 0
100755 7c4a013e52c76442ab80ee5572399a30373600a2 0	trippin
  ctime: 1715050874:2790600
  mtime: 1715050874:2790600
  dev: 83	ino: 1500092
  uid: 1000	gid: 1000
  size: 3	flags: 0
100755 8aeed6ff2e38c6de09d06f5eea289bbb6fdd8768 0	try4asdfas
  ctime: 1715056240:319025200
  mtime: 1715056240:319025200
  dev: 83	ino: 956189
  uid: 1000	gid: 1000
  size: 28	flags: 0

filename: lolski

contents: 
 aaaaa
filename: lolski2

contents: 
 aaaaavvvv
ï¿½ï¿½>
filename: mine

contents: 
 tree 643ac7bac9eac54fe5a181f85fb89e92976c50f6
parent 426c513c09a6c84a409329539561714eca5389c0
author kevin <kdo@caltech.edu> 1715384056 -0700
committer kevin <kdo@caltech.edu> 1715384056 -0700

hmmmm

filename: mysrc

contents: 
 100755 blob 903677c6117bc7ae96e3957fe50e3131c13ac04b	add.c
040000 tree f0df58b11f08722aca058aaa8478654a00cb9615	src/brodie/
040000 tree f6801152e031533e632256d3c1eebacaf6002264	src/brodie2/
100755 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	bvasdfv
100755 blob c855383c5babedd70eebec59e020c9bc436462ff	checkout.c
100755 blob bd5e00489ea83f8814186141e36f315b883e0157	commit.c
100755 blob b549117398f36f979a65c013363b0157910df31d	config_io.c
100755 blob c3fb8e67ac0495c613ac3993f24ec7918e8ef4ae	fetch.c
100755 blob dce7d7d36a3ce4adcb1f59da9dc1a990aba70f42	hash_table.c
100755 blob c3d6b98b186971edff511b5118ff13d55494f25b	index_io.c
100755 blob 27e327a8d2dcebbb9d4e31dd0649b480231c6829	linked_list.c
100755 blob 3e3c3cd5093ab5791a6786d4790618ec99fa91bc	log.c
100755 blob 0ae6abf89b8152b323c5196a85e1a20291703a9d	main.c
100755 blob 0b64d05ddc8789177dbb855b12f73924f45f9a78	main.exe
100755 blob ae4a7ac7c8292cc9f59a72b7afa1bdf4110b7bdd	mygit.c
100755 blob 27516adb83046a433fc81cfbcf908a860f5f03ab	object_io.c
100755 blob dd3435e5c0e40a967dbef4dd26e8d3b95b7c580f	push.c
100755 blob 74b8416bc59144fd0084c6d25759e96cefdc8e25	ref_io.c
100755 blob c8f8e952ee12cb6ea1c008853903c8d885a260a6	status.c
100755 blob 5637785d7573777f1c8360afa212ff8a076dbd08	transport.c
100755 blob f5f803f928f16d6ebfad595086169958fe8feb1c	util.c
100755 blob 081f5567a63d78013f81242f39df9b5c04464e24	yoooo
1
filename: new_filetest

contents: 
 ï¿½ï¿½ï¿½>
filename: newbrodie

contents: 
 ï¿½ï¿½ï¿½>
filename: out

contents: 
 100755 .gitkeep
filename: .gitkeep

contents: 
 ï¿½ï¿½ï¿½>
filename: revealfile

contents: 
 ï¿½ï¿½ï¿½>
filename: src

contents: 
 100755 add.c
filename: add.c

contents: 
 #include "add.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "index_io.h"
#include "object_io.h"
#include "util.h"
#include <sys/stat.h>
#include <string.h>
#include <unistd.h>


// struct list_node {
//    list_node_t *next;
//    void *value;
// };
// struct linked_list {
//     list_node_t *head;
//     list_node_t **tail;
// };


typedef struct index_header_t{
    char signature[4];
    uint32_t version_number;
    uint32_t number_of_entries;
}index_header_t;

typedef struct index_entry_full_t{
    uint32_t ctime_seconds;
    uint32_t ctime_nanoseconds;
    uint32_t mtime_seconds;
    uint32_t mtime_nanoseconds;
    uint32_t dev;
    uint32_t ino;
    // mode consists of unused (16 bits), object type (4 bits),
    // unused (3 bits), and UNIX perms (9 bits 0644 nonexecuteable, 0755 executeable)
    uint32_t mode;
    uint32_t uid;
    uint32_t gid;
    uint32_t file_size;
    char sha1_hash[HASH_STRING_LENGTH + 1];
    
    uint16_t flags;

    char *file_name;
    char null_byte;
}index_entry_full_t;

uint16_t get_flags(uint32_t fsize){
    if (fsize >= 0xfff){
        return 0xfff;
    }
    return (uint16_t) fsize;
}

int is_executable(const char *path) {
    struct stat file_stat;

    if (stat(path, &file_stat) != 0) {
        return -1; // Return -1 to indicate error
    }
    if (file_stat.st_mode & S_IXUSR || file_stat.st_mode & S_IXGRP || file_stat.st_mode & S_IXOTH) {
        return 1; // Return 1 to indicate executable
    } else {
        return 0; // Return 0 to indicate not executable
    }
}

index_entry_full_t *make_full_index_entry(index_entry_t *index_entry_temp){
    index_entry_full_t *index_entry = malloc(sizeof(index_entry_full_t));

    index_entry->ctime_seconds = 0;
    index_entry->ctime_nanoseconds = 0;

    struct stat file_stat;
    // TODO: Should this be recalculated and when???
    // printf("index_entry_temp->mtime %ld\n", index_entry_temp->mtime);
    if (index_entry_temp->mtime == 0){
        if (stat(index_entry_temp->fname, &file_stat) == 0) {
                index_entry->mtime_seconds = (uint32_t)file_stat.st_mtime;
            }
        else {
                // Handle error
                // printf("something wrong with stat");
        }
    } else {
        index_entry->mtime_seconds = index_entry_temp->mtime;
    }    

    index_entry->mtime_nanoseconds = 0;
    index_entry->dev = 0;
    index_entry->ino = 0;

    // printf("aasdfasdf filepath: %s", index_entry_temp->fname);

    if (index_entry_temp->mode != 33261 && index_entry_temp->mode != 33188){
        if (is_executable(index_entry_temp->fname)){
            index_entry->mode = 0b00000000000000000000000001000000111101101;
           // 0b00000000000000000000000001000000111101101 //0b00000000000000000000000001000000110100100;//
        } else {
            index_entry->mode = 0b00000000000000000000000001000000110100100;
        }
    } else {
        // printf("index_entry_temp->file %s", index_entry_temp->fname);
        // printf("index_entry_temp->mode %o\n", index_entry_temp->mode);
        index_entry->mode = index_entry_temp->mode; // 0b00000000000000000000000001000000110100100
    }
    
    index_entry->uid = 0;
    index_entry->gid = 0;

    index_entry->file_size = index_entry_temp->size;

    memcpy(index_entry->sha1_hash, index_entry_temp->sha1, HASH_STRING_LENGTH + 1);
    // printf("sha hash  %s\n", index_entry->sha1_hash);

    index_entry->flags = get_flags(index_entry_temp->fname_length);
    index_entry->file_name = malloc(sizeof(char)*(index_entry_temp->fname_length + 1));
    strcpy(index_entry->file_name, index_entry_temp->fname);

    index_entry->null_byte = '\0';

    return index_entry;
}

void free_full_index_entry(index_entry_full_t *index_entry){
    free(index_entry->file_name);
    free(index_entry);
}

size_t get_padding(index_entry_full_t *index_entry){
    // Account for the fact that it's a char pointer, and we just store the

    int n_read = 62;
    n_read += strlen(index_entry->file_name) + 1;

    /* Pad such that n_read % 8 = 0 */
    size_t padding = 8 - (n_read % 8); 

    if (padding == 8){
        return 0;
    }
    return padding;

    // return padding;
}


void write_index(FILE *f, index_entry_full_t *index_entry){

    fwrite(&index_entry->ctime_seconds, sizeof(uint32_t), 1, f);
    fwrite(&index_entry->ctime_nanoseconds, sizeof(uint32_t), 1, f);
    
    
    // printf("bruh %ld\n\n", index_entry->mtime_seconds);

    uint8_t mtime_seconds[4];
    // printf("mtime: %u\n", index_entry->mtime_seconds);
    write_be(index_entry->mtime_seconds, mtime_seconds, 4);
    fwrite(&mtime_seconds, sizeof(uint32_t), 1, f);

    fwrite(&index_entry->mtime_nanoseconds, sizeof(uint32_t), 1, f);

    fwrite(&index_entry->dev, sizeof(uint32_t), 1, f);
    fwrite(&index_entry->ino, sizeof(uint32_t), 1, f);

    uint8_t mode[4];
    write_be(index_entry->mode, mode, 4);
    fwrite(&mode, sizeof(uint32_t), 1, f);
    
    fwrite(&index_entry->uid, sizeof(uint32_t), 1, f);
    fwrite(&index_entry->gid, sizeof(uint32_t), 1, f);

    uint8_t file_size[4];
    write_be(index_entry->file_size, file_size, 4);
    fwrite(&file_size, sizeof(uint32_t), 1, f);
    
    uint8_t hash_bytes[HASH_BYTES];
    hex_to_hash(index_entry->sha1_hash, hash_bytes);

    fwrite(&hash_bytes, sizeof(uint8_t), HASH_BYTES, f);

    uint8_t flags[2];
    write_be(index_entry->flags, flags, 2);
    fwrite(&flags, sizeof(uint16_t), 1, f);

    // we already are writing the null byte with the file_name i guess
    fwrite(index_entry->file_name, sizeof(char), strlen(index_entry->file_name) + 1, f);

    size_t padding = get_padding(index_entry);
    assert(padding < 8);

    uint8_t *padding_array = calloc(padding, sizeof(uint8_t));
    if (padding_array == NULL) {
        // Handle error
    } else {
        fwrite(padding_array, sizeof(uint8_t), padding, f);
        free(padding_array);
    }

}

index_entry_t *make_index_entry(size_t size, object_hash_t sha1, char *fname, uint32_t fname_length, time_t mtime){
    index_entry_t *index_entry = malloc(sizeof(index_entry_t));
    index_entry->size = size;
    // need to copy the sha1 hash
    memcpy(index_entry->sha1, sha1, sizeof(object_hash_t));
    strncpy(index_entry->fname, fname, fname_length);
    index_entry->fname[fname_length] = '\0';
    index_entry->mtime = mtime;
    return index_entry;
}


void write_index_header(FILE *f, uint32_t num_entries){
    // for the null character
    fwrite("DIRC", sizeof(char), 4, f);
    uint32_t version_number = 2;
    uint8_t bytes[4];
    write_be(version_number, bytes, 4);
    fwrite(&bytes, sizeof(uint32_t), 1, f);

    uint8_t num_entry_bytes[4];
    write_be(num_entries, num_entry_bytes, 4);
    fwrite(&num_entry_bytes, sizeof(uint32_t), 1, f);
}

// what to do with added files that are deleted, 
void add_files(const char **file_paths, size_t file_count)
{
    index_file_t *index_file = read_index_file();


    hash_table_t *index_table = index_file->entries;
    uint32_t index_cnts = hash_table_size(index_table);
    // add everything to the index_table

    for (size_t i=0; i < file_count; i++){
        const char *file_path = file_paths[i];
        // printf("file path: %s\n\n", file_path);
        
        char *file_contents = get_file_contents(file_path);
        if (file_contents == NULL){
            // file doesn't exist/deleted
            if (hash_table_contains(index_table, file_path)){

                index_entry_t *prev_entry = hash_table_get(index_table, file_path);
                free_index_entry(prev_entry);
                hash_table_add(index_table, file_path, NULL);
                index_cnts--;
            }
            printf("File \"%s\"has been deleted\n", file_path);
            continue;
        }

        // printf("file contents: %s\n", file_contents);
        object_hash_t hash;
        write_object(BLOB, file_contents, strlen(file_contents), hash);
        index_entry_t *new_entry = malloc(sizeof(index_entry_t));
        new_entry->fname = malloc(sizeof(char) * (strlen(file_path) + 1));
        strcpy(new_entry->fname, file_path);
        new_entry->fname_length = strlen(file_path);
        
        memcpy(new_entry->sha1, hash, sizeof(object_hash_t));
        new_entry->size = strlen(file_contents);

        // printf("new hash: %s\n", hash);
        // needs to be recalculated

        // we needa free the previous one or else you get memory leaks
        if (hash_table_contains(index_table, file_path)){
            index_entry_t *prev_entry = hash_table_get(index_table, file_path);
            free_index_entry(prev_entry);
        } else {
            // its a new one
            new_entry->mode = 0; 
            new_entry->mtime = 0;
            index_cnts++;
        }
        hash_table_add(index_table, file_path, new_entry);
        free(file_contents);
    }

    hash_table_sort(index_table);

    char idx_name[] =  ".git/index"; //"temp_idx_file"; //
    
    FILE *new_index_file = fopen(idx_name, "wb");

    write_index_header(new_index_file, index_cnts); //

    list_node_t *curr_node = key_set(index_table);
    while (curr_node != NULL){
        char *file_path = curr_node->value;

        // file is still there
        index_entry_t *idx_entry = hash_table_get(index_table, file_path);
        if (idx_entry != NULL){
            index_entry_full_t *full_idx = make_full_index_entry(idx_entry);
            write_index(new_index_file, full_idx);
            free_full_index_entry(full_idx);
        }
        curr_node = curr_node->next;
    }
    fclose(new_index_file);     
    free_index_file(index_file);
    // exit(1);
}

filename: brodie

contents: 
 100755 bruh
filename: bruh

contents: 
 ï¿½
ï¿½ï¿½>
filename: brodie2

contents: 
 100755 bbb
filename: bbb

contents: 
 
filename: brodie3

contents: 
 40000 brodie4
filename: brodie4

contents: 
 100755 yoooo
filename: yoooo

contents: 
 ï¿½ï¿½>
filename: yoooo2

contents: 
 sssssss
filename: bruh.c

contents: 
 #include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>


int is_executable(const char *file_path) {
    return access(file_path, X_OK) == 0;
}
int main(int argc, char **argv)
{
    if (is_executable(".gitlab-ci.yml")) {
    printf("The file is executable.\n");
    } else {
        printf("The file is not executable.\n");
    }
}   0
filename: bruh.exe

contents: 
 MZï¿½
filename: checkout.c

contents: 
 #include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "checkout.h"
#include "ref_io.h"
#include "object_io.h"
#include "util.h"
#include "constants.h"
#include "index_io.h"
#include "status.h"
#include <sys/stat.h>
#include "add.h"
#include <unistd.h>

#include "hash_table.h"


char *get_head_commit_hash(){
    bool detached;    
    char *head = read_head_file(&detached);
    char *commit_hash = malloc(sizeof(char) * (HASH_STRING_LENGTH + 1));
    // object_hash_t commit_hash;
    bool found = head_to_hash(head, detached, commit_hash);
    if (!found){
        free(commit_hash);
        printf("Hash not found\n");
        commit_hash = NULL;
    }
    free(head);
    return commit_hash;
}


hash_table_t *get_curr_table(){    
    char *curr_head_commit = get_head_commit_hash();

    if (curr_head_commit == NULL){
        printf("head commit isn't real\n");
        exit(1);
    }

    commit_t *commit = read_commit(curr_head_commit);

    hash_table_t *curr_hash_table = hash_table_init();

    expand_tree(commit->tree_hash, curr_hash_table, "");

    free(curr_head_commit);
    free_commit(commit);
    return curr_hash_table;
}


bool check_local_change(char *file_name, index_entry_t *idx_entry){
    struct stat file_stat;
    if (stat(file_name, &file_stat) == 0) {
        time_t file_mtime = file_stat.st_mtime;
        if (file_mtime == idx_entry->mtime) {
            // mtime of the file is the same as idx_entry->mtime
        } else {
            // mtime of the file is different from idx_entry->mtime

            object_hash_t file_hash;

            char * contents = get_file_contents(file_name);
            get_object_hash(BLOB, contents, strlen(contents), file_hash);

            // printf("file hash: %s", file_hash);
            // printf("sha hash: %s", idx_entry->sha1 );
            free(contents);
            
            return strcmp(idx_entry->sha1, file_hash) != 0;
        }
    } else {
        // handle error from stat, file might not exist which is ok
    }
    return false;
}


void checkout(const char *checkout_name, bool make_branch) {
    if (make_branch) {
        // Create a new branch pointing to the current value of HEAD

        bool detached;    
        char *curr_head = read_head_file(&detached);

        if (strcmp(curr_head, checkout_name) == 0){
            free(curr_head);

            printf("Already on %s\n", checkout_name);
            return;
        }

        if (branch_exists(checkout_name)){
            free(curr_head);
            printf("Branch \"%s\" exists\n", checkout_name);
            return;
        }
        char *head_commit_hash = get_head_commit_hash();


        if (head_commit_hash != NULL){
            set_branch_ref(checkout_name, head_commit_hash);
        } else {
            printf("Note that head commit isn't real\n");
        }
        printf("Switched to a new branch '%s'\n", checkout_name);

        write_head_file(checkout_name, false);
        free(head_commit_hash);
        free(curr_head);

        return;
    } 

    

    char **changed_files = NULL;
    int changed_files_count = 0;
    
    bool detached;    
    char *curr_head = read_head_file(&detached);


    if (strcmp(curr_head, checkout_name) == 0){
        printf("Already on %s\n", checkout_name);
        free(curr_head);
        return;
    }

    char *head_commit = get_head_commit_hash();
    
    if (head_commit == NULL){
        printf("Current head isn't real\n");
        return; 
    }
    
    hash_table_t *curr_commit_table = get_curr_table();


    if (is_valid_commit_hash(checkout_name)) {
        // If name_or_hash is a valid commit hash, checkout to that commit
        commit_t *commit = read_commit(checkout_name); 
        write_head_file(checkout_name, true);
        free_commit(commit);
    } else {
        // Otherwise, assume name_or_hash is a branch name and checkout to that branch
        object_hash_t hash;
        if (!get_branch_ref(checkout_name, hash)){
            
            free_hash_table(curr_commit_table, free);
            free(head_commit);
            free(curr_head);
            printf("Not a branch name \n");
            return;
        }
        write_head_file(checkout_name, false);
    }

    


    index_file_t *idx_file = read_index_file();
    
    hash_table_t *new_commit_table = get_curr_table();

    list_node_t *new_commit_node = key_set(new_commit_table);

    while (new_commit_node != NULL){
        char *file_name = new_commit_node->value;
        char *new_hash = hash_table_get(new_commit_table, file_name);
        char *curr_hash = hash_table_get(curr_commit_table, file_name);
        // the files are different
        // printf("file name: %s\n", file_name);
        // printf("curr_hash: %s\n", curr_hash);
        // printf("new hash checkout: %s\n", new_hash);
        if (curr_hash == NULL || strcmp(curr_hash, new_hash) != 0){
            // printf("yuhhhh\n");
            index_entry_t * idx_entry = hash_table_get(idx_file->entries, file_name); 

            if (access(file_name, F_OK) != -1){
                bool local_change = check_local_change(file_name, idx_entry);
                if (local_change){
                    printf("%s has unstaged changes\n", file_name);
                    write_head_file(curr_head, detached);
                    exit(1);
                }

                if (strcmp(curr_hash, idx_entry->sha1)){
                    printf("%s has uncomomited changes\n", file_name);
                    write_head_file(curr_head, detached);
                    exit(1);
                }
            }
            // printf("Writing file: %s\n", file_name);
            

            object_type_t obj_type;
            size_t length;
            char *blob = read_object(new_hash, &obj_type, &length);
            if (blob == NULL) {
                printf("Failed to open object: %s\n", new_hash);
                exit(1);
            }

            // Open the file in write mode
            FILE *file = fopen(file_name, "w");
            if (file == NULL) {
                printf("Failed to open file: %s\n", file_name);
                exit(1);
            }

            changed_files = realloc(changed_files, (changed_files_count + 1) * sizeof(char *));
            changed_files[changed_files_count] = strdup(file_name);
            changed_files_count++;

            // Write the blob contents to the file
            fwrite(blob, sizeof(char), length, file);

            // Close the file
            fclose(file);

            free(blob);
        }
        new_commit_node = new_commit_node->next;
    }

    // delete files if they don't exist
    list_node_t *curr_commit_keys = key_set(curr_commit_table);

    while (curr_commit_keys != NULL) {
        char *file_name = curr_commit_keys->value;
        char *new_hash = hash_table_get(new_commit_table, file_name);

        // If the file doesn't exist in the new commit, delete it
        if (new_hash == NULL) {
            if (remove(file_name) == 0) {
                printf("Deleted file: %s\n", file_name);
                changed_files = realloc(changed_files, (changed_files_count + 1) * sizeof(char *));
                changed_files[changed_files_count] = strdup(file_name);
                changed_files_count++;
            } else {
                printf("Failed to delete file: %s\n", file_name);
            }
        }

        curr_commit_keys = curr_commit_keys->next;
    }

    printf("Switched to branch %s\n", checkout_name);

    // update the index file
    // printf("List of changed files:\n");
    // for (int i = 0; i < changed_files_count; i++) {
    //     printf("%s\n", changed_files[i]);
    // }    
    add_files((const char **)changed_files, changed_files_count);

    for (int i = 0; i < changed_files_count; i++) {
        free(changed_files[i]);
    }

    free_index_file(idx_file);
    free(curr_head);
    free(changed_files);
    free_hash_table(curr_commit_table, free);
    free_hash_table(new_commit_table, free);
    free(head_commit);
}
filename: commit.c

contents: 
 #include "commit.h"
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "config_io.h"
#include "index_io.h"
#include "object_io.h"
#include "ref_io.h"
#include "util.h"

typedef struct directory_file{
    char *file_dir_name;
    bool is_directory;
} directory_file_t;

typedef struct directory{
    /* data */
    bool completed;
    char *name;
    directory_file_t *directory_files;
    size_t num_files;
} directory_t;

directory_t *make_directory(char *name){
    directory_t * directory = malloc(sizeof(directory_t));
    directory->name = malloc(sizeof(char) * (1 + strlen(name)));
    strcpy(directory->name, name);
    directory->num_files = 0;
    directory->directory_files = NULL;
    directory->completed = false;
    return directory;
}

void add_to_directory(directory_t *directory, char * file_name, bool dir){
    directory->directory_files = realloc(directory->directory_files, sizeof(directory_file_t) * (directory->num_files + 1));

    directory_file_t dir_file;
    dir_file.is_directory = dir;
    dir_file.file_dir_name = file_name;
    
    directory->directory_files[directory->num_files] = dir_file;
    directory->num_files++;
}

void free_directory(directory_t *directory){

    directory_file_t *directory_files = directory->directory_files;
    for (size_t i=0; i < directory->num_files; i++){
        free(directory_files[i].file_dir_name);
    }
    if (directory->directory_files != NULL){
        free(directory->directory_files);
    }
    free(directory->name);
    free(directory);
}

// dictionary from directories to the tree objects
tree_entry_t *make_tree_entry(char *name, file_mode_t mode, object_hash_t hash){
    tree_entry_t *tree_entry = malloc(sizeof(tree_entry_t));
    tree_entry->mode = mode;
    strcpy(tree_entry->hash, hash);
    tree_entry->name = name;
    return tree_entry;
}

// starts off with one tree entry
tree_t *make_empty_tree(){
    tree_t *tree = malloc(sizeof(tree_t));
    assert(tree != NULL);
    tree->entry_count = 0;
    tree->entries = NULL; 
    return tree;
}

void add_to_tree(tree_t *tree, tree_entry_t *tree_entry){
    // printf("tree count %lu\n\n", tree->entry_count);
    tree->entries = realloc(tree->entries, (tree->entry_count + 1) * sizeof(tree_entry_t));
    if (tree->entries == NULL) {
        // Handle error
        // fprintf(stderr, "Failed to allocate memory.\n");
        return;
    }
    tree->entries[tree->entry_count] = *tree_entry;
    tree->entry_count++;
}





void add_to_directory_map(index_entry_t *index_entry, hash_table_t *directory_map) {
    char *file_path = index_entry->fname;
    // char *file_path_copy = strdup(file_path);
    // char *curr_directory = malloc(1);  
    // *curr_directory = '\0';  
    // char *file = strtok(file_path_copy, "/");

    char **file_split = split_path_into_directories(file_path);

    char *curr_directory = strdup("");  // Initialize curr_directory as an empty string
    
    for (int i = 0; file_split[i] != NULL; i++) {
        if (file_split[i+1] == NULL){
            char * file = file_split[i];
            // printf("Directory: %s\n", curr_directory);
            // printf("curr part: %s\n", file);
            if (hash_table_contains(directory_map, curr_directory)){
                directory_t *directory = hash_table_get(directory_map, curr_directory);
                char* part2 = strdup(file);
                add_to_directory(directory, part2, false);
            } else {
                char* dir_copy = strdup(curr_directory);
                directory_t *directory = make_directory(dir_copy);
                char * bruh = strdup(file);
                add_to_directory(directory, bruh, false);
                hash_table_add(directory_map, dir_copy, directory);
                free(dir_copy);
            }
        } else{

            char *prev_dir = strdup(curr_directory);

            size_t new_length = strlen(curr_directory) + strlen(file_split[i]) + 2;  
            curr_directory = realloc(curr_directory, new_length);  // Reallocate memory for curr_directory

            strcat(curr_directory, file_split[i]);
            strcat(curr_directory, "/");  // Append "/" to curr_directory

            // add to the previous directory if the previous directory
            // exists
            // or make a new directory if it's not in the hash table

            if (hash_table_contains(directory_map, curr_directory)){
                // directory_t *directory = hash_table_get(directory_map, prev_dir);
                // char* part2 = strdup(curr_directory);
                // add_to_directory(directory, part2, true);
            } else {
                char* prev_dir_copy = strdup(prev_dir);
                char* dir_copy = strdup(curr_directory);

                assert(hash_table_contains(directory_map, prev_dir_copy));

                directory_t *prev_directory = hash_table_get(directory_map, prev_dir_copy);

                add_to_directory(prev_directory, dir_copy, true);

                directory_t *new_directory = make_directory(dir_copy);

                hash_table_add(directory_map, dir_copy, new_directory);
                // free(dir_copy);
                free(prev_dir_copy);
            }
            free(prev_dir);
        }       
    }
    free(file_split);
    // free(file_path_copy);
    free(curr_directory);
}



void debug_map(const hash_table_t *dir_map){
    list_node_t *head2 = key_set(dir_map);
    while (head2 != NULL) {
        char *file_path = head2->value;
        directory_t *dir = hash_table_get(dir_map, file_path);
        printf("dir name: %s-------------\n", dir->name);
        for (size_t i=0; i < dir->num_files; i++){
            directory_file_t dir_file = dir->directory_files[i];
            if (dir_file.is_directory){
                printf("\tdirectory: %s\n", dir_file.file_dir_name);

                // get_last_dir(dir_file.file_dir_name);
                
            } else {
                printf("\tnot a directory: %s\n", dir_file.file_dir_name);
            }
        }
        printf("\n");
        head2 = head2->next;
    }

    printf("--------------------   end of debug    ----------------\n\n\n");

}


char *get_full_name(char *dir_name, char *file_name){
    char * full_path = malloc(sizeof(char) * (strlen(dir_name) + strlen(file_name) + 1));
    strcpy(full_path, dir_name);
    strcat(full_path, file_name);
    return full_path;
}


char *add_a_stupid_slash(char *string){
    char * name_w_slash = malloc(sizeof(char) * (strlen(string) + 2));
    strcpy(name_w_slash, string);
    strcat(name_w_slash, "/");
    return name_w_slash;
}
bool can_hash(directory_t *dir, hash_table_t *dir_map){
    if (dir->completed){
        return true;
    }
    for (size_t i=0; i < dir->num_files; i++){
        directory_file_t dir_file = dir->directory_files[i];
        if (dir_file.is_directory){
            char *name_w_slash;
            if (dir_file.file_dir_name[strlen(dir_file.file_dir_name)-1] != '/'){
                name_w_slash = add_a_stupid_slash(dir_file.file_dir_name);
            } else {
                name_w_slash = strdup(dir_file.file_dir_name);
            }
            // char * name_w_slash = add_a_stupid_slash(dir_file.file_dir_name);
            
            directory_t * the_dir = hash_table_get(dir_map, name_w_slash);
            assert(the_dir != NULL);
            free(name_w_slash);

            if (!the_dir->completed){
                return false;
            }
        }
    }
    dir->completed = true;
    return true;
}


void write_tree(directory_t *directory, const hash_table_t * index_table, hash_table_t *tree_map) {
    
    uint8_t *contents = malloc(1);
    size_t curr_size = 0;

    // *contents = '\0';
    for (size_t i=0; i < directory->num_files; i ++){
        directory_file_t dir_file = directory->directory_files[i];

        if (dir_file.is_directory){

            assert(hash_table_contains(tree_map, dir_file.file_dir_name));

            void *tree_hash = hash_table_get(tree_map, dir_file.file_dir_name);
            // printf("tree hash len: %s\n", strlen(tree_hash));

            char *last_dir = get_last_dir(dir_file.file_dir_name);

            // char mode_str[12];  // Large enough to hold a 32-bit integer in octal
            // sprintf(mode_str, "%o", idx_entry->mode);
            //bruh

            contents = realloc(contents, curr_size + strlen("40000 ") + strlen(last_dir) + 2 + HASH_BYTES);
            
            memcpy(contents + curr_size, "40000 ", strlen("40000 "));
            curr_size += strlen("40000 ");


            memcpy(contents + curr_size, last_dir, strlen(last_dir));
            curr_size += strlen(last_dir);

            memcpy(contents + curr_size, "\0", 1);
            curr_size += 1;

            uint8_t hash_bytes[HASH_BYTES];
            hex_to_hash(tree_hash, hash_bytes);
            memcpy(contents + curr_size, hash_bytes, HASH_BYTES);
            curr_size += HASH_BYTES;
            free(last_dir);

        } else {
            char *full_name = get_full_name(directory->name, dir_file.file_dir_name);
            // printf("full name : %s\n", full_name);
            index_entry_t *idx_entry = hash_table_get(index_table, full_name);
            assert(idx_entry != NULL);

            char mode_str[12];  // Large enough to hold a 32-bit integer in octal
            sprintf(mode_str, "%o", idx_entry->mode);
            size_t total_size = curr_size + strlen(mode_str) + strlen(dir_file.file_dir_name) + HASH_BYTES + 3;
            contents = realloc(contents, total_size);
            
            
            memcpy(contents + curr_size, mode_str, strlen(mode_str));
            curr_size += strlen(mode_str);
            
            memcpy(contents + curr_size, " ", 1);
            curr_size += 1;
            memcpy(contents + curr_size, dir_file.file_dir_name, strlen(dir_file.file_dir_name));
            curr_size += strlen(dir_file.file_dir_name);
            memcpy(contents + curr_size, "\0", 1);

            curr_size += 1;

            // size_t contents_len = strlen(contents);
            uint8_t hash_bytes[HASH_BYTES];
            hex_to_hash(idx_entry->sha1, hash_bytes);
            memcpy(contents + curr_size, hash_bytes, HASH_BYTES);
            curr_size += HASH_BYTES;
            
            // strcat(contents, hash_bytes);
            // printf("contents: \n%s\n", contents);
            free(full_name);
        }
    }
    object_hash_t hash;
    write_object(TREE, (void *)contents, curr_size, hash);

    char *hash_brodie = malloc(sizeof(char) * 41);
    strcpy(hash_brodie, hash);

    hash_table_add(tree_map, directory->name, hash_brodie);
    free(contents);
}



void directory_traversal(directory_t *curr_root_directory, hash_table_t *dir_map, const hash_table_t * index_table, hash_table_t * tree_map){

    if (can_hash(curr_root_directory, dir_map) ){
        char *dir_name = get_last_dir(curr_root_directory->name);

        // hash the stuff and return remember to write name of the tree not the
        // name of the 
        write_tree(curr_root_directory, index_table, tree_map);
        free(dir_name);
        return;
    }
    for (size_t i=0; i < curr_root_directory->num_files; i ++){
        directory_file_t dir_file = curr_root_directory->directory_files[i];
        char *file_name = dir_file.file_dir_name;

        if (dir_file.is_directory){
            // printf("dir name: %s\n", dir_file.file_dir_name);
            char *name_w_slash;
            if (dir_file.file_dir_name[strlen(dir_file.file_dir_name)-1] != '/'){
                // printf("bruhhhh\n");

                // printf("   %c ???????", dir_file.file_dir_name[strlen(dir_file.file_dir_name)-1]);
                name_w_slash = add_a_stupid_slash(dir_file.file_dir_name);
            } else {
                name_w_slash = strdup(dir_file.file_dir_name);
            }


            assert(hash_table_contains(dir_map, name_w_slash));

            directory_t * directory = hash_table_get(dir_map, name_w_slash);
            if (!directory->completed){
                directory_traversal(directory, dir_map, index_table, tree_map);
                directory->completed = true;
            } 
            free(name_w_slash);
        } else {
            // it has to be a blob object, make it into the tree entry
            char *full_path = get_full_name(curr_root_directory->name, file_name);
            assert(hash_table_contains(index_table, full_path));
            free(full_path);
        }
    }    
    char *dir_name = get_last_dir(curr_root_directory->name);

    // printf("i can be hashed %s\n", dir_name);
    // hash the stuff and return remember to write name of the tree not the
    // name of the 
    write_tree(curr_root_directory, index_table, tree_map);
    free(dir_name);
    curr_root_directory->completed = true;
}

char *make_tree_from_idx(hash_table_t *tree_map){
    index_file_t *index_file = read_index_file();
    hash_table_t *index_table = index_file->entries;

    hash_table_sort(index_table);

    list_node_t *head = key_set(index_table);

    // // Count the number of nodes in the linked list
    list_node_t *current = head;

    hash_table_t *dir_map = hash_table_init();


    directory_t *root_dir = make_directory("");


    hash_table_add(dir_map, "", root_dir);

    while (current != NULL) {
        char *file_path = current->value;
        index_entry_t *idx_entry = hash_table_get(index_table, file_path);
        
        char *str = strdup(file_path);
        add_to_directory_map(idx_entry, dir_map);

        current = current->next;
        free(str);
    }

    directory_traversal(root_dir, dir_map, index_file->entries, tree_map);

    char *final_hash = hash_table_get(tree_map, "");


    free_hash_table(dir_map, (free_func_t) free_directory);

    free_index_file(index_file);
    // free_hash_table(dir_tree_map, free_tree);
    return final_hash;

}

commit_t *get_head_commit(bool *detached){
    char *head = read_head_file(detached);

    if (!*detached){
        printf("not detached brodie\n");
    }
    char *hash = malloc(sizeof(char) * (HASH_STRING_LENGTH + 1));
    head_to_hash(head, *detached, hash);

    commit_t *head_commit = read_commit(hash);
    free(hash);
    free(head);
    return head_commit;
}




char* get_unix_timestamp_and_timezone() {
    time_t current_time = time(NULL);
    struct tm* local_time_info = localtime(&current_time);

    // Calculate the timezone offset in hours and minutes
    int timezone_offset_hours = local_time_info->tm_gmtoff / 3600;
    int timezone_offset_minutes = labs((local_time_info->tm_gmtoff % 3600) / 60);

    char* timestamp_and_timezone_str = malloc(30);  // Large enough to hold the timestamp and timezone
    if (timestamp_and_timezone_str == NULL) {
        fprintf(stderr, "Failed to allocate memory for timestamp_and_timezone_str\n");
        exit(1);
    }
    sprintf(timestamp_and_timezone_str, "%ld %+03d%02d", (long)current_time, timezone_offset_hours, timezone_offset_minutes);
    return timestamp_and_timezone_str;
}


char* create_commit_message(const char* tree_hash, const char* commit_message, char **parent_hashes) {
    // Calculate the size of the commit message
    config_t *config = read_global_config();

    config_section_t *config_section = get_section(config, "user");

            
    char * author_email = NULL; //= config_section->properties[0].value;
    char * author_name = NULL; //= config_section->properties[1].value;

    for (size_t i=0; i < config_section->property_count; i++){
        config_property_t property =  config_section->properties[i];
        printf(" %s \n", config_section->properties[i].value);
        if (strcmp(property.key, "email") == 0){
            author_email = config_section->properties[i].value;
            printf("author email: %s\n", author_email);
        }
        if (strcmp(property.key, "name") == 0){
            author_name = config_section->properties[i].value;
            printf("author name: %s\n", author_name);
        }
    }

    if (author_email == NULL || author_name == NULL){
        printf("Author or email is not set in config file");
        exit(1);
    }
    
    
    size_t count = 0;
    size_t parent_len = 0;
    for (size_t i =0 ; parent_hashes[i] != NULL; i++){  
        // printf("parent_hash %s\n", parent_hashes[i]); 
        parent_len += strlen(parent_hashes[i]);
        count++;
    }
    
    char* author_date_unix = get_unix_timestamp_and_timezone();
    char* committer_date_unix = get_unix_timestamp_and_timezone();

    // printf("author date unix %s\n", author_date_unix);

    size_t message_size = strlen("tree \n\nauthor <>  \ncommitter <>  \n\n\n") +
                      strlen(tree_hash) + parent_len + count *strlen("parent ") + 
                      strlen(commit_message) + 
                      2 * (strlen(author_name) + strlen(author_email) + strlen(author_date_unix) + 20);

    char *commit_message_str = malloc(sizeof(char) * message_size);
    if (commit_message_str == NULL) {
        fprintf(stderr, "Failed to allocate memory for commit_message_str\n");
        exit(1);
    }

    strcpy(commit_message_str, "tree ");
    strcat(commit_message_str, tree_hash);
    strcat(commit_message_str, "\n");

    for (size_t i = 0; parent_hashes[i] != NULL; i++) {
        strcat(commit_message_str, "parent ");
        strcat(commit_message_str, parent_hashes[i]);
        strcat(commit_message_str, "\n");
    }

    strcat(commit_message_str, "author ");
    strcat(commit_message_str, author_name);
    strcat(commit_message_str, " <");
    strcat(commit_message_str, author_email);
    strcat(commit_message_str, "> ");
    strcat(commit_message_str, author_date_unix);
    strcat(commit_message_str, "\n");

    strcat(commit_message_str, "committer ");
    strcat(commit_message_str, author_name);
    strcat(commit_message_str, " <");
    strcat(commit_message_str, author_email);
    strcat(commit_message_str, "> ");
    strcat(commit_message_str, committer_date_unix);
    strcat(commit_message_str, "\n\n");

    strcat(commit_message_str, commit_message);
    strcat(commit_message_str, "\n");

    free(author_date_unix);
    free(committer_date_unix);

    // printf("commit message:\n\n\n%s\n", commit_message_str);
    free_config(config);

    return commit_message_str;
}

void commit(const char *commit_message) {
    
    // index_file_t *read_index_file();
    hash_table_t *tree_map = hash_table_init();

    char *tree_hash = make_tree_from_idx(tree_map);
    // printf("tree hash %s\n", tree_hash);
    bool detached;    
    char *head = read_head_file(&detached);


    char *commit_hash = malloc(sizeof(char) * (HASH_STRING_LENGTH + 1));
    bool found = head_to_hash(head, detached, commit_hash);
    if (!found){
        free(commit_hash);
        commit_hash = NULL;
    }

    // make multiple parent hashes
    char **parent_hashes = malloc(sizeof(char *) * 2);
    parent_hashes[0] = commit_hash;
    parent_hashes[1] = NULL;

    char * msg = create_commit_message(tree_hash, commit_message, parent_hashes);
    printf("commit message:\n%s\n", msg);
    object_hash_t hash; 
    write_object(COMMIT, msg, strlen(msg), hash);


    printf("commit hash %s\n", hash);
    free_hash_table(tree_map, free);
    free(msg);
    if (commit_hash != NULL){
        free(commit_hash);
    }
    if (detached){
        write_head_file(hash, detached);
    } else {
        set_branch_ref(head, hash);
    }
    free(head);
    free(parent_hashes);
}

filename: config_io.c

contents: 
 #include "config_io.h"
#include <assert.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "linked_list.h"
#include "util.h"

const char CONFIG_PATH[] = ".git/config";
const char GLOBAL_CONFIG_PATH1[] = "/.gitconfig";
const char GLOBAL_CONFIG_PATH2[] = "/.config/git/config";
const char COMMENT_START = '#';
const char SECTION_START = '[',
           SECTION_END = ']';
const char PROPERTY_START = '\t';
const char PROPERTY_SEPARATOR[] = " = ";
const char BRANCH_SECTION_PREFIX[] = "branch \"";
const char REMOTE_SECTION_PREFIX[] = "remote \"";
const char SECTION_SUFFIX[] = "\"";
const char MERGE_KEY[] = "merge";
const char REMOTE_KEY[] = "remote";
const char URL_KEY[] = "url";

FILE *open_config_file(char *mode) {
    FILE *file = fopen(CONFIG_PATH, mode);
    if (file == NULL) {
        fprintf(stderr, "Failed to open config file\n");
        assert(false);
    }
    return file;
}

static char *skip_whitespace(char* line) {
    while (*line && isspace(*line)) line++;
    return line;
}

char *read_config_line(FILE *file) {
    while (true) {
        char *line = NULL;
        size_t line_capacity = 0;
        ssize_t line_length = getline(&line, &line_capacity, file);
        if (line_length <= 0) {
            assert(feof(file));
            free(line);
            return NULL;
        } else if (line_length < 1) {
            // empty line
            free(line);
            continue;
        }

        assert(line[line_length - 1] == '\n');
        line[line_length - 1] = '\0';
        // Exclude any part of the line after a comment character
        char *comment_start = strchr(line, COMMENT_START);
        if (comment_start == NULL) return line;
        if (comment_start > line) {
            *comment_start = '\0';
            return line;
        }

        // If the entire line is a comment, skip it
        free(line);
    }
}

config_t *read_config_file(FILE *file) {
    size_t section_count = 0;
    linked_list_t *sections = init_linked_list();

    char *section_line = read_config_line(file);
    while (section_line != NULL) {
        assert(section_line[0] == SECTION_START);
        char *name_start = section_line + 1;
        char *name_end = strchr(name_start, SECTION_END);
        assert(name_end != NULL);
        assert(name_end[1] == '\0');
        section_count++;
        config_section_t *section = malloc(sizeof(*section));
        assert(section != NULL);
        size_t name_length = name_end - name_start;
        section->name = malloc(sizeof(char[name_length + 1]));
        assert(section->name != NULL);
        memcpy(section->name, name_start, sizeof(char[name_length]));
        section->name[name_length] = '\0';
        free(section_line);

        section->property_count = 0;
        linked_list_t *properties = init_linked_list();
        char *property_line;
        while (
            (property_line = read_config_line(file)) != NULL &&
            property_line[0] != SECTION_START
        ) {
            char *key_start = skip_whitespace(property_line);
            char *key_end = strstr(key_start, PROPERTY_SEPARATOR);
            assert(key_end != NULL);
            section->property_count++;
            config_property_t *property = malloc(sizeof(*property));
            assert(property != NULL);
            size_t key_length = key_end - key_start;
            property->key = malloc(sizeof(char[key_length + 1]));
            assert(property->key != NULL);
            memcpy(property->key, key_start, sizeof(char[key_length]));
            property->key[key_length] = '\0';
            property->value = strdup(key_end + strlen(PROPERTY_SEPARATOR));
            assert(property->value != NULL);
            list_push_back(properties, property);
            free(property_line);
        }

        section->properties = malloc(sizeof(config_property_t[section->property_count]));
        assert(section->properties != NULL);
        list_node_t *property = list_head(properties);
        for (size_t i = 0; i < section->property_count; i++) {
            section->properties[i] = *(config_property_t *) node_value(property);
            property = node_next(property);
        }
        free_linked_list(properties, free);
        list_push_back(sections, section);
        section_line = property_line;
    }
    fclose(file);

    config_t *config =
        malloc(sizeof(*config) + sizeof(config_section_t[section_count]));
    assert(config != NULL);
    config->section_count = section_count;
    list_node_t *section = list_head(sections);
    for (size_t i = 0; i < config->section_count; i++) {
        config->sections[i] = *(config_section_t *) node_value(section);
        section = node_next(section);
    }
    free_linked_list(sections, free);
    return config;
}

config_t *read_config(void) {
    return read_config_file(open_config_file("r"));
}

config_t *read_global_config(void) {
    char *home_directory = getenv("HOME");
    assert(home_directory != NULL);
    char config_path1[strlen(home_directory) + strlen(GLOBAL_CONFIG_PATH1) + 1];
    strcpy(config_path1, home_directory);
    strcat(config_path1, GLOBAL_CONFIG_PATH1);
    FILE *file = fopen(config_path1, "r");
    if (!file) {
        char config_path2[strlen(home_directory) + strlen(GLOBAL_CONFIG_PATH2) + 1];
        strcpy(config_path1, home_directory);
        strcat(config_path2, GLOBAL_CONFIG_PATH2);
        file = fopen(config_path2, "r");
        if (!file) {
            fprintf(stderr, "Failed to open global config file\n");
            exit(1);
        }
    }
    return read_config_file(file);
}

void write_config(const config_t *config) {
    FILE *file = open_config_file("w");
    for (size_t i = 0; i < config->section_count; i++) {
        const config_section_t *section = config->sections + i;
        int result = fputc(SECTION_START, file);
        assert(result != EOF);
        result = fputs(section->name, file);
        assert(result != EOF);
        result = fputc(SECTION_END, file);
        assert(result != EOF);
        result = fputc('\n', file);
        assert(result != EOF);
        for (size_t j = 0; j < section->property_count; j++) {
            config_property_t *property = section->properties + j;
            int result = fputc(PROPERTY_START, file);
            assert(result != EOF);
            result = fputs(property->key, file);
            assert(result != EOF);
            result = fputs(PROPERTY_SEPARATOR, file);
            assert(result != EOF);
            result = fputs(property->value, file);
            assert(result != EOF);
            result = fputc('\n', file);
            assert(result != EOF);
        }
    }
    fclose(file);
}

void free_config(config_t *config) {
    for (size_t i = 0; i < config->section_count; i++) {
        config_section_t *section = config->sections + i;
        free(section->name);
        for (size_t j = 0; j < section->property_count; j++) {
            config_property_t *property = section->properties + j;
            free(property->key);
            free(property->value);
        }
        free(section->properties);
    }
    free(config);
}

config_section_t *get_section(const config_t *config, const char *name) {
    for (size_t i = 0; i < config->section_count; i++) {
        config_section_t *section = (config_section_t *) config->sections + i;
        if (strcmp(section->name, name) == 0) return section;
    }
    return NULL;
}

char *get_branch_section_name(const char *branch_name) {
    char *section_name = malloc(sizeof(char[
        strlen(BRANCH_SECTION_PREFIX) +
        strlen(branch_name) +
        strlen(SECTION_SUFFIX) +
        1
    ]));
    assert(section_name != NULL);
    strcpy(section_name, BRANCH_SECTION_PREFIX);
    strcat(section_name, branch_name);
    strcat(section_name, SECTION_SUFFIX);
    return section_name;
}

config_section_t *get_branch_section(const config_t *config, const char *branch_name) {
    char *section_name = get_branch_section_name(branch_name);
    config_section_t *section = get_section(config, section_name);
    free(section_name);
    return section;
}

config_section_t *get_remote_section(const config_t *config, const char *remote_name) {
    char section_name[
        strlen(REMOTE_SECTION_PREFIX) +
        strlen(remote_name) +
        strlen(SECTION_SUFFIX) +
        1
    ];
    strcpy(section_name, REMOTE_SECTION_PREFIX);
    strcat(section_name, remote_name);
    strcat(section_name, SECTION_SUFFIX);
    return get_section(config, section_name);
}

bool is_branch_section(const config_section_t *section) {
    return starts_with(section->name, BRANCH_SECTION_PREFIX);
}

bool is_remote_section(const config_section_t *section) {
    return starts_with(section->name, REMOTE_SECTION_PREFIX);
}

char *copy_until_quote(char *start) {
    char *end = strstr(start, SECTION_SUFFIX);
    assert(end != NULL);
    size_t length = end - start;
    char *result = malloc(sizeof(char[length + 1]));
    assert(result != NULL);
    memcpy(result, start, sizeof(char[length]));
    result[length] = '\0';
    return result;
}

char *get_branch_name(const config_section_t *branch) {
    assert(is_branch_section(branch));
    return copy_until_quote(branch->name + strlen(BRANCH_SECTION_PREFIX));
}

char *get_remote_name(const config_section_t *remote) {
    assert(starts_with(remote->name, REMOTE_SECTION_PREFIX));
    return copy_until_quote(remote->name + strlen(REMOTE_SECTION_PREFIX));
}

char *get_property_value(const config_section_t *section, const char *key) {
    for (size_t i = 0; i < section->property_count; i++) {
        config_property_t *property = section->properties + i;
        if (strcmp(property->key, key) == 0) return property->value;
    }
    return NULL;
}

void set_property_value(
    const config_section_t *section,
    const char *key,
    const char *value
) {
    for (size_t i = 0; i < section->property_count; i++) {
        config_property_t *property = section->properties + i;
        if (strcmp(property->key, key) == 0) {
            free(property->value);
            property->value = (char *) value;
            return;
        }
    }
    fprintf(stderr, "No such property: %s\n", key);
    assert(false);
}

filename: fetch.c

contents: 
 #include "fetch.h"
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "config_io.h"
#include "hash_table.h"
#include "object_io.h"
#include "ref_io.h"
#include "transport.h"
#include "util.h"



void ermm(char *ref, object_hash_t hash, void *aux){
    printf("ref: %s\n", ref);
    printf("hash: %s\n", hash);

    hash_table_t *table = (hash_table_t *)aux;
    hash_table_add(table, ref, hash);
}

char ** go_through_local_commits(object_hash_t hash, char * hash_fetched){
    char ** hashes_to_fetch = NULL;
    size_t hashes_cnt = 0;
    printf("hash fetched: %s\n", hash);
    commit_t *commit = read_commit(hash);
    while (commit != NULL){
        object_hash_t *parent_hashes = commit->parent_hashes;
        for (size_t i = 0; i < commit->parents; i++) {
            // hash was found in commit history
            hashes_to_fetch = realloc(hashes_to_fetch, hashes_cnt + 1);
            if (strcmp(parent_hashes[i], hash_fetched) == 0){
                return false;
            }
            hashes_to_fetch[hashes_cnt] = strdup(parent_hashes[i]);
            hashes_cnt++;
        }    

        if (commit->parents > 0){
            memcpy(hash, &(commit->parent_hashes[0]), sizeof(object_hash_t));
            free_commit(commit);
            commit = read_commit(hash);
        } else {
            free_commit(commit);
            commit = NULL;
        }
    }
    return hashes_to_fetch;
}

void fetch_remote(const char *remote_name, config_section_t *remote) {
    char *url = get_url(remote);
    printf("url: %s\n", url);

    transport_t * transport = open_transport(FETCH, url);
    hash_table_t *ref_to_hash = hash_table_init(); 
    receive_refs(transport, ermm, ref_to_hash);
    
    list_node_t *ref_node = key_set(ref_to_hash);
    printf("remote name: %s\n", remote_name);


    while (ref_node != NULL){
        char *ref = ref_node->value;
        printf("ref name: %s\n", ref);

        // object_hash_t hash;
        char * hash_fetched = hash_table_get(ref_to_hash, ref);

        object_hash_t hash; 

        bool remote_ref = get_remote_ref(remote_name, ref, hash);
        if (!remote_ref){
            printf("Remote Ref : '%s' not found\n", remote_name);
            exit(1);
        }

        // char **local_commits = go_through_local_commits(hash, hash_fetched);

        // for (size_t i=0; local_commits[i] != NULL; i++){
        //     printf("local commit hash: %s", local_commits[i]);
        // }

        ref_node = ref_node->next;
    }


    finish_wants(transport);

    close_transport(transport);
    
    free(url);
    // exit(1);
}

void fetch(const char *remote_name) {
    config_t *config = read_config();
    config_section_t *remote = get_remote_section(config, remote_name);
    if (remote == NULL) {
        fprintf(stderr, "No such remote: %s\n", remote_name);
        exit(1);
    }

    fetch_remote(remote_name, remote);
    free_config(config);
}

void fetch_all(void) {
    config_t *config = read_config();
    for (size_t i = 0; i < config->section_count; i++) {
        config_section_t *section = &config->sections[i];
        if (is_remote_section(section)) {
            char *remote_name = get_remote_name(section);
            // printf("remote name: %s", remote_name);
            fetch_remote(remote_name, section);
            free(remote_name);
        }
    }
    free_config(config);
}
yï¿½
filename: hash_table.c

contents: 
 #include <string.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include "hash_table.h"

// prime
const size_t BUCKETS = 7919;

// Entries in a hash table's linked list.
struct key_value {
    char *key;
    void *value;
};

struct hash_table {
    linked_list_t *entries[BUCKETS];

    // Number of keys. Handy to keep track of this as it needs to be written
    // into index file metadata.
    size_t size;

    // Maintain the key set so we can iterate over the hash table
    // TODO: point to key_value_t
    linked_list_t *key_set;
};

// Simple hash function
// h(s) = sum s_i * 31^i
size_t hash_func(const char *key) {
    size_t hash = 0;
    while (*key) hash = hash * 31 + *(key++);
    return hash;
}

// key + value pair functions

key_value_t *key_value_init(const char *key, void *value) {
    key_value_t *pair = malloc(sizeof(*pair));
    assert(pair != NULL);
    pair->key = strdup(key);
    assert(pair->key != NULL);
    pair->value = value;
    return pair;
}

void free_key_value(key_value_t *pair, free_func_t freer) {
    free(pair->key);
    if (freer) freer(pair->value);
    free(pair);
}

bool key_equals(const key_value_t *pair, const char *key) {
    return strcmp(pair->key, key) == 0;
}

char *key_of(const key_value_t *pair) {
    return pair->key;
}

void *value_of(const key_value_t *pair) {
    return pair->value;
}

// Hash table functions

hash_table_t *hash_table_init(void) {
    hash_table_t *table = calloc(1, sizeof(*table));
    assert(table != NULL);
    table->key_set = init_linked_list();
    return table;
}
void free_hash_table(hash_table_t *table, free_func_t freer) {
    for (size_t i = 0; i < BUCKETS; i++) {
        linked_list_t *list = table->entries[i];
        if (list != NULL) {
            // Annoying. Ideally, we would just call free_linked_list and pass
            // free_key_value. However, free_key_value is not the correct type;
            // it ALSO needs to be passed a freer for the (void *) value.
            for (list_node_t *it = list_head(list), *next; it != NULL; it = next) {
                free_key_value(node_value(it), freer);
                next = node_next(it);
                free(it);
            }
            free(list);
        }
    }
    free_linked_list(table->key_set, NULL);
    free(table);
}

void *hash_table_add(hash_table_t *table, const char *key, void *value) {
    linked_list_t **list = &table->entries[hash_func(key) % BUCKETS];
    if (*list == NULL) *list = init_linked_list();

    // If entry with passed key exists, modify its value.
    for (list_node_t *it = list_head(*list); it != NULL; it = node_next(it)) {
        key_value_t *pair = node_value(it);
        if (key_equals(pair, key)) {
            void *old_value = pair->value;
            pair->value = value;
            return old_value;
        }
    }

    // New entry if we make it here
    key_value_t *entry = key_value_init(key, value);
    list_push_back(*list, entry);
    list_push_back(table->key_set, entry->key);
    table->size++;
    return NULL;
}
void *hash_table_get(const hash_table_t *table, const char *key) {
    linked_list_t *list = table->entries[hash_func(key) % BUCKETS];
    if (list == NULL) return NULL;

    for (list_node_t *it = list_head(list); it != NULL; it = node_next(it)) {
        key_value_t *pair = node_value(it);
        if (key_equals(pair, key)) return value_of(pair);
    }
    return NULL;
}
bool hash_table_contains(const hash_table_t *table, const char *key) {
    return hash_table_get(table, key) != NULL;
}
size_t hash_table_size(const hash_table_t *table) {
    return table->size;
}
void hash_table_sort(hash_table_t *table) {
    list_sort(table->key_set, (compare_func_t) strcmp);
}

list_node_t *key_set(const hash_table_t *table) {
    return list_head(table->key_set);
}

filename: hmmmm

contents: 
 100755 aaa.txt
filename: aaa.txt

contents: 
 ï¿½ï¿½ï¿½>
filename: bb.txt

contents: 
 ï¿½ï¿½ï¿½>
filename: bruhhhh

contents: 
 100755 hm.txt
filename: hm.txt

contents: 
 ï¿½ï¿½ï¿½>
filename: noooo

contents: 
 100755 ccc.txt
filename: ccc.txt

contents: 
 ï¿½ï¿½ï¿½>
filename: index_io.c

contents: 
 /*
 * The index file is used as a staging area.
 * Reading from the index file is necessary during a checkout; if
 * a checkout would overwrite a staged change, the checkout should
 * fail. Additionally, the index file has to be overwritten after
 * the checkout.
 */

#include "index_io.h"
#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "util.h"
#include "object_io.h"
#include "linked_list.h"

/* Expected file signature for index files */
const char DIRC_SIG[4] = {'D', 'I', 'R', 'C'};

const char *INDEX_PATH = ".git/index"; //"temp_idx_file"; //   

/*
 * Read a big-endian bytestream
 * (can't just fread() on a little endian system)
 */
uint32_t read32(FILE *f) {
    uint8_t bytes[4];
    fread(bytes, 1, 4, f);
    return read_be(bytes, 4);
}

/*
 * Write in big-endian order
 */
void write32(FILE *f, uint32_t n) {
    uint8_t bytes[4];
    write_be(n, bytes, 4);
    fwrite(bytes, 1, 4, f);
}

index_entry_t *read_index_entry(FILE *f, uint32_t version) {
    index_entry_t *entry = (index_entry_t *) malloc(sizeof(index_entry_t));
    /* Skip over metadata that I don't need */
    fseek(f, 8, SEEK_CUR);
    entry->mtime = read32(f);
    // printf("entry->mtime %u\n", entry->mtime);

    fseek(f, 12, SEEK_CUR);
    entry->mode = read32(f);
    // printf("mode: %u\n", entry->mode);
    
    fseek(f, 8, SEEK_CUR);

    entry->size = read32(f);

    // printf("sizesss %u\n", entry->size);


    uint8_t sha1[HASH_BYTES];
    fread(sha1, 1, HASH_BYTES, f);
    hash_to_hex(sha1, entry->sha1);

    // printf("hash %s\n", entry->sha1);


    char flags[2];
    fread(flags, 1, 2, f);

    int fname_length = ((flags[0] & 0x0F) << 9) + flags[1];
    entry->fname_length = fname_length;


    bool extended_flag = flags[0] & 0x40;
    if (version == 2 && extended_flag) {
        fprintf(stderr, "fatal: version 2 must have extended_flag = 0\n");
        exit(1);
    }

    int n_read = 62;

    entry->fname = (char *) malloc(fname_length + 1);

    fread(entry->fname, 1, fname_length + 1, f);

    n_read += fname_length + 1;

    // printf("file:%s\n", entry->fname);
    // printf("size:%u\n", entry->size);
    // printf("sha1:%s\n", entry->sha1);
    // printf("mtime:%ld\n", entry->mtime);
    // printf("stage:%d\n", (flags[0] & 0xC0) >> 6);
    // printf("\n");

    /* Pad such that n_read % 8 = 0 */
    int pad = 8 - (n_read % 8);
    if (pad != 8)
        fseek(f, pad, SEEK_CUR);

    // printf("padding length: %d\n", pad);

    return entry;
}

index_file_t *empty_index_file(void) {
    index_file_t *index = malloc(sizeof(*index));
    assert(index != NULL);
    index->entries = hash_table_init();
    return index;
}

index_file_t *read_index_file() {

    index_file_t *idx = empty_index_file();
    FILE *f = fopen(INDEX_PATH, "r");
    if (!f) return idx; // index may not exist if it has no entries

    // First 4 bytes are file signature
    char sig[4];
    fread(sig, 1, 4, f);
    if (memcmp(sig, DIRC_SIG, 4) != 0) {
        fprintf(stderr, "fatal: unexpected file signature\n");
        exit(1);
    }

    uint32_t version = read32(f);
    // Only support version 2
    if (version != 2) {
        fprintf(stderr, "fatal: invalid version; got %u but must be 2\n",
                version);
        exit(1);
    }
    // printf("version: %u\n", version);

    size_t n_entries = read32(f);
    // printf("n_entries: %lu\n", n_entries);
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));
    // free_index_entry(read_index_entry(f, version));

    for (unsigned int i = 0; i < n_entries; i++) {
        index_entry_t *entry = read_index_entry(f, version);
        // printf("fname: %s\n", entry->fname);
        hash_table_add(idx->entries, entry->fname, entry);
        // if (i == 2){
        //     break;
        // }
    }

    fclose(f);
    return idx;
}

void free_index_entry(index_entry_t *entry) {
    if (entry == NULL){
        return;
    }
    free(entry->fname);
    free(entry);
}
void free_index_file(index_file_t *idx) {
    free_hash_table(idx->entries, (free_func_t) free_index_entry);
    free(idx);
}

filename: linked_list.c

contents: 
 // Simple linked list implementation; only includes operations that I need
#include <assert.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#include "linked_list.h"

struct list_node {
   list_node_t *next;
   void *value;
};
struct linked_list {
    list_node_t *head;
    list_node_t **tail;
};

linked_list_t *init_linked_list() {
    linked_list_t *list = malloc(sizeof(*list));
    assert(list != NULL);
    list->head = NULL;
    list->tail = &list->head;
    return list;
}

void free_linked_list(linked_list_t *list, free_func_t freer) {
    for (list_node_t *node = list_head(list), *next; node != NULL; node = next) {
        if (freer != NULL) freer(node_value(node));
        next = node_next(node);
        free(node);
    }
    free(list);
}

void *list_pop_front(linked_list_t *list) {
    list_node_t *head = list->head;
    if (head == NULL) return NULL;

    void *value = head->value;
    list->head = head->next;
    if (list->tail == &head->next) list->tail = &list->head;
    free(head);
    return value;
}

void list_push_back(linked_list_t *list, void *value) {
    list_node_t *node = malloc(sizeof(*node));
    assert(node != NULL);
    node->value = value;
    node->next = NULL;

    *list->tail = node;
    list->tail = &node->next;
}

linked_list_t split(list_node_t *list) {
    linked_list_t other_list = {.tail = &other_list.head};
    while (list != NULL) {
        // Add the next element to the other list, if it exists.
        // If there are an odd number of nodes, `list` will have 1 more than `other_list`.
        list_node_t *other_next = list->next;
        if (other_next == NULL) break;

        // Remove `other_next` from `list`
        list->next = other_next->next;
        list = list->next;
        // Append `other_next` to `other_list`
        *other_list.tail = other_next;
        other_list.tail = &other_next->next;
    }
    *other_list.tail = NULL;
    return other_list;
}

void list_sort(linked_list_t *list, compare_func_t cmp) {
    linked_list_t other_list = split(list->head);
    if (other_list.head == NULL) return; // 1-element list needs no sorting

    // Recursively sort each half of the list
    list_sort(list, cmp);
    list_sort(&other_list, cmp);

    // Merge `list` and `other_list` into `list`
    list_node_t *list_next = list->head;
    list_node_t *other_next = other_list.head;
    list->tail = &list->head;
    while (true) {
        // Decide which element to append to the list.
        // If either sublist is empty, add from the other. If both are empty, we are done.
        // Otherwise, compare the values and take the smaller one.
        list_node_t **next;
        if (list_next == NULL) {
            if (other_next == NULL) break;

            next = &other_next;
        }
        else {
            next = other_next == NULL
                ? &list_next
                : cmp(list_next->value, other_next->value) < 0 ? &list_next : &other_next;
        }

        // Append the element to the list and remove it from its sublist
        *list->tail = *next;
        list->tail = &(*next)->next;
        *next = (*next)->next;
    }
    *list->tail = NULL;
}

list_node_t *list_head(const linked_list_t *list) {
    if (list == NULL) return NULL;
    return list->head;
}
list_node_t *node_next(const list_node_t *node) {
    return node->next;
}
void *node_value(const list_node_t *node) {
    return node->value;
}

filename: log.c

contents: 
 #include "log.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "object_io.h"
#include "ref_io.h"

#include <stdio.h>
#include "commit.h"
#include "util.h"

#include "config_io.h"


void print_commit(object_hash_t hash) {
    commit_t *commit = read_commit(hash);

    while (commit != NULL){
        object_hash_t *parent_hashes = commit->parent_hashes;
        printf("commit %s\n", hash);
        
        if (commit->parents > 1) {
            printf("Merge: ");
            for (size_t i = 0; i < commit->parents-1; i++) {
                printf("%s ", parent_hashes[i]);
            }
            printf("%s", parent_hashes[commit->parents-1]);
            printf("\n");
        }
        printf("Author: %s\n", commit->author);

        // Convert the time_t object to a struct tm object
        struct tm *timeinfo = localtime(&(commit->author_time));

        char buff[80];
        // Format the date
        strftime(buff, 80, "%a %b %d %H:%M:%S %Y %z", timeinfo);
        printf("Date: %s\n\n", buff);

        printf("%s\n\n", commit->message);
        
        if (commit->parents > 0){

            memcpy(hash, &(commit->parent_hashes[0]), sizeof(object_hash_t));
            free_commit(commit);

            commit = read_commit(hash);
        } else {
            free_commit(commit);
            commit = NULL;
        }
    }
}

void mygit_log(const char *ref) {

    if (ref == NULL){
        bool detached;
        char *head = read_head_file(&detached);

        object_hash_t hash;
        bool found = head_to_hash(head, detached, hash);
        if (!found){
            printf("No commits");
            exit(1);
        }
        print_commit(hash);
    } else {
        object_hash_t hash;
        bool found = get_branch_ref(ref, hash);

        if (found){
            print_commit(hash);
            return;
        }
        // printf("hash!!! %s\n", ref);

        if (is_valid_commit_hash(ref)) {
            // If name_or_hash is a valid commit hash, checkout to that commit
            print_commit((char *) ref);
            return;
        } else {
            printf("fatal: bad object %s", ref);
        }
    }
}

filename: main.c

contents: 
 #include <stdio.h>
#include <string.h>
#include <stdlib.h>
char **split_path_into_directories(char *path) {
    // Count the number of directories in the path
    int count = 0;
    for (int i = 0; path[i]; i++) {
        if (path[i] == '/') {
            count++;
        }
    }

    // Allocate memory for the array of directory names
    char **directories = malloc((count + 2) * sizeof(char *));
    if (directories == NULL) {
        fprintf(stderr, "Failed to allocate memory.\n");
        return NULL;
    }

    // Split the path into directory names
    int index = 0;
    char *token = strtok(path, "/");
    while (token != NULL) {
        directories[index] = token;
        token = strtok(NULL, "/");
        index++;
    }
    directories[index] = NULL;  // Null-terminate the array

    return directories;
}

int main() {
    char path[] = "/home/user/documents/file.txt";
    char **directories = split_path_into_directories(path);

    // Print the directory names
    for (int i = 0; directories[i] != NULL; i++) {
        printf("%s\n", directories[i]);
    }

    // Free the array of directory names
    free(directories);

    return 0;
}
filename: main.exe

contents: 
 MZï¿½
filename: mygit.c

contents: 
 #include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>

#include "add.h"
#include "commit.h"
#include "checkout.h"
#include "fetch.h"
#include "log.h"
#include "push.h"
#include "status.h"

typedef enum {
    ADD,
    CHECKOUT,
    COMMIT,
    FETCH,
    HELP,
    LOG,
    PUSH,
    STATUS,
    INVALID_SUBCOMMAND
} subcommand_t;

const char GIT_DIR[] = "/.git";
const char ADD_CMD[] = "add";
const char CHECKOUT_CMD[] = "checkout";
const char COMMIT_CMD[] = "commit";
const char FETCH_CMD[] = "fetch";
const char HELP_CMD[] = "help";
const char LOG_CMD[] = "log";
const char PUSH_CMD[] = "push";
const char STATUS_CMD[] = "status";

const char USAGE_STRING[] = "Usage:\n"
    "\tmygit add ...\n"
    "\tmygit checkout ...\n"
    "\tmygit commit ...\n"
    "\tmygit fetch ...\n"
    "\tmygit help [COMMAND]\n"
    "\tmygit log ...\n"
    "\tmygit push ...\n";
const char ADD_USAGE_STRING[] = "Usage:\n"
    "\tmygit add [FILES ...]\n\n"
    "\tStages files for commit\n"
    "\tFILES: files or directories to stage for commit\n";
const char CHECKOUT_USAGE_STRING[] = "Usage:\n"
    "\tmygit checkout [-b] REF\n\n"
    "\tChecks out the files at a given commit\n"
    "\tREF: either a commit hash or a branch name\n"
    "\t-b: create a new branch\n";
const char COMMIT_USAGE_STRING[] = "Usage:\n"
    "\tmygit commit -m MESSAGE\n\n"
    "\tMakes a commit to the current branch\n"
    "\tMESSAGE: the commit message\n";
const char FETCH_USAGE_STRING[] = "Usage:\n"
    "\tmygit fetch [REMOTES ...]\n\n"
    "\tFetches all branches from a set of git remotes\n"
    "\tREMOTES: the names of the remotes to fetch. If omitted, fetches all remotes.\n";
const char HELP_USAGE_STRING[] = "Usage:\n"
    "\tmygit help [COMMAND]\n\n"
    "\tPrints out usage information for mygit or a mygit subcommand\n"
    "\tCOMMAND: the mygit subcommand, e.g. 'commit'\n";
const char LOG_USAGE_STRING[] = "Usage:\n"
    "\tmygit log [REF]\n\n"
    "\tLogs the commit history up to a given commit\n"
    "\tREF: the commit hash or branch name whose history to log."
        " If omitted, logs the current commit.\n";
const char PUSH_USAGE_STRING[] = "Usage:\n"
    "\tmygit push [-u REMOTE] [BRANCHES ...]\n\n"
    "\tPushes branches to their corresponding remotes\n"
    "\t-u REMOTE: configures the branches to be pushed to the given remote\n"
    "\tBRANCHES: the branch names to push. If omitted, pushes all branches.\n";
const char STATUS_USAGE_STRING[] = "Usage:\n"
    "\tmygit status\n\n"
    "\tDisplays the state of the staging area\n";
const char *USAGE_STRINGS[] = {
    ADD_USAGE_STRING,
    CHECKOUT_USAGE_STRING,
    COMMIT_USAGE_STRING,
    FETCH_USAGE_STRING,
    HELP_USAGE_STRING,
    LOG_USAGE_STRING,
    PUSH_USAGE_STRING,
    STATUS_USAGE_STRING
};

subcommand_t get_subcommand(char *cmd) {
    if (strcmp(cmd, ADD_CMD) == 0) return ADD;
    if (strcmp(cmd, CHECKOUT_CMD) == 0) return CHECKOUT;
    if (strcmp(cmd, COMMIT_CMD) == 0) return COMMIT;
    if (strcmp(cmd, FETCH_CMD) == 0) return FETCH;
    if (strcmp(cmd, HELP_CMD) == 0) return HELP;
    if (strcmp(cmd, LOG_CMD) == 0) return LOG;
    if (strcmp(cmd, PUSH_CMD) == 0) return PUSH;
    if (strcmp(cmd, STATUS_CMD) == 0) return STATUS;
    return INVALID_SUBCOMMAND;
}

/*
 * scans up directory tree until a directory containing a .git
 * directory is encountered
 *
 * fatal error if no directory is found or can't cd
 */
void cd_to_git_dir(void) {
    char *cwd = getcwd(NULL, 0);
    assert(cwd != NULL);
    for (char *dir = cwd; *dir != '\0'; *strrchr(dir, '/') = '\0') {
        char git_dir[strlen(dir) + strlen(GIT_DIR) + 1];
        strcpy(git_dir, dir);
        strcat(git_dir, GIT_DIR);

        /* check if directory exists */
        struct stat sb;
        if (stat(git_dir, &sb) == 0 && S_ISDIR(sb.st_mode)) {
            int result = chdir(dir);
            assert(result == 0);
            free(cwd);
            return;
        }
    }
    free(cwd);

    fprintf(stderr, "fatal: no .git directory found\n");
    exit(1);
}

typedef void (*run_subcommand_t)(size_t argc, char *argv[]);

void run_add(size_t argc, char *argv[]) {
    cd_to_git_dir();
    add_files((const char **) argv, argc);
}

void run_checkout(size_t argc, char *argv[]) {
    bool make_branch = argc > 1;
    if (make_branch) {
        if (strcmp(argv[0], "-b") != 0) {
            fprintf(stderr, CHECKOUT_USAGE_STRING);
            exit(1);
        }
        argc--;
        argv++;
    }
    if (argc != 1) {
        fprintf(stderr, CHECKOUT_USAGE_STRING);
        exit(1);
    }

    cd_to_git_dir();
    checkout(argv[0], make_branch);
}

void run_commit(size_t argc, char *argv[]) {
    if (argc != 2 || strcmp(argv[0], "-m") != 0) {
        fprintf(stderr, COMMIT_USAGE_STRING);
        exit(1);
    }

    cd_to_git_dir();
    commit(argv[1]);
}

void run_fetch(size_t argc, char *argv[]) {
    cd_to_git_dir();
    if (argc == 0) fetch_all();
    else {
        for (size_t i = 0; i < argc; i++) fetch(argv[i]);
    }
}

void run_help(size_t argc, char *argv[]) {
    if (argc == 0) printf(USAGE_STRING);
    else if (argc == 1) {
        subcommand_t subcommand = get_subcommand(argv[0]);
        if (subcommand == INVALID_SUBCOMMAND) {
            fprintf(stderr, HELP_USAGE_STRING);
            exit(1);
        }

        printf("%s", USAGE_STRINGS[subcommand]);
    }
    else {
        fprintf(stderr, HELP_USAGE_STRING);
        exit(1);
    }
}

void run_log(size_t argc, char *argv[]) {
    if (argc > 1) {
        fprintf(stderr, LOG_USAGE_STRING);
        exit(1);
    }

    cd_to_git_dir();
    mygit_log(argc == 0 ? NULL : argv[0]);
}

void run_push(size_t argc, char *argv[]) {
    char *set_remote;
    if (argc > 0 && strcmp(argv[0], "-u") == 0) {
        if (argc <= 2) {
            // At least 1 branch must be specified
            fprintf(stderr, PUSH_USAGE_STRING);
            exit(1);
        }
        set_remote = argv[1];
        argc -= 2;
        argv += 2;
    }
    else set_remote = NULL;

    cd_to_git_dir();
    push(argc, argc == 0 ? NULL : (const char **) argv, set_remote);
}

void run_status(size_t argc, char *argv[]) {
    (void) argc;
    (void) argv;
    cd_to_git_dir();
    status();
}

run_subcommand_t RUN_SUBCOMMANDS[] = {
    run_add,
    run_checkout,
    run_commit,
    run_fetch,
    run_help,
    run_log,
    run_push,
    run_status
};

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, USAGE_STRING);
        return 1;
    }
    subcommand_t subcommand = get_subcommand(argv[1]);
    if (subcommand == INVALID_SUBCOMMAND) {
        fprintf(stderr, USAGE_STRING);
        return 1;
    }

    RUN_SUBCOMMANDS[subcommand](argc - 2, argv + 2);
}

filename: new file

contents: 
 ï¿½ï¿½ï¿½>
filename: object_io.c

contents: 
 #include "object_io.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <openssl/sha.h>
#define ZLIB_CONST
#include <zlib.h>
#include "util.h"

const char OBJECT_DIR[] = ".git/objects/";
const size_t HASH_DIRECTORY_LENGTH = 2;
const size_t HASH_FILE_LENGTH = HASH_STRING_LENGTH - HASH_DIRECTORY_LENGTH;

const char BLOB_TYPE[] = "blob";
const char COMMIT_TYPE[] = "commit";
const char TAG_TYPE[] = "tag";
const char TREE_TYPE[] = "tree";

// Object files start with "OBJECT_TYPE LENGTH\0".
// "commit" is the longest type and 20 base-10 digits for the length should be plenty.
const size_t MAX_OBJECT_HEADER_LENGTH = sizeof(COMMIT_TYPE) + 20 + 1;
const size_t MAX_TIME_STRING_LENGTH = 30; // e.g. "1590023943 -0700"
const size_t MAX_MODE_STRING_LENGTH = 6; // e.g. "100644"
const size_t INFLATE_CHUNK_SIZE = 64 << 10; // 64 KB
const size_t DEFLATE_CHUNK_SIZE = 128 << 10; // 128 KB

const char TREE_LINE[] = "tree ";
const char PARENT_LINE[] = "parent ";
const char AUTHOR_LINE[] = "author ";
const char COMMITTER_LINE[] = "committer ";

const size_t MAX_COPY_OFFSET_BYTES = 4;
const size_t MAX_COPY_SIZE_BYTES = 3;

FILE *open_object(const object_hash_t hash, const char *mode) {
    assert(strlen(hash) == HASH_STRING_LENGTH);
    char filename[strlen(OBJECT_DIR) + HASH_DIRECTORY_LENGTH + 1 + HASH_FILE_LENGTH + 1];
    strcpy(filename, OBJECT_DIR);
    strncat(filename, hash, HASH_DIRECTORY_LENGTH);
    if (mode[0] == 'w') mkdir(filename, 0755);
    strcat(filename, "/");
    strcat(filename, hash + HASH_DIRECTORY_LENGTH);
    return fopen(filename, mode);
}

void *read_object(const object_hash_t hash, object_type_t *type, size_t *length) {
    FILE *file = open_object(hash, "r");
    if (file == NULL) {
        fprintf(stderr, "Failed to open object: %s\n", hash);
        assert(false);
    }
    z_stream stream;
    memset(&stream, 0, sizeof(stream));
    int result = inflateInit(&stream);
    assert(result == Z_OK);

    // Read the object header (and likely some of the following bytes)
    char header[MAX_OBJECT_HEADER_LENGTH];
    stream.next_out = (void *) header;
    stream.avail_out = MAX_OBJECT_HEADER_LENGTH;
    uint8_t chunk[INFLATE_CHUNK_SIZE];
    while (stream.avail_out > 0) { // fill up the header
        stream.next_in = chunk;
        stream.avail_in = fread(chunk, 1, INFLATE_CHUNK_SIZE, file);
        if (stream.avail_in == 0 && feof(file)) break;

        result = inflate(&stream, Z_NO_FLUSH);
        assert(result == Z_OK || result == Z_STREAM_END);
    }
    // Ensure the header is null-terminated; otherwise we will cause buffer overflows
    if (memchr(header, '\0', stream.total_out) == NULL) {
        fprintf(stderr, "Object header not found\n");
        assert(false);
    }
    char *type_end = strchr(header, ' ');
    assert(type_end != NULL);
    *type_end = '\0';
    if (!strcmp(header, BLOB_TYPE)) *type = BLOB;
    else if (!strcmp(header, COMMIT_TYPE)) *type = COMMIT;
    else if (!strcmp(header, TREE_TYPE)) *type = TREE;
    else {
        fprintf(stderr, "Unrecognized object type: %s\n", header);
        assert(false);
    }
    *length = 0;
    char *length_digit = type_end + 1;
    while (*length_digit) {
        *length = 10 * *length + from_decimal(*length_digit);
        length_digit++;
    }
    uint8_t *inflated = malloc(*length);
    assert(inflated != NULL);
    // Copy the extra bytes read to the start of the inflated data
    uint8_t *data_start = (uint8_t *) (length_digit + 1);
    size_t extra_header_bytes = stream.next_out - data_start;
    memcpy(inflated, data_start, extra_header_bytes);
    stream.next_out = inflated + extra_header_bytes;
    stream.avail_out = *length - extra_header_bytes;
    while (result != Z_STREAM_END) {
        if (stream.avail_in == 0) {
            stream.next_in = chunk;
            stream.avail_in = fread(chunk, 1, INFLATE_CHUNK_SIZE, file);
        }
        result = inflate(&stream, Z_NO_FLUSH);
        assert(result == Z_OK || result == Z_STREAM_END);
    }
    assert(stream.avail_out == 0);

    result = inflateEnd(&stream);
    assert(result == Z_OK);
    fclose(file);
    return inflated;
}

void read_name_and_time(
    char **line,
    size_t *length,
    const char *type,
    char **name,
    time_t *time
) {
    size_t type_length = strlen(type);
    assert(*length > type_length && starts_with(*line, type));
    *line += type_length;
    *length -= type_length;
    char *email_end = memchr(*line, '>', *length);
    assert(email_end != NULL);
    size_t name_length = email_end + 1 - *line;
    *name = malloc(sizeof(char[name_length + 1]));
    assert(*name != NULL);
    memcpy(*name, *line, sizeof(char[name_length]));
    (*name)[name_length] = '\0';
    *line += name_length;
    *length -= name_length;
    assert(*length > 0 && **line == ' ');
    (*line)++;
    (*length)--;
    *time = 0;
    while (true) {
        assert(*length > 0);
        if (**line == ' ') break;

        *time = *time * 10 + from_decimal(**line);
        (*line)++;
        (*length)--;
    }
    char *line_end = memchr(*line, '\n', *length);
    assert(line_end != NULL);
    size_t timezone_length = line_end + 1 - *line;
    *line += timezone_length;
    *length -= timezone_length;
}

commit_t *read_commit(const object_hash_t hash) {
    object_type_t type;
    size_t length;
    char *data = read_object(hash, &type, &length);
    length /= sizeof(char);
    assert(type == COMMIT);
    commit_t *commit = malloc(sizeof(*commit));
    assert(commit != NULL);

    // Read tree line
    char *line = data;
    assert(length > strlen(TREE_LINE) && starts_with(line, TREE_LINE));
    line += strlen(TREE_LINE);
    length -= strlen(TREE_LINE);
    assert(length > HASH_STRING_LENGTH);
    memcpy(commit->tree_hash, line, sizeof(char[HASH_STRING_LENGTH]));
    commit->tree_hash[HASH_STRING_LENGTH] = '\0';
    line += HASH_STRING_LENGTH + 1;
    length -= HASH_STRING_LENGTH + 1;
    assert(line[-1] == '\n');

    // Read parents lines
    commit->parents = 0;
    char *parent_line = line;
    size_t parent_length = strlen(PARENT_LINE);
    while (length > parent_length && starts_with(line, PARENT_LINE)) {
        line += parent_length;
        length -= parent_length;
        commit->parents++;
        assert(length > HASH_STRING_LENGTH);
        line += HASH_STRING_LENGTH + 1;
        length -= HASH_STRING_LENGTH + 1;
        assert(line[-1] == '\n');
    }
    commit->parent_hashes = malloc(sizeof(object_hash_t[commit->parents+1]) );
    assert(commit->parent_hashes != NULL);
    for (size_t i = 0; i < commit->parents; i++) {
        parent_line += strlen(PARENT_LINE);
        memcpy(commit->parent_hashes[i], parent_line, sizeof(char[HASH_STRING_LENGTH]));
        commit->parent_hashes[i][HASH_STRING_LENGTH] = '\0';
        parent_line += HASH_STRING_LENGTH + 1;
    }
    assert(parent_line == line);

    // Read author and committer lines
    read_name_and_time(&line, &length, AUTHOR_LINE, &commit->author, &commit->author_time);
    read_name_and_time(&line, &length, COMMITTER_LINE, &commit->committer, &commit->commit_time);

    // The rest of the file is the commit message
    assert(length > 0 && *line == '\n');
    line++;
    length--;
    if (length > 0 && line[length - 1] == '\n') {
        length--; // trim the trailing newline if there is one
    }
    commit->message = malloc(sizeof(char[length + 1]));
    assert(commit->message != NULL);
    memcpy(commit->message, line, sizeof(char[length]));
    commit->message[length] = 0;

    free(data);
    return commit;
}

void get_time_string(time_t time, char time_string[MAX_TIME_STRING_LENGTH]) {
    // Format the author/committer time as epoch time + local timezone offset
    size_t printed = snprintf(time_string, MAX_TIME_STRING_LENGTH, "%ld ", time);
    assert(printed < MAX_TIME_STRING_LENGTH);
    struct tm local_time;
    localtime_r(&time, &local_time);
    size_t remaining_length = MAX_TIME_STRING_LENGTH - printed;
    size_t timezone_length =
        strftime(time_string + printed, remaining_length, "%z", &local_time);
    assert(timezone_length > 0);
}

void free_commit(commit_t *commit) {
    free(commit->parent_hashes);
    free(commit->author);
    free(commit->committer);
    free(commit->message);
    free(commit);
}

tree_t *read_tree(const object_hash_t hash) {
    object_type_t type;
    size_t length;
    uint8_t *data = read_object(hash, &type, &length);
    assert(type == TREE);

    // Count the number of entries
    size_t entries = 0;
    uint8_t *offset = data;
    while (length > 0) {
        while (true) {
            assert(length > 0);
            if (*offset == ' ') break;

            offset++;
            length--;
        }
        offset++;
        length--;
        while (true) {
            assert(length > 0);
            if (*offset == '\0') break;

            offset++;
            length--;
        }
        assert(length > HASH_BYTES);
        offset += 1 + HASH_BYTES;
        length -= 1 + HASH_BYTES;
        entries++;
    }

    tree_t *tree = malloc(sizeof(*tree));
    assert(tree != NULL);
    tree->entry_count = entries;
    tree->entries = malloc(sizeof(tree_entry_t[entries]));
    assert(tree->entries != NULL);
    offset = data;
    for (size_t i = 0; i < entries; i++) {
        tree->entries[i].mode = 0;
        while (*offset != ' ') {
            tree->entries[i].mode = tree->entries[i].mode << 3 | from_octal(*offset);
            offset++;
        }
        offset++;
        size_t name_size = sizeof(char[strlen((char *) offset) + 1]);
        tree->entries[i].name = malloc(name_size);
        assert(tree->entries[i].name != NULL);
        memcpy(tree->entries[i].name, offset, name_size);
        offset += name_size;
        hash_to_hex(offset, tree->entries[i].hash);
        offset += HASH_BYTES;
    }
    free(data);
    return tree;
}

void free_tree(tree_t *tree) {
    if (tree->entries == NULL){
        printf("why the tree null\n");
        free(tree);
        return;
    }
    for (size_t i = 0; i < tree->entry_count; i++) free(tree->entries[i].name);
    free(tree->entries);
    free(tree);
}

void free_tree_entry(tree_entry_t *tree_entry){
    free(tree_entry->name);
    free(tree_entry);
}

void free_tree_mine(tree_t *tree) {
    if (tree->entries == NULL){
        printf("why the tree null\n");
        free(tree);
        return;
    }
    // for (size_t i = 0; i < tree->entry_count; i++) free_tree_entry(&tree->entries[i]);
    free(tree->entries);
    free(tree);
}

blob_t *read_blob(const object_hash_t hash) {
    blob_t *blob = malloc(sizeof(*blob));
    assert(blob != NULL);
    object_type_t type;
    blob->contents = read_object(hash, &type, &blob->length);

    assert(type == BLOB);
    return blob;
}

void free_blob(blob_t *blob) {
    free(blob->contents);
    free(blob);
}

size_t decode_varint(const uint8_t **data, size_t *length) {
    size_t value = 0;
    size_t bits_read = 0;
    bool more_bytes = true;
    while (more_bytes) {
        assert(*length > 0);
        uint8_t byte = *((*data)++);
        (*length)--;
        value |= (byte & 0b1111111) << bits_read;
        bits_read += 7;
        more_bytes = byte >> 7;
    }
    return value;
}

size_t get_header(object_type_t type, size_t length, char *header) {
    // Refuse to write object types that shouldn't be saved
    const char *type_string =
        type == BLOB ? BLOB_TYPE :
        type == COMMIT ? COMMIT_TYPE :
        type == TREE ? TREE_TYPE :
        NULL;
    if (type_string == NULL) {
        fprintf(stderr, "Invalid object type: %d\n", type);
        assert(false);
    }

    size_t printed =
        snprintf(header, MAX_OBJECT_HEADER_LENGTH, "%s %zu", type_string, length);
    assert(printed < MAX_OBJECT_HEADER_LENGTH);
    return sizeof(char[printed + 1]);
}

void get_object_hash(
    object_type_t type,
    const void *contents,
    size_t length,
    object_hash_t hash
) {
    char header[MAX_OBJECT_HEADER_LENGTH];
    size_t header_length = get_header(type, length, header);

    SHA_CTX sha1;
    SHA1_Init(&sha1);
    SHA1_Update(&sha1, header, header_length);
    SHA1_Update(&sha1, contents, length);
    uint8_t hash_bytes[HASH_BYTES];
    SHA1_Final(hash_bytes, &sha1);
    hash_to_hex(hash_bytes, hash);
}

void write_object(
    object_type_t type,
    const void *contents,
    size_t length,
    object_hash_t hash
) {
    char header[MAX_OBJECT_HEADER_LENGTH];
    size_t header_length = get_header(type, length, header);

    get_object_hash(type, contents, length, hash);

    // Deflate file contents to disk
    FILE *file = open_object(hash, "wx");
    if (file == NULL) { // file already exists
        // TODO: should probably check for a hash collision
        return;
    }

    z_stream stream;
    memset(&stream, 0, sizeof(stream));
    int result = deflateInit(&stream, Z_DEFAULT_COMPRESSION);
    assert(result == Z_OK);

    stream.next_in = (uint8_t *) header;
    stream.avail_in = header_length;
    while (stream.avail_in > 0) {
        uint8_t write_buf[DEFLATE_CHUNK_SIZE];
        stream.next_out = write_buf;
        stream.avail_out = DEFLATE_CHUNK_SIZE;
        result = deflate(&stream, Z_NO_FLUSH);
        assert(result == Z_OK);
        size_t out_bytes = stream.next_out - write_buf;
        size_t written = fwrite(write_buf, 1, out_bytes, file);
        assert(written == out_bytes);
    }
    stream.next_in = contents;
    stream.avail_in = length;
    while (stream.avail_in > 0) {
        uint8_t write_buf[DEFLATE_CHUNK_SIZE];
        stream.next_out = write_buf;
        stream.avail_out = DEFLATE_CHUNK_SIZE;
        result = deflate(&stream, Z_NO_FLUSH);
        assert(result == Z_OK);
        size_t out_bytes = stream.next_out - write_buf;
        size_t written = fwrite(write_buf, 1, out_bytes, file);
        assert(written == out_bytes);
    }
    while (result != Z_STREAM_END) {
        uint8_t write_buf[DEFLATE_CHUNK_SIZE];
        stream.next_out = write_buf;
        stream.avail_out = DEFLATE_CHUNK_SIZE;
        result = deflate(&stream, Z_FINISH);
        assert(result == Z_OK || result == Z_STREAM_END);
        size_t out_bytes = stream.next_out - write_buf;
        size_t written = fwrite(write_buf, 1, out_bytes, file);
        assert(written == out_bytes);
    }
    result = deflateEnd(&stream);
    assert(result == Z_OK);
    fclose(file);
}

size_t read_partial_bytes(
    const uint8_t **data,
    size_t *length,
    uint8_t *instruction,
    uint8_t bytes
) {
    size_t value = 0;
    for (uint8_t i = 0; i < bytes; i++) {
        if (*instruction & 1) {
            assert(*length > 0);
            value |= *((*data)++) << (i * 8);
            (*length)--;
        }
        *instruction >>= 1;
    }
    return value;
}

void apply_ref_delta(
    const object_hash_t base_hash,
    const uint8_t *data,
    size_t length,
    object_hash_t hash
) {
    object_type_t base_type;
    size_t base_length;
    uint8_t *base_obj = read_object(base_hash, &base_type, &base_length);

    // Delta data contains 2 varints at start - source size and target size
    size_t source_length = decode_varint(&data, &length);
    assert(base_length == source_length);

    uint8_t result_obj[decode_varint(&data, &length)];
    size_t written = 0;

    while (length > 0) {
        uint8_t instruction = *(data++);
        length--;

        size_t size;
        const uint8_t *source;
        // Copy instruction
        if (instruction >> 7) {
            size_t offset =
                read_partial_bytes(&data, &length, &instruction, MAX_COPY_OFFSET_BYTES);
            size = read_partial_bytes(&data, &length, &instruction, MAX_COPY_SIZE_BYTES);
            // 0 size exception
            if (size == 0) size = 0x10000;
            assert(offset + size <= base_length);
            source = base_obj + offset;
        }
        // New data instruction
        else {
            // Check that this is not a reserved instruction
            assert(instruction != 0);

            size = instruction;
            assert(size <= length);
            source = data;
            data += size;
            length -= size;
        }

        assert(written + size <= sizeof(result_obj));
        memcpy(result_obj + written, source, size);
        written += size;
    }
    assert(written == sizeof(result_obj));
    write_object(base_type, result_obj, sizeof(result_obj), hash);
}

filename: push.c

contents: 
 #include "push.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "config_io.h"
#include "hash_table.h"
#include "linked_list.h"
#include "object_io.h"
#include "ref_io.h"
#include "transport.h"
#include "util.h"


void ermm2(char *ref, object_hash_t hash, void *aux){
    printf("ref received: %s\n", ref);
    printf("hash: %s\n", hash);

    hash_table_t *table = (hash_table_t *)aux;
    hash_table_add(table, ref, strdup((char *)hash));
    // free(ref);
}

char **get_commit_hashes_to_push(char *hash, char *remote_hash){
    // printf("hash: %s", hash);
    commit_t *commit = read_commit(hash);
    char **hashes = NULL;
    size_t count = 0;

    while (commit != NULL){
        object_hash_t *parent_hashes = commit->parent_hashes;
        printf("commit %s\n", hash);
        if (commit->parents > 0){
            // Check if the current hash is the remote hash
            if (strcmp(hash, remote_hash) == 0) {
                break;
            }

            // Add the current hash to the array
            hashes = realloc(hashes, sizeof(char *) * (count + 1));
            hashes[count] = strdup(hash);
            count++;

            memcpy(hash, &(commit->parent_hashes[0]), sizeof(object_hash_t));
            free_commit(commit);

            commit = read_commit(hash);
        } else {
            free_commit(commit);
            commit = NULL;
        }
    }

    // Add a NULL pointer at the end of the array
    hashes = realloc(hashes, sizeof(char *) * (count + 1));
    hashes[count] = NULL;

    return hashes;
}

char * make_head_ref_from_branch(char *branch){
    char * ref = malloc(sizeof(char) * (strlen("refs/heads/") + strlen(branch) + 1));
    strcpy(ref, "refs/heads/");
    strcat(ref, branch);
    return ref;
}

void send_tree(char *tree_hash, transport_t *transport){
    tree_t *tree = read_tree(tree_hash);
    for (size_t i=0; i < tree->entry_count; i ++){
        tree_entry_t tree_entry = tree->entries[i];

        object_type_t obj_type;
        size_t length;
        char *contents = read_object(tree_entry.hash, &obj_type, &length);
        if (contents == NULL) {
            printf("Failed to open object: %s\n", tree_entry.hash);
            exit(1);
        }
        printf("contents: \n %s\n", contents);
        // send_pack_object(transport, obj_type, contents, strlen(contents));
        if (tree_entry.mode == MODE_DIRECTORY){
            send_tree(tree_entry.hash, transport);
        }
    }
}

void send_updates_for_commit(char *commit_hash, transport_t *transport){
    commit_t *commit = read_commit(commit_hash);
    char * tree_hash = commit->tree_hash;
    send_tree(tree_hash, transport);
}


void push(size_t branch_count, const char **branch_names, const char *set_remote) {
    for (size_t i=0; i < branch_count; i ++){
        char *branch = branch_names[i];  
        char *branch_config = malloc(sizeof(char) * strlen("branch \"") + strlen(branch) + 2);
        strcpy(branch_config, "branch \"");

        strcat(branch_config, branch);
        strcat(branch_config, "\"");

        printf("branch config noooo way: %s\n", branch_config);
        config_t *config = read_config();


        char *remote;
        // todo: what to do with merge???
        char *merge;
        for (size_t i=0; i < config->section_count; i++){
            config_section_t sec = config->sections[i];
            if (strcmp(branch_config, sec.name) == 0){
                size_t name_len = strlen(sec.name);
                for (size_t i = 0; i < sec.property_count; i++){
                    if (strcmp(sec.properties[i].key, "remote") == 0 ){
                        remote = sec.properties[i].value;
                    }
                    if (strcmp(sec.properties[i].key, "merge") == 0 ){
                        merge = sec.properties[i].value;
                    }
                }
            }
        }
        
        // TODO: "If a branch is new, it may not have a config section yet;"
        if (remote == NULL){
            printf("failed to push to branch %s, does not exist in config\n", branch);
            exit(1);
        }
        printf("we need to push to  : %s\n", remote);

        config_section_t *remote_sec = get_remote_section(config, remote);
        char *url = get_url(remote_sec);
        printf("url: %s\n", url);

        transport_t * transport = open_transport(PUSH, url);
        hash_table_t *ref_to_hash = hash_table_init(); 
        receive_refs(transport, ermm2, ref_to_hash);

        // list_node_t *ls_node = key_set(ref_to_hash);

        object_hash_t my_remote_hash;
        bool found = get_remote_ref(remote, branch, my_remote_hash);
        if (!found){
            printf("branch %s was not found\n", branch);
            exit(1);
        }
        printf("branch: %s\n", branch);
        // char * branch_name = get_last_dir(ref);
        char *ref = make_head_ref_from_branch(branch);

        char *remote_hash = hash_table_get(ref_to_hash, ref);
        printf("remote_hash: %s\n", remote_hash);
        printf("my hash: %s\n", my_remote_hash);

        if (remote_hash == NULL || strcmp(remote_hash, my_remote_hash) != 0){
            printf("you gotta fetch first\n");
            exit(1);
        }
        object_hash_t curr_hash;
        bool found_branch = get_branch_ref(branch, curr_hash);
        if (!found_branch){
            printf("branch %s was not found", branch);
            exit(1);
        }

        char **hashes_to_push = get_commit_hashes_to_push(curr_hash, remote_hash);
        char * old_hash = remote_hash;
        for (size_t i=0; hashes_to_push[i] != NULL; i++){
            printf("hash to push: %s\n", hashes_to_push[i]);
            send_update(transport, ref, old_hash, hashes_to_push[i]);
            // size_t object_count;
            // // send_pack_object(transport, )
            send_updates_for_commit(hashes_to_push[i], transport);

            old_hash = hashes_to_push[i];
        }

        finish_updates(transport);

        // start sending over the pack file 
        // start_pack(transport, object_count);



        // we can push the branch!!

        // while (ls_node != NULL){
        //     char *ref = ls_node->value;
        //     printf("ref here: %s\n", ref);
        //     // TODO: what to do with the head ref prbably update it huh
        //     if (strcmp("HEAD", ref) == 0){
        //         ls_node = ls_node->next;
        //         continue;
        //     }

        //     char * branch_name = get_last_dir(ref);
        //     printf("%s\n", bruh);

        //     object_hash_t myhash;
        //     bool got_ref = get_remote_ref(remote, bruh, myhash);
        //     if (!got_ref){
        //         printf("what\n");
        //         exit(1);
        //     }
            
        //     printf("myhash: %s\n", myhash);

        //     // compare myhash with the remote hash to see if we need to do a git fetch/pull
        //     // if (strcmp(myhash, ))

        //     ls_node = ls_node->next;
        // }

        // send_update(transport, NULL, )
        close_transport(transport);
        // free(url);


        
        free_config(config);
        free(branch_config);
        free(url);
    }
    
    // list_node_t *ref_node = key_set(ref_to_hash);


    // finish_wants(transport);

    
}

filename: ref_io.c

contents: 
 #include "ref_io.h"
#include <assert.h>
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "util.h"

// HEAD file pointing to a ref (e.g. master) starts with this prefix
const char REF_PREFIX[] = "ref: refs/heads/";
// The HEAD file
const char HEAD_FILE[] = ".git/HEAD";
// The branches directory (contains a file for each branch name)
const char BRANCH_REFS_DIR[] = ".git/refs/heads/";
// The remote branches directory (contains a directory for each remote)
const char REMOTE_REFS_DIR[] = ".git/refs/remotes/";

char *read_head_file(bool *detached) {
    FILE *file = fopen(HEAD_FILE, "r");
    if (file == NULL) {
        fprintf(stderr, "fatal: HEAD file not found\n");
        assert(false);
    }

    // Have to strip newline at end
    size_t size = get_file_size(file) / sizeof(char) - 1;
    char *contents = malloc(sizeof(char[size + 1]));
    assert(contents != NULL);
    size_t read = fread(contents, sizeof(char), size, file);
    assert(read == size);
    fclose(file);
    contents[size] = '\0';

    *detached = !starts_with(contents, REF_PREFIX);
    if (*detached) assert(size == HASH_STRING_LENGTH);
    else {
        size_t prefix_length = strlen(REF_PREFIX);
        size = sizeof(char[size - prefix_length + 1]);
        memmove(contents, contents + prefix_length, size);
        contents = realloc(contents, size);
        assert(contents != NULL);
    }
    return contents;
}

void write_head_file(const char *contents, bool detached) {
    FILE *file = fopen(HEAD_FILE, "w");
    if (file == NULL) {
        fprintf(stderr, "fatal: could not write to HEAD\n");
        assert(false);
    }

    int result;
    if (detached) assert(strlen(contents) == HASH_STRING_LENGTH);
    else {
        result = fputs(REF_PREFIX, file);
        assert(result != EOF);
    }
    result = fputs(contents, file);
    assert(result != EOF);
    result = fputc('\n', file);
    assert(result != EOF);
    fclose(file);
}

bool head_to_hash(const char *head, bool detached, object_hash_t hash) {
    if (detached) {
        memcpy(hash, head, sizeof(object_hash_t));
        return true;
    }
    return get_branch_ref(head, hash);
}

FILE *open_branch_ref(const char *branch, char *mode) {
    char filename[strlen(BRANCH_REFS_DIR) + strlen(branch) + 1];
    strcpy(filename, BRANCH_REFS_DIR);
    strcat(filename, branch);
    if (mode[0] == 'w') make_parent_dirs(filename);
    return fopen(filename, mode);
}

bool read_hash(FILE *file, object_hash_t hash) {
    if (file == NULL) return false;

    size_t read = fread(hash, sizeof(char), HASH_STRING_LENGTH, file);
    assert(read == HASH_STRING_LENGTH);
    hash[HASH_STRING_LENGTH] = '\0';
    fclose(file);
    return true;
}


void write_hash(FILE *file, const object_hash_t hash) {
    size_t written = fwrite(hash, sizeof(char), HASH_STRING_LENGTH, file);
    assert(written == HASH_STRING_LENGTH);
    int result = fputc('\n', file);
    assert(result != EOF);
    fclose(file);
}

bool get_branch_ref(const char *branch, object_hash_t hash) {
    return read_hash(open_branch_ref(branch, "r"), hash);
}
void set_branch_ref(const char *branch, const object_hash_t hash) {
    FILE *file = open_branch_ref(branch, "w");
    if (file == NULL) {
        fprintf(stderr, "Failed to write branch: %s\n", branch);
        assert(false);
    }
    write_hash(file, hash);
}

FILE *open_remote_ref(const char *remote, const char *ref, char *mode) {
    char filename[strlen(REMOTE_REFS_DIR) + strlen(remote) + 1 + strlen(ref) + 1];
    strcpy(filename, REMOTE_REFS_DIR);
    strcat(filename, remote);
    strcat(filename, "/");
    strcat(filename, ref);
    printf("FILE NAME: %s\n", filename);
    if (mode[0] == 'w') make_parent_dirs(filename);
    return fopen(filename, mode);
}

bool get_remote_ref(const char *remote, const char *ref, object_hash_t hash) {
    return read_hash(open_remote_ref(remote, ref, "r"), hash);
}
void set_remote_ref(const char *remote, const char *ref, const object_hash_t hash) {
    FILE *file = open_remote_ref(remote, ref, "w");
    if (file == NULL) {
        fprintf(stderr, "Failed to write ref %s on remote %s\n", ref, remote);
        assert(false);
    }
    write_hash(file, hash);
}

linked_list_t *list_branch_refs(void) {
    linked_list_t *refs = init_linked_list();
    DIR *refs_dir = opendir(BRANCH_REFS_DIR);
    assert(refs_dir != NULL);
    struct dirent *entry;
    while ((entry = readdir(refs_dir)) != NULL) {
        if (entry->d_name[0] == '.') continue;

        char *name_copy = strdup(entry->d_name);
        assert(name_copy != NULL);
        list_push_back(refs, name_copy);
    }
    closedir(refs_dir);
    return refs;
}


bool branch_exists(const char *branch_name) {
    char filename[strlen(BRANCH_REFS_DIR) + strlen(branch_name) + 1];
    strcpy(filename, BRANCH_REFS_DIR);
    strcat(filename, branch_name);

    FILE *file = fopen(filename, "r");
    if (file != NULL) {
        fclose(file);
        return true;
    }
    return false;
}
filename: status.c

contents: 
 #include "status.h"
#include <assert.h>
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "index_io.h"
#include "object_io.h"
#include "ref_io.h"

#include "linked_list.h"

#include "util.h"



void get_all_files_in_directory_recursively(const char *dir_name, char **files, size_t array_size, int *index) {
    DIR *d;
    struct dirent *dir;
    d = opendir(dir_name);
    if (d == NULL) {
        return;
    }
    char path[1024];
    while ((dir = readdir(d)) != NULL) {
        if (dir->d_type == DT_DIR) {
            if (strcmp(dir->d_name, ".") == 0 || strcmp(dir->d_name, "..") == 0){
                continue;
            }
            snprintf(path, sizeof(path), "%s/%s", dir_name, dir->d_name);

            if (starts_with(path, "./.git") == 1) {
                continue;
            }
            // if (starts_with(path, "./bin") == 1) {
            //     continue;
            // }
            // if (starts_with(path, "./out") == 1) {
            //     continue;
            // }
            get_all_files_in_directory_recursively(path, files, array_size, index);
        } else {
            // When you add a file path to the files array
            snprintf(path, sizeof(path), "%s/%s", dir_name, dir->d_name);
            files[*index] = strdup(path+2);
            (*index)++;

            // Check if the array needs to be resized
            if ((size_t) *index >= array_size) {
                // Double the size of the array
                array_size *= 2;
                files = realloc(files, array_size * sizeof(char *));
                if (files == NULL) {
                    // Handle the error
                    fprintf(stderr, "Failed to allocate memory\n");
                    exit(1);
                }
            }
        }
    }
    closedir(d);
}

char **get_all_files_in_directory() {
    char **files = malloc(sizeof(char *) * 1024);  // Allocate memory for up to 1024 file names
    if (files == NULL) {
        return NULL;
    }
    int index = 0;
    get_all_files_in_directory_recursively(".", files, 1024, &index);
    files[index] = NULL;  // Null-terminate the array

    return files;
}

void print_staged_for_commit(index_file_t *idx_file, hash_table_t *commit_table){

    list_node_t *curr_node = key_set(idx_file->entries);

    while (curr_node != NULL){
        char *file_name = curr_node->value;
        index_entry_t *idx_entry = hash_table_get(idx_file->entries, file_name);

        char *hash_commit = (char *) hash_table_get(commit_table, file_name);
        if (hash_commit == NULL) {
            // in the index, not in the commit 
            printf("\tnew file: %s\n", file_name);
        } else{
            // The hashes are different, indicating modified
            if (strcmp(idx_entry->sha1, hash_commit) != 0){
                printf("\tmodified: %s\n", file_name);
            }
            // otherwise they're the same file
        }
        curr_node = curr_node->next;
    }

    list_node_t *commit_node = key_set(commit_table);

    // iterating through the commit file to track delted files
    while (commit_node != NULL){
        char *file_name = commit_node->value;

        if (!hash_table_contains(idx_file->entries, file_name)){
            // index file doesn't have it, but commit does
            printf("\tdeleted: %s\n", file_name);
        }
        commit_node = commit_node->next;
    }
}


void status(void) {
    bool *detached = malloc(sizeof(bool));
    char *head = read_head_file(detached);

    // get to the hash of the head
    // const char *PATH = ".git/refs/heads/";

    // if (!*detached){
    //     printf("not detached brodie\n");
    // }
    char *hash = malloc(sizeof(char) * (HASH_STRING_LENGTH + 1));
    bool found = head_to_hash(head, *detached, hash);
    hash_table_t *commit_table = hash_table_init();
    commit_t *head_commit;
    
    if (!found){
        free(hash);
        printf("couldn't find head!!!\n");
        exit(1);
        // todo: worry about the memory leaks
    } else {
        head_commit = read_commit(hash);
        object_hash_t tree_hash;
        memcpy(tree_hash, head_commit->tree_hash, sizeof(object_hash_t));  // Copy the tree_hash

        // map the file names of the commit to their hashes
        expand_tree(tree_hash, commit_table, "");
    }


    index_file_t *idx_file = read_index_file();

    printf("Staged for commit:\n");
    print_staged_for_commit(idx_file, commit_table);

    char **files = get_all_files_in_directory();

    hash_table_t *work_tree = hash_table_init();

    printf("Not staged for commit:\n");
    for (int i = 0; files[i] != NULL; i++) {
        // printf("%s\n", files[i]);
        char *file_path = files[i];
        char *file_contents = get_file_contents(file_path);

        object_hash_t hash;
        get_object_hash(BLOB, file_contents, strlen(file_contents), hash);

        hash_table_add(work_tree, file_path, (char *) hash);
        if (hash_table_contains(idx_file->entries, file_path)){
            // printf("yuhhhh\n");
            index_entry_t *index_entry = hash_table_get(idx_file->entries, file_path);
            if (strcmp(hash, index_entry->sha1) != 0){
                // printf("idx_hash  %s\n", index_entry->sha1);
                // printf("file hash %s\n",  hash);
                printf("\tmodified: %s\n", file_path);
            }
        }
        free(file_contents);
    }


    list_node_t *curr_node2 = key_set(idx_file->entries);

    // iterating through the index file to see if one has gotten deleted
    while (curr_node2 != NULL){
        char *file_name = curr_node2->value;
        if (!hash_table_contains(work_tree, file_name)){
            printf("\tdeleted: %s\n", file_name);
        }
        curr_node2 = curr_node2->next;
    }

    printf("Untracked files:\n");
    for (int i = 0; files[i] != NULL; i++) {
        char *file_path = files[i];
        if (!hash_table_contains(idx_file->entries, file_path)){
            printf("\t%s\n", file_path);
        }
    }
    // TODO WHY IS THIS UNNECESSARY???
    free_commit(head_commit);
    free(detached);
    free(head);
    free(hash);
    free_index_file(idx_file);
    free_hash_table(work_tree, NULL);
    free_hash_table(commit_table, free);
}

filename: temp.c

contents: 
 #include "commit.h"
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "config_io.h"
#include "index_io.h"
#include "object_io.h"
#include "ref_io.h"
#include "util.h"


struct list_node {
   list_node_t *next;
   void *value;
};
struct linked_list {
    list_node_t *head;
    list_node_t **tail;
};

typedef struct directory_file{
    char *file_dir_name;
    bool is_directory;
} directory_file_t;

typedef struct directory{
    /* data */
    bool completed;
    char *name;
    directory_file_t *directory_files;
    size_t num_files;
} directory_t;

directory_t *make_directory(char *name){
    directory_t * directory = malloc(sizeof(directory_t));
    directory->name = malloc(sizeof(char) * (1 + strlen(name)));
    strcpy(directory->name, name);
    directory->num_files = 0;
    directory->directory_files = NULL;
    directory->completed = false;
    return directory;
}

void add_to_directory(directory_t *directory, char * file_name, bool dir){
    directory->directory_files = realloc(directory->directory_files, sizeof(directory_file_t) * (directory->num_files + 1));

    directory_file_t dir_file;
    dir_file.is_directory = dir;
    dir_file.file_dir_name = file_name;
    
    directory->directory_files[directory->num_files] = dir_file;
    directory->num_files++;
}

void free_directory(directory_t *directory){

    directory_file_t *directory_files = directory->directory_files;
    for (size_t i=0; i < directory->num_files; i++){
        free(directory_files[i].file_dir_name);
    }
    if (directory->directory_files != NULL){
        free(directory->directory_files);
    }
    free(directory->name);
    free(directory);
}

// dictionary from directories to the tree objects
tree_entry_t *make_tree_entry(char *name, file_mode_t mode, object_hash_t hash){
    tree_entry_t *tree_entry = malloc(sizeof(tree_entry_t));
    tree_entry->mode = mode;
    strcpy(tree_entry->hash, hash);
    tree_entry->name = name;
    return tree_entry;
}

// starts off with one tree entry
tree_t *make_empty_tree(){
    tree_t *tree = malloc(sizeof(tree_t));
    assert(tree != NULL);
    tree->entry_count = 0;
    tree->entries = NULL; 
    return tree;
}

void add_to_tree(tree_t *tree, tree_entry_t *tree_entry){
    // printf("tree count %lu\n\n", tree->entry_count);
    tree->entries = realloc(tree->entries, (tree->entry_count + 1) * sizeof(tree_entry_t));
    if (tree->entries == NULL) {
        // Handle error
        // fprintf(stderr, "Failed to allocate memory.\n");
        return;
    }
    tree->entries[tree->entry_count] = *tree_entry;
    tree->entry_count++;
}

char **split_path_into_directories(char *path) {
    // Count the number of directories in the path
    int count = 0;
    for (int i = 0; path[i]; i++) {
        if (path[i] == '/') {
            count++;
        }
    }

    // Allocate memory for the array of directory names
    char **directories = malloc((count + 2) * sizeof(char *));
    if (directories == NULL) {
        fprintf(stderr, "Failed to allocate memory.\n");
        return NULL;
    }

    // Split the path into directory names
    int index = 0;
    char *token = strtok(path, "/");
    while (token != NULL) {
        directories[index] = token;
        token = strtok(NULL, "/");
        index++;
    }
    directories[index] = NULL;  // Null-terminate the array

    return directories;
}



void add_to_directory_map(index_entry_t *index_entry, hash_table_t *directory_map) {
    char *file_path = index_entry->fname;
    // char *file_path_copy = strdup(file_path);
    // char *curr_directory = malloc(1);  
    // *curr_directory = '\0';  
    // char *file = strtok(file_path_copy, "/");

    char **file_split = split_path_into_directories(file_path);

    char *curr_directory = strdup("");  // Initialize curr_directory as an empty string
    
    for (int i = 0; file_split[i] != NULL; i++) {
        if (file_split[i+1] == NULL){
            char * file = file_split[i];
            // printf("Directory: %s\n", curr_directory);
            // printf("curr part: %s\n", file);
            if (hash_table_contains(directory_map, curr_directory)){
                directory_t *directory = hash_table_get(directory_map, curr_directory);
                char* part2 = strdup(file);
                add_to_directory(directory, part2, false);
            } else {
                char* dir_copy = strdup(curr_directory);
                directory_t *directory = make_directory(dir_copy);
                char * bruh = strdup(file);
                add_to_directory(directory, bruh, false);
                hash_table_add(directory_map, dir_copy, directory);
                free(dir_copy);
            }
        } else{

            char *prev_dir = strdup(curr_directory);

            size_t new_length = strlen(curr_directory) + strlen(file_split[i]) + 2;  
            curr_directory = realloc(curr_directory, new_length);  // Reallocate memory for curr_directory

            strcat(curr_directory, file_split[i]);
            strcat(curr_directory, "/");  // Append "/" to curr_directory

            // add to the previous directory if the previous directory
            // exists
            // or make a new directory if it's not in the hash table

            if (hash_table_contains(directory_map, curr_directory)){
                // directory_t *directory = hash_table_get(directory_map, prev_dir);
                // char* part2 = strdup(curr_directory);
                // add_to_directory(directory, part2, true);
            } else {
                char* prev_dir_copy = strdup(prev_dir);
                char* dir_copy = strdup(curr_directory);

                assert(hash_table_contains(directory_map, prev_dir_copy));

                directory_t *prev_directory = hash_table_get(directory_map, prev_dir_copy);

                add_to_directory(prev_directory, dir_copy, true);

                directory_t *new_directory = make_directory(dir_copy);

                hash_table_add(directory_map, dir_copy, new_directory);
                // free(dir_copy);
                free(prev_dir_copy);
            }
            free(prev_dir);
        }       
    }
    free(file_split);
    // free(file_path_copy);
    free(curr_directory);
}

char *get_last_dir(char *file_dir_name){

    char * full_name = strdup(file_dir_name);     
    char ** full_name_splitted= split_path_into_directories(full_name);
    int count = 0;

    while (full_name_splitted[count] != NULL) {
        count++;
    }
    char *last_dir;
    if (count != 0){
        last_dir = strdup(full_name_splitted[count-1]);
    } else {
        last_dir = strdup(full_name);
    }
    free(full_name_splitted);
    free(full_name);
    return last_dir;
}

void debug_map(const hash_table_t *dir_map){
    list_node_t *head2 = key_set(dir_map);
    while (head2 != NULL) {
        char *file_path = head2->value;
        directory_t *dir = hash_table_get(dir_map, file_path);
        printf("dir name: %s-------------\n", dir->name);
        for (size_t i=0; i < dir->num_files; i++){
            directory_file_t dir_file = dir->directory_files[i];
            if (dir_file.is_directory){
                printf("\tdirectory: %s\n", dir_file.file_dir_name);

                // get_last_dir(dir_file.file_dir_name);
                
            } else {
                printf("\tnot a directory: %s\n", dir_file.file_dir_name);
            }
        }
        printf("\n");
        head2 = head2->next;
    }

    printf("--------------------   end of debug    ----------------\n\n\n");

}


char *get_full_name(char *dir_name, char *file_name){
    char * full_path = malloc(sizeof(char) * (strlen(dir_name) + strlen(file_name) + 1));
    strcpy(full_path, dir_name);
    strcat(full_path, file_name);
    return full_path;
}


char *add_a_stupid_slash(char *string){
    char * name_w_slash = malloc(sizeof(char) * (strlen(string) + 2));
    strcpy(name_w_slash, string);
    strcat(name_w_slash, "/");
    return name_w_slash;
}
bool can_hash(directory_t *dir, hash_table_t *dir_map){
    if (dir->completed){
        return true;
    }
    for (size_t i=0; i < dir->num_files; i++){
        directory_file_t dir_file = dir->directory_files[i];
        if (dir_file.is_directory){
            char *name_w_slash;
            if (dir_file.file_dir_name[strlen(dir_file.file_dir_name)-1] != '/'){
                name_w_slash = add_a_stupid_slash(dir_file.file_dir_name);
            } else {
                name_w_slash = strdup(dir_file.file_dir_name);
            }
            // char * name_w_slash = add_a_stupid_slash(dir_file.file_dir_name);
            
            directory_t * the_dir = hash_table_get(dir_map, name_w_slash);
            assert(the_dir != NULL);
            free(name_w_slash);

            if (!the_dir->completed){
                return false;
            }
        }
    }
    dir->completed = true;
    return true;
}


void write_tree(directory_t *directory, const hash_table_t * index_table, hash_table_t *tree_map) {
    
    uint8_t *contents = malloc(1);
    size_t curr_size = 0;

    // *contents = '\0';
    for (size_t i=0; i < directory->num_files; i ++){
        directory_file_t dir_file = directory->directory_files[i];

        if (dir_file.is_directory){

            assert(hash_table_contains(tree_map, dir_file.file_dir_name));

            void *tree_hash = hash_table_get(tree_map, dir_file.file_dir_name);
            // printf("tree hash len: %s\n", strlen(tree_hash));

            char *last_dir = get_last_dir(dir_file.file_dir_name);

            // char mode_str[12];  // Large enough to hold a 32-bit integer in octal
            // sprintf(mode_str, "%o", idx_entry->mode);
            //bruh

            contents = realloc(contents, curr_size + strlen("40000 ") + strlen(last_dir) + 2 + HASH_BYTES);
            
            memcpy(contents + curr_size, "40000 ", strlen("40000 "));
            curr_size += strlen("40000 ");


            memcpy(contents + curr_size, last_dir, strlen(last_dir));
            curr_size += strlen(last_dir);

            memcpy(contents + curr_size, "\0", 1);
            curr_size += 1;

            uint8_t hash_bytes[HASH_BYTES];
            hex_to_hash(tree_hash, hash_bytes);
            memcpy(contents + curr_size, hash_bytes, HASH_BYTES);
            curr_size += HASH_BYTES;
            free(last_dir);

        } else {
            char *full_name = get_full_name(directory->name, dir_file.file_dir_name);
            // printf("full name : %s\n", full_name);
            index_entry_t *idx_entry = hash_table_get(index_table, full_name);
            assert(idx_entry != NULL);

            char mode_str[12];  // Large enough to hold a 32-bit integer in octal
            sprintf(mode_str, "%o", idx_entry->mode);
            size_t total_size = curr_size + strlen(mode_str) + strlen(dir_file.file_dir_name) + HASH_BYTES + 3;
            contents = realloc(contents, total_size);
            
            
            memcpy(contents + curr_size, mode_str, strlen(mode_str));
            curr_size += strlen(mode_str);
            
            memcpy(contents + curr_size, " ", 1);
            curr_size += 1;
            memcpy(contents + curr_size, dir_file.file_dir_name, strlen(dir_file.file_dir_name));
            curr_size += strlen(dir_file.file_dir_name);
            memcpy(contents + curr_size, "\0", 1);

            curr_size += 1;

            // size_t contents_len = strlen(contents);
            uint8_t hash_bytes[HASH_BYTES];
            hex_to_hash(idx_entry->sha1, hash_bytes);
            memcpy(contents + curr_size, hash_bytes, HASH_BYTES);
            curr_size += HASH_BYTES;
            
            // strcat(contents, hash_bytes);
            // printf("contents: \n%s\n", contents);
            free(full_name);
        }
    }
    object_hash_t hash;
    write_object(TREE, (void *)contents, curr_size, hash);

    char *hash_brodie = malloc(sizeof(char) * 41);
    strcpy(hash_brodie, hash);

    hash_table_add(tree_map, directory->name, hash_brodie);
    free(contents);
}






void directory_traversal(directory_t *curr_root_directory, hash_table_t *dir_map, const hash_table_t * index_table, hash_table_t * tree_map){



    if (can_hash(curr_root_directory, dir_map) ){
        char *dir_name = get_last_dir(curr_root_directory->name);

        // hash the stuff and return remember to write name of the tree not the
        // name of the 
        write_tree(curr_root_directory, index_table, tree_map);
        free(dir_name);
        return;
    }
    for (size_t i=0; i < curr_root_directory->num_files; i ++){
        directory_file_t dir_file = curr_root_directory->directory_files[i];
        char *file_name = dir_file.file_dir_name;

        if (dir_file.is_directory){
            // printf("dir name: %s\n", dir_file.file_dir_name);
            char *name_w_slash;
            if (dir_file.file_dir_name[strlen(dir_file.file_dir_name)-1] != '/'){
                // printf("bruhhhh\n");

                // printf("   %c ???????", dir_file.file_dir_name[strlen(dir_file.file_dir_name)-1]);
                name_w_slash = add_a_stupid_slash(dir_file.file_dir_name);
            } else {
                name_w_slash = strdup(dir_file.file_dir_name);
            }


            assert(hash_table_contains(dir_map, name_w_slash));

            directory_t * directory = hash_table_get(dir_map, name_w_slash);
            if (!directory->completed){
                directory_traversal(directory, dir_map, index_table, tree_map);
                directory->completed = true;
            } 
            free(name_w_slash);
        } else {
            // it has to be a blob object, make it into the tree entry
            char *full_path = get_full_name(curr_root_directory->name, file_name);
            assert(hash_table_contains(index_table, full_path));
            free(full_path);
        }
    }    
    char *dir_name = get_last_dir(curr_root_directory->name);

    // printf("i can be hashed %s\n", dir_name);
    // hash the stuff and return remember to write name of the tree not the
    // name of the 
    write_tree(curr_root_directory, index_table, tree_map);
    free(dir_name);
    curr_root_directory->completed = true;
}

char *make_tree_from_idx(hash_table_t *tree_map){
    index_file_t *index_file = read_index_file();
    hash_table_t *index_table = index_file->entries;

    hash_table_sort(index_table);

    list_node_t *head = key_set(index_table);

    // // Count the number of nodes in the linked list
    list_node_t *current = head;

    hash_table_t *dir_map = hash_table_init();


    directory_t *root_dir = make_directory("");


    hash_table_add(dir_map, "", root_dir);

    while (current != NULL) {
        char *file_path = current->value;
        index_entry_t *idx_entry = hash_table_get(index_table, file_path);
        
        char *str = strdup(file_path);
        add_to_directory_map(idx_entry, dir_map);

        current = current->next;
        free(str);
    }

    directory_traversal(root_dir, dir_map, index_file->entries, tree_map);

    char *final_hash = hash_table_get(tree_map, "");


    free_hash_table(dir_map, (free_func_t) free_directory);

    free_index_file(index_file);
    // free_hash_table(dir_tree_map, free_tree);
    return final_hash;

}

commit_t *get_head_commit(bool *detached){
    char *head = read_head_file(detached);

    if (!*detached){
        printf("not detached brodie\n");
    }
    char *hash = malloc(sizeof(char) * (HASH_STRING_LENGTH + 1));
    head_to_hash(head, *detached, hash);

    commit_t *head_commit = read_commit(hash);
    free(hash);
    free(head);
    return head_commit;
}




char* get_unix_timestamp_and_timezone() {
    time_t current_time = time(NULL);
    struct tm* local_time_info = localtime(&current_time);

    // Calculate the timezone offset in hours and minutes
    int timezone_offset_hours = local_time_info->tm_gmtoff / 3600;
    int timezone_offset_minutes = labs((local_time_info->tm_gmtoff % 3600) / 60);

    char* timestamp_and_timezone_str = malloc(30);  // Large enough to hold the timestamp and timezone
    if (timestamp_and_timezone_str == NULL) {
        fprintf(stderr, "Failed to allocate memory for timestamp_and_timezone_str\n");
        exit(1);
    }
    sprintf(timestamp_and_timezone_str, "%ld %+03d%02d", (long)current_time, timezone_offset_hours, timezone_offset_minutes);
    return timestamp_and_timezone_str;
}


char* create_commit_message(const char* tree_hash, const char* commit_message, char **parent_hashes) {
    // Calculate the size of the commit message
    config_t *config = read_global_config();

    config_section_t *config_section = get_section(config, "user");

            
    char * author_email = NULL; //= config_section->properties[0].value;
    char * author_name = NULL; //= config_section->properties[1].value;

    for (size_t i=0; i < config_section->property_count; i++){
        config_property_t property =  config_section->properties[i];
        printf(" %s \n", config_section->properties[i].value);
        if (strcmp(property.key, "email") == 0){
            author_email = config_section->properties[i].value;
            printf("author email: %s\n", author_email);
        }
        if (strcmp(property.key, "name") == 0){
            author_name = config_section->properties[i].value;
            printf("author name: %s\n", author_name);
        }
    }

    if (author_email == NULL || author_name == NULL){
        printf("Author or email is not set in config file");
        exit(1);
    }
    
    
    size_t count = 0;
    size_t parent_len = 0;
    for (size_t i =0 ; parent_hashes[i] != NULL; i++){  
        // printf("parent_hash %s\n", parent_hashes[i]); 
        parent_len += strlen(parent_hashes[i]);
        count++;
    }
    
    char* author_date_unix = get_unix_timestamp_and_timezone();
    char* committer_date_unix = get_unix_timestamp_and_timezone();

    // printf("author date unix %s\n", author_date_unix);

    size_t message_size = strlen("tree \n\nauthor <>  \ncommitter <>  \n\n\n") +
                      strlen(tree_hash) + parent_len + count *strlen("parent ") + 
                      strlen(commit_message) + 
                      2 * (strlen(author_name) + strlen(author_email) + strlen(author_date_unix) + 20);

    char *commit_message_str = malloc(sizeof(char) * message_size);
    if (commit_message_str == NULL) {
        fprintf(stderr, "Failed to allocate memory for commit_message_str\n");
        exit(1);
    }

    strcpy(commit_message_str, "tree ");
    strcat(commit_message_str, tree_hash);
    strcat(commit_message_str, "\n");

    for (size_t i = 0; parent_hashes[i] != NULL; i++) {
        strcat(commit_message_str, "parent ");
        strcat(commit_message_str, parent_hashes[i]);
        strcat(commit_message_str, "\n");
    }

    strcat(commit_message_str, "author ");
    strcat(commit_message_str, author_name);
    strcat(commit_message_str, " <");
    strcat(commit_message_str, author_email);
    strcat(commit_message_str, "> ");
    strcat(commit_message_str, author_date_unix);
    strcat(commit_message_str, "\n");

    strcat(commit_message_str, "committer ");
    strcat(commit_message_str, author_name);
    strcat(commit_message_str, " <");
    strcat(commit_message_str, author_email);
    strcat(commit_message_str, "> ");
    strcat(commit_message_str, committer_date_unix);
    strcat(commit_message_str, "\n\n");

    strcat(commit_message_str, commit_message);
    strcat(commit_message_str, "\n");

    free(author_date_unix);
    free(committer_date_unix);

    // printf("commit message:\n\n\n%s\n", commit_message_str);
    free_config(config);

    return commit_message_str;
}

void commit(const char *commit_message) {

    // index_file_t *read_index_file();
    hash_table_t *tree_map = hash_table_init();

    char *tree_hash = make_tree_from_idx(tree_map);
    // printf("tree hash %s\n", tree_hash);
    bool detached;    
    char *head = read_head_file(&detached);


    char *commit_hash = malloc(sizeof(char) * (HASH_STRING_LENGTH + 1));
    bool found = head_to_hash(head, detached, commit_hash);
    if (!found){
        free(commit_hash);
        commit_hash = NULL;
    }

    // make multiple parent hashes
    char **parent_hashes = malloc(sizeof(char *) * 2);
    parent_hashes[0] = commit_hash;
    parent_hashes[1] = NULL;

    char * msg = create_commit_message(tree_hash, commit_message, parent_hashes);
    printf("commit message:\n%s\n", msg);
    object_hash_t hash; 
    write_object(COMMIT, msg, strlen(msg), hash);


    printf("commit hash %s\n", hash);
    free_hash_table(tree_map, free);
    free(msg);
    if (commit_hash != NULL){
        free(commit_hash);
    }
    if (detached){
        write_head_file(hash, detached);
    } else {
        set_branch_ref(head, hash);
    }
    free(head);
    free(parent_hashes);
}

filename: transport.c

contents: 
 #include "transport.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>
#include <openssl/sha.h>
#define ZLIB_CONST
#include <zlib.h>
#include "util.h"

const char SSH[] = "ssh";
const char FETCH_COMMAND[] = "git-upload-pack '";
const char PUSH_COMMAND[] = "git-receive-pack '";
const char CLOSE_QUOTE[] = "'";

const size_t PKT_HEX_LENGTH = 4;
const size_t MAX_PKT_DATA_LENGTH = 65516; // requirement documented in protocol-common.txt
const char FLUSH_PKT[] = "0000";

const char ERR[] = "ERR ";
const char WANT[] = "want ";
const char HAVE[] = "have ";
const char ACK[] = "ACK ";
const char NAK[] = "NAK";
const char READY[] = "ready";
const char COMMON[] = "common";
const char DONE[] = "done";
const char UNPACK[] = "unpack ";
const char UNPACK_OK[] = "ok";
const char REF_OK[] = "ok ";
const char REF_NOT_GOOD[] = "ng ";
const object_hash_t ZERO_HASH = "0000000000000000000000000000000000000000";

const char FETCH_CAPABILITIES[] = " side-band-64k multi_ack_detailed";
const char PUSH_CAPABILTIIES[] = "report-status";

const char BRANCH_REF_PREFIX[] = "refs/heads/";

const uint8_t PACK_SIGNATURE[] = {'P', 'A', 'C', 'K'};
const size_t PACK_SIGNATURE_LENGTH = sizeof(PACK_SIGNATURE);
const size_t PACK_VERSION_LENGTH = 4;
const size_t PACK_OBJECT_COUNT_LENGTH = 4;
const size_t PACK_VERSION = 2;
const size_t PUSH_DEFLATE_CHUNK_SIZE = 128 << 10; // 128 KB

typedef enum {
    PACK = 1,
    PROGRESS = 2,
    ERROR = 3
} stream_code_t;

typedef enum {
    // Fetch states
    FETCH_RECEIVING_REFS,
    SENDING_FIRST_WANT,
    SENDING_ADDITIONAL_WANT,
    SENDING_HAVES,
    SENDING_HAVES_READY,
    RECEIVING_PACK,

    // Push states
    PUSH_RECEIVING_REFS,
    SENDING_FIRST_UPDATE,
    SENDING_ADDITIONAL_UPDATE,
    SENDING_PACK_HEADER,
    SENDING_PACK_OBJECTS,
    CHECKING_UPDATES,

    TRANSPORT_DONE
} transport_stage_t;

typedef struct {
    z_stream stream;
    SHA_CTX sha1;
} pack_state_t;

struct transport {
    pid_t ssh_pid;
    int ssh_read_fd, ssh_write_fd;
    transport_stage_t stage;

    // Additional state for pushes
    bool needs_pack;
    pack_state_t *pack_state;
};

// Representing the layout of the argument to a pipe() syscall
typedef struct {
    int read_fd, write_fd;
} pipe_t;

_Noreturn void exec_ssh(
    transport_direction_t direction,
    const char *ssh_login,
    const char *project
) {
    const char *command = direction == FETCH ? FETCH_COMMAND : PUSH_COMMAND;
    // TODO: sanitize project to protect against bash injection?
    char ssh_command[strlen(command) + strlen(project) + strlen(CLOSE_QUOTE) + 1];
    strcpy(ssh_command, command);
    strcat(ssh_command, project);
    strcat(ssh_command, CLOSE_QUOTE);
    char *ssh_extra_arg;
    char **argv;
    if ((ssh_extra_arg = getenv("MYGIT_TESTS_SSH_EXTRA_ARG"))) {
        char* the_argv[] = {(char *) SSH, (char*)ssh_extra_arg, (char *) ssh_login, ssh_command, NULL};
        argv = the_argv;
    } else {
        char* the_argv[] = {(char *) SSH, (char *) ssh_login, ssh_command, NULL};
        argv = the_argv;
    }
    execvp(argv[0], argv);
    fprintf(stderr, "SSH command failed\n");
    assert(false);
}

transport_t *open_transport(transport_direction_t direction, char *url) {
    assert(direction == FETCH || direction == PUSH);
    // We will replace the : between the SSH login
    // and the project name with '\0' in the child process
    char *ssh_login_end = strchr(url, ':');
    if (ssh_login_end == NULL) {
        fprintf(stderr, "Invalid SSH URL: %s\n", url);
        assert(false);
    }

    // Create a bidirectional pipe for the SSH process.
    // The pipes are referred to from the parent process's perspective.
    pipe_t read_pipe, write_pipe;
    int result = pipe((int *) &read_pipe);
    assert(result == 0);
    result = pipe((int *) &write_pipe);
    assert(result == 0);

    // Fork off a subprocess to run SSH
    pid_t ssh_pid = fork();
    assert(ssh_pid >= 0);
    if (ssh_pid == 0) {
        // The child process closes the ends of the pipes used by the parent
        result = close(read_pipe.read_fd);
        assert(result == 0);
        result = close(write_pipe.write_fd);
        assert(result == 0);
        // Connect the ends of the pipes to stdin and stdout of the SSH process.
        // The stdout pipe will be read from the parent and written to by the child.
        // The stdin pipe will be written to by the parent and read from the child.
        result = dup2(read_pipe.write_fd, STDOUT_FILENO);
        assert(result >= 0);
        result = dup2(write_pipe.read_fd, STDIN_FILENO);
        assert(result >= 0);
        size_t ssh_login_length = ssh_login_end - url;
        char *ssh_login = malloc(sizeof(char[ssh_login_length + 1]));
        assert(ssh_login != NULL);
        memcpy(ssh_login, url, sizeof(char[ssh_login_length]));
        ssh_login[ssh_login_length] = '\0';
        exec_ssh(direction, ssh_login, ssh_login_end + 1);
    }
    else {
        // The parent process closes the ends of the pipes used by the child
        result = close(read_pipe.write_fd);
        assert(result == 0);
        result = close(write_pipe.read_fd);
        assert(result == 0);

        // Create a transport_t struct storing the state of the SSH process
        transport_t *transport = malloc(sizeof(*transport));
        assert(transport != NULL);
        transport->ssh_pid = ssh_pid;
        transport->ssh_read_fd = read_pipe.read_fd;
        transport->ssh_write_fd = write_pipe.write_fd;
        transport->stage = direction == FETCH
            ? FETCH_RECEIVING_REFS
            : PUSH_RECEIVING_REFS;
        transport->needs_pack = false; // only used for push
        return transport;
    }
}

void close_transport(transport_t *transport) {
    printf("transport stage :%d\n", transport->stage);
    assert(transport->stage == TRANSPORT_DONE);
    // Close the input to the SSH process, which should cause it to exit
    int result = close(transport->ssh_write_fd);
    assert(result == 0);
    // Wait for the SSH process to exit
    int exit_status;
    pid_t pid = waitpid(transport->ssh_pid, &exit_status, 0);
    assert(pid == transport->ssh_pid);
    // Close the output from the SSH process
    result = close(transport->ssh_read_fd);
    assert(result == 0);
    free(transport);
}

// Tries to read `length` bytes into `buffer`. Returns whether successful.
bool read_full(int fd, void *buffer, size_t length) {
    // Repeatedly call read() since it may only read part of the buffer each time
    while (length > 0) {
        ssize_t read_length = read(fd, buffer, length);
        if (read_length < 0) return false;

        buffer += read_length;
        length -= read_length;
    }
    return true;
}

void *read_pkt_line(transport_t *transport, size_t *length) {
    char hex_length[PKT_HEX_LENGTH];
    if (!read_full(transport->ssh_read_fd, hex_length, sizeof(hex_length))) {
        fprintf(stderr, "Failed to read pkt-len\n");
        assert(false);
    }

    *length = 0;
    for (size_t i = 0; i < PKT_HEX_LENGTH; i++) {
        *length = *length << 4 | from_hex(hex_length[i]);
    }
    // "flush-pkt" marks the end of the pkt
    if (*length == 0) return NULL;

    assert(*length > PKT_HEX_LENGTH);
    *length -= PKT_HEX_LENGTH;
    char *line = malloc(*length);
    assert(line != NULL);
    if (!read_full(transport->ssh_read_fd, line, *length)) {
        fprintf(stderr, "Failed to read pkt-payload\n");
        assert(false);
    }

    if (*length >= strlen(ERR) && starts_with(line, ERR)) {
        fprintf(stderr, "Server error: %.*s", (int) *length, line);
        assert(false);
    }
    return line;
}

char *read_pkt_line_string(transport_t *transport) {
    size_t length;
    char *line = read_pkt_line(transport, &length);
    if (line == NULL) return NULL;

    // Replace newline with a null terminator
    assert(line[length - 1] == '\n');
    line[length - 1] = '\0';
    return line;
}

void write_pkt_line(transport_t *transport, const void *line, size_t length, bool text) {
    // Text pkt-lines include a trailing newline
    size_t data_length = length + (text ? sizeof(char) : 0);
    assert(data_length <= MAX_PKT_DATA_LENGTH);
    size_t line_length = PKT_HEX_LENGTH + data_length;
    char hex_length[PKT_HEX_LENGTH];
    for (size_t i = 0; i < PKT_HEX_LENGTH; i++) {
        hex_length[i] = to_hex(line_length >> ((PKT_HEX_LENGTH - 1 - i) * 4) & 0xF);
    }
    ssize_t written = write(transport->ssh_write_fd, hex_length, sizeof(hex_length));
    assert(written == sizeof(hex_length));
    written = write(transport->ssh_write_fd, line, length);
    assert(written == (ssize_t) length);
    if (text) {
        char newline = '\n';
        written = write(transport->ssh_write_fd, &newline, sizeof(newline));
        assert(written == sizeof(char));
    }
}
void write_pkt_line_string(transport_t *transport, const char *line) {
    size_t length = strlen(line);
    write_pkt_line(transport, line, sizeof(char[length]), true);
}

void send_flush_pkt(transport_t *transport) {
    size_t length = sizeof(char[strlen(FLUSH_PKT)]);
    ssize_t written = write(transport->ssh_write_fd, FLUSH_PKT, length);
    assert(written == (ssize_t) length);
}

void receive_refs(transport_t *transport, ref_receiver_t receiver, void *aux) {
    bool fetch = transport->stage == FETCH_RECEIVING_REFS;
    assert(fetch || transport->stage == PUSH_RECEIVING_REFS);
    char *line;
    while ((line = read_pkt_line_string(transport)) != NULL) {
        // We ignore the list of capabilities after the first ref name
        char *hash_end = strchr(line, ' ');
        if (!hash_end) {
            fprintf(stderr, "Expected commit hash and ref name\n");
            assert(false);
        }
        *hash_end = '\0';
        // Ignore the "zero-id" hash, which is sent when there are no refs
        if (strcmp(line, ZERO_HASH)) receiver(hash_end + 1, line, aux);
        free(line);
    }
    transport->stage = fetch ? SENDING_FIRST_WANT : SENDING_FIRST_UPDATE;
}

void send_want(transport_t *transport, const object_hash_t hash) {
    bool first_want = transport->stage == SENDING_FIRST_WANT;
    assert(first_want || transport->stage == SENDING_ADDITIONAL_WANT);
    size_t line_length = strlen(WANT) + strlen(hash) + 1;
    if (first_want) line_length += strlen(FETCH_CAPABILITIES);
    char line[line_length];
    strcpy(line, WANT);
    strcat(line, hash);
    if (first_want) strcat(line, FETCH_CAPABILITIES);
    write_pkt_line_string(transport, line);
    transport->stage = SENDING_ADDITIONAL_WANT;
}

void finish_wants(transport_t *transport) {
    bool first_want = transport->stage == SENDING_FIRST_WANT;
    assert(first_want || transport->stage == SENDING_ADDITIONAL_WANT);
    send_flush_pkt(transport);
    // If no wants are requested, the transport is terminated
    transport->stage = first_want ? TRANSPORT_DONE : SENDING_HAVES;
}

void send_have(transport_t *transport, const object_hash_t hash) {
    assert(transport->stage == SENDING_HAVES);
    char line[strlen(HAVE) + strlen(hash) + 1];
    strcpy(line, HAVE);
    strcat(line, hash);
    write_pkt_line_string(transport, line);
}

bool check_have_acks(transport_t *transport, ack_receiver_t receiver, void *aux) {
    // This shouldn't be called once a "ready" status has been sent
    assert(transport->stage == SENDING_HAVES);
    send_flush_pkt(transport);
    bool ready = false;
    while (true) {
        // Read server ACK lines until a NAK is received
        char *line = read_pkt_line_string(transport);
        assert(line != NULL);
        if (!strcmp(line, NAK)) {
            free(line);
            break;
        }

        // Expect an ACK
        if (!starts_with(line, ACK)) {
            fprintf(stderr, "Invalid ACK/NAK response: %s\n", line);
            assert(false);
        }
        // `line` looks like "ACK 7e47fe2bd8d01d481f44d7af0531bd93d3b21c01 common"
        char *hash = line + strlen(ACK);
        char *status = strchr(hash, ' ');
        if (status == NULL) {
            fprintf(stderr, "ACK status missing: %s\n", line);
            assert(false);
        }
        status++; // skip over the space
        if (!strcmp(status, READY)) ready = true;
        else if (!strcmp(status, COMMON)) {
            status[-1] = '\0'; // null-terminate the hash
            receiver(hash, aux);
        }
        else {
            fprintf(stderr, "Unexpected ACK status: %s\n", status);
            assert(false);
        }
        free(line);
    }
    if (ready) transport->stage = SENDING_HAVES_READY;
    return ready;
}

void finish_haves(transport_t *transport) {
    // TODO: assert that all sent haves have been checked
    assert(transport->stage == SENDING_HAVES || transport->stage == SENDING_HAVES_READY);
    write_pkt_line_string(transport, DONE);
    // Server responds with either an ACK or a NAK, which we can ignore
    char *line = read_pkt_line_string(transport);
    assert(line != NULL);
    assert(starts_with(line, ACK) || !strcmp(line, NAK));
    free(line);
    transport->stage = RECEIVING_PACK;
}

// The state of decoding a PACK file
typedef enum {
    // Reading the 4-byte "PACK" signature
    SIGNATURE,
    // Reading the 32-bit version number
    VERSION,
    // Reading the 32-bit object count
    OBJECT_COUNT,
    // Reading the objects
    OBJECTS,
    // Verifying the SHA1 hash
    VERIFY_SHA,
    // Done processing PACK file
    FINISHED
} pack_read_stage_t;
typedef struct {
    uint8_t bytes[PACK_SIGNATURE_LENGTH];
    size_t bytes_read;
} signature_state_t;
typedef struct {
    uint8_t bytes[PACK_VERSION_LENGTH];
    size_t bytes_read;
} version_state_t;
typedef struct {
    uint8_t bytes[PACK_OBJECT_COUNT_LENGTH];
    size_t bytes_read;
} object_count_state_t;
typedef struct {
    // The number of objects remaining to be read
    size_t objects;
    // Whether reading the type byte; whether reading additional length bytes
    bool reading_type, reading_length;
    // The type of the current object
    object_type_t type;
    // The hash of the base object, for `OBJ_REF_DELTA`
    uint8_t base_hash[HASH_BYTES];
    // The number of hash bytes read so far
    size_t hash_bytes_read;
    // The size of the inflated object
    size_t inflated_length;
    // The number of bits of the inflate length read so far
    uint8_t inflated_length_bits;
    // The heap-allocated inflated data
    uint8_t *inflated;
    // A reusable DEFLATE decompression stream
    z_stream stream;
} objects_state_t;
typedef struct {
    uint8_t bytes[HASH_BYTES];
    size_t bytes_read;
} verify_sha_state_t;
typedef struct {
    // A tagged union of the PACK file read state
    pack_read_stage_t stage;
    union {
        signature_state_t signature_state;
        version_state_t version_state;
        object_count_state_t object_count_state;
        objects_state_t objects_state;
        verify_sha_state_t verify_sha_state;
    };

    // Object callback function and auxiliary parameter
    object_receiver_t receiver;
    void *aux;

    // The current chunk of the PACK file being read.
    // The file can be split arbitrarily into chunks.
    const uint8_t *chunk;
    // The number of bytes remaining in the current chunk
    size_t length;

    // Total bytes of the PACK file read
    size_t bytes_read;
    // Current SHA-1 state of the PACK file
    SHA_CTX sha1;
} pack_read_state_t;

bool read_bytes(
    pack_read_state_t *state,
    uint8_t *destination,
    size_t *bytes_read,
    size_t max_length,
    bool hash
) {
    size_t remaining_bytes = max_length - *bytes_read;
    if (state->length < remaining_bytes) remaining_bytes = state->length;
    memcpy(destination + *bytes_read, state->chunk, remaining_bytes);
    if (hash) {
        state->bytes_read += remaining_bytes;
        SHA1_Update(&state->sha1, state->chunk, remaining_bytes);
    }
    state->chunk += remaining_bytes;
    state->length -= remaining_bytes;
    *bytes_read += remaining_bytes;
    return *bytes_read == max_length;
}
uint8_t read_byte(pack_read_state_t *state) {
    uint8_t byte;
    size_t bytes_read = 0;
    read_bytes(state, &byte, &bytes_read, 1, true);
    assert(bytes_read == 1);
    return byte;
}

/**
 * Parses a chunk of a PACK file. May only consume part of the chunk,
 * so must be called repeatedly until state->length becomes 0.
 * Since there are no guarantees how the PACK file will be chunked up,
 * this is basically a big state machine.
 */
void process_pack_chunk(pack_read_state_t *state) {
    assert(state->length > 0);
    switch (state->stage) {
        case SIGNATURE:
            if (read_bytes(
                state,
                state->signature_state.bytes,
                &state->signature_state.bytes_read,
                PACK_SIGNATURE_LENGTH,
                true
            )) {
                // PACK file should start with "PACK"
                assert(!memcmp(
                    state->signature_state.bytes,
                    PACK_SIGNATURE,
                    PACK_SIGNATURE_LENGTH
                ));
                state->stage++;
                state->version_state.bytes_read = 0;
            }
            break;

        case VERSION:
            if (read_bytes(
                state,
                state->version_state.bytes,
                &state->version_state.bytes_read,
                PACK_VERSION_LENGTH,
                true
            )) {
                // Version should be 2
                size_t version = read_be(state->version_state.bytes, PACK_VERSION_LENGTH);
                if (version != PACK_VERSION) {
                    fprintf(stderr, "Unknown pack version: %zu\n", version);
                    assert(false);
                }
                state->stage++;
                state->object_count_state.bytes_read = 0;
            }
            break;

        case OBJECT_COUNT:
            if (read_bytes(
                state,
                state->object_count_state.bytes,
                &state->object_count_state.bytes_read,
                PACK_OBJECT_COUNT_LENGTH,
                true
            )) {
                // Compute how many objects need to be read
                // and initialize the objects read state
                state->stage++;
                state->objects_state.objects =
                    read_be(state->object_count_state.bytes, PACK_OBJECT_COUNT_LENGTH);
                state->objects_state.reading_type = true;
                state->objects_state.inflated = NULL;
                memset(&state->objects_state.stream, 0, sizeof(z_stream));
                int result = inflateInit(&state->objects_state.stream);
                assert(result == Z_OK);
            }
            break;

        case OBJECTS:
            // If done reading objects, clean up the zlib stream
            if (state->objects_state.objects == 0) {
                int result = inflateEnd(&state->objects_state.stream);
                assert(result == Z_OK);
                state->stage++;
                state->verify_sha_state.bytes_read = 0;
                break;
            }

            if (state->objects_state.reading_type) {
                // The first byte read contains the object type
                // and 4 bits of the inflated length
                uint8_t byte = read_byte(state);
                state->objects_state.reading_type = false;
                state->objects_state.reading_length = byte >> 7;
                object_type_t type = byte >> 4 & 0b111;
                assert( // ensure this object type can be handled
                    type == COMMIT || type == TREE || type == BLOB ||
                    type == OBJ_REF_DELTA
                );
                state->objects_state.type = type;
                state->objects_state.hash_bytes_read = 0; // only used for OBJ_REF_DELTA
                state->objects_state.inflated_length = byte & 0b1111;
                state->objects_state.inflated_length_bits = 4;
            }
            else if (state->objects_state.reading_length) {
                // Subsequent bytes (while the high bit is 1)
                // contain the next 7 bits of the inflated length
                uint8_t byte = read_byte(state);
                state->objects_state.reading_length = byte >> 7;
                state->objects_state.inflated_length |=
                    (byte & 0b1111111) << state->objects_state.inflated_length_bits;
                state->objects_state.inflated_length_bits += 7;
            }
            else {
                if (state->objects_state.type == OBJ_REF_DELTA) {
                    // OBJ_REF_DELTA objects have a 20-byte hash before the DEFLATE data
                    read_bytes(
                        state,
                        state->objects_state.base_hash,
                        &state->objects_state.hash_bytes_read,
                        HASH_BYTES,
                        true
                    );
                    if (state->length == 0) break;
                }

                if (state->objects_state.inflated == NULL) {
                    // Reached the DEFLATE stream, so allocate space for the object
                    state->objects_state.inflated =
                    state->objects_state.stream.next_out =
                        malloc(state->objects_state.inflated_length);
                    assert(state->objects_state.inflated != NULL);
                    state->objects_state.stream.avail_out =
                        state->objects_state.inflated_length;
                }

                // Use zlib to inflate the object data.
                // The DEFLATE format indicates the end of the object data.
                state->objects_state.stream.next_in = state->chunk;
                state->objects_state.stream.avail_in = state->length;
                int result = inflate(&state->objects_state.stream, Z_FINISH);
                // Hash the consumed bytes
                size_t deflated_length =
                    state->objects_state.stream.next_in - state->chunk;
                state->bytes_read += deflated_length;
                SHA1_Update(&state->sha1, state->chunk, deflated_length);
                // Move to the unconsumed remainder of the chunk
                state->chunk = state->objects_state.stream.next_in;
                state->length = state->objects_state.stream.avail_in;
                if (result == Z_STREAM_END) {
                    // Reached the end of the DEFLATE stream.
                    // Check that all inflated_length bytes were read.
                    assert(state->objects_state.stream.avail_out == 0);
                    object_hash_t base_hash;
                    if (state->objects_state.type == OBJ_REF_DELTA) {
                        // If this is an OBJ_REF_DELTA object,
                        // convert the base object hash to hexadecimal
                        hash_to_hex(state->objects_state.base_hash, base_hash);
                    }
                    // Call the callback with the inflated object
                    state->receiver(
                        state->objects_state.type,
                        state->objects_state.type == OBJ_REF_DELTA ? base_hash : NULL,
                        state->objects_state.inflated,
                        state->objects_state.inflated_length,
                        state->aux
                    );
                    // Reset state for next object
                    state->objects_state.objects--;
                    state->objects_state.reading_type = true;
                    state->objects_state.inflated = NULL;
                    result = inflateReset(&state->objects_state.stream);
                    assert(result == Z_OK);
                }
                else {
                    // Didn't finish the DEFLATE stream; the rest is in future chunks.
                    // Result can be Z_BUF_ERROR is some deflated bytes were read,
                    // but not enough to generate more bytes of output.
                    assert(result == Z_OK || result == Z_BUF_ERROR);
                    assert(state->length == 0);
                }
            }
            break;

        case VERIFY_SHA:
            // Compute the SHA-1 hash of the PACK file and check that it matches
            if (read_bytes(
                state,
                state->verify_sha_state.bytes,
                &state->verify_sha_state.bytes_read,
                HASH_BYTES,
                false
            )) {
                uint8_t actual_hash[HASH_BYTES];
                SHA1_Final(actual_hash, &state->sha1);
                if (memcmp(actual_hash, state->verify_sha_state.bytes, HASH_BYTES)) {
                    fprintf(stderr, "SHA1 hash check of pack file failed\n");
                    assert(false);
                }
                state->stage++;
            }
            break;

        default:
            fprintf(stderr, "Invalid pack stage: %d\n", state->stage);
            assert(false);
    }
}

void receive_pack(transport_t *transport, object_receiver_t receiver, void *aux) {
    assert(transport->stage == RECEIVING_PACK);
    pack_read_state_t state = {
        .stage = SIGNATURE,
        .signature_state = {.bytes_read = 0},
        .receiver = receiver,
        .aux = aux,
        .bytes_read = 0
    };
    SHA1_Init(&state.sha1);

    // Read until the flush-pkt after the end of the PACK file
    size_t line_length;
    uint8_t *line;
    while ((line = read_pkt_line(transport, &line_length)) != NULL) {
        stream_code_t stream_code = line[0];
        line_length--;
        uint8_t *data = line + 1;
        if (stream_code == PACK) {
            // Run the full chunk through the PACK file reader
            state.chunk = data;
            state.length = line_length;
            while (state.length > 0) process_pack_chunk(&state);
        }
        else if (stream_code == PROGRESS || stream_code == ERROR) {
            // TIL the protocol actually sends the messages to print to the terminal,
            // e.g. "Counting objects: 100% (3/3), done."
            if (stream_code == ERROR) fprintf(stderr, "Fatal error: ");
            fprintf(stderr, "%.*s", (int) line_length, (char *) data);
        }
        else {
            fprintf(stderr, "Unrecognized stream code: %d\n", stream_code);
            assert(false);
        }

        free(line);
    }

    assert(state.stage == FINISHED);
    transport->stage = TRANSPORT_DONE;
}

void send_update(
    transport_t *transport,
    const char *ref,
    const object_hash_t old_hash,
    const object_hash_t new_hash
) {
    bool first_update = transport->stage == SENDING_FIRST_UPDATE;
    assert(first_update || transport->stage == SENDING_ADDITIONAL_UPDATE);
    size_t line_length =
        HASH_STRING_LENGTH + 1 + HASH_STRING_LENGTH + 1 + strlen(ref) + 1;
    if (first_update) line_length += strlen(PUSH_CAPABILTIIES) + 1;
    // An old hash of 0 indicates a creation; a new hash of 0 indicates a deletion
    char line[line_length];
    strcpy(line, old_hash == NULL ? ZERO_HASH : old_hash);
    strcat(line, " ");
    strcat(line, new_hash == NULL ? ZERO_HASH : new_hash);
    strcat(line, " ");
    strcat(line, ref);
    if (first_update) strcpy(line + strlen(line) + 1, PUSH_CAPABILTIIES);
    // Can't use write_pkt_line_string() since there is a '\0' in the string
    write_pkt_line(transport, line, sizeof(char[line_length - 1]), true);
    transport->stage = SENDING_ADDITIONAL_UPDATE;
    if (new_hash != NULL) transport->needs_pack = true;
}

void finish_updates(transport_t *transport) {
    bool first_update = transport->stage == SENDING_FIRST_UPDATE;
    assert(first_update || transport->stage == SENDING_ADDITIONAL_UPDATE);
    send_flush_pkt(transport);
    transport->stage = first_update
        ? TRANSPORT_DONE
        : transport->needs_pack ? SENDING_PACK_HEADER : CHECKING_UPDATES;
}

void write_pack(transport_t *transport, const uint8_t *data, size_t length) {
    pack_state_t *pack_state = transport->pack_state;
    ssize_t written = write(transport->ssh_write_fd, data, length);
    assert(written == (ssize_t) length);
    SHA1_Update(&pack_state->sha1, data, length);
}

void start_pack(transport_t *transport, size_t object_count) {
    assert(transport->stage == SENDING_PACK_HEADER);
    transport->pack_state = malloc(sizeof(pack_state_t));
    assert(transport->pack_state != NULL);
    SHA1_Init(&transport->pack_state->sha1);
    write_pack(transport, PACK_SIGNATURE, PACK_SIGNATURE_LENGTH);
    uint8_t version_bytes[PACK_SIGNATURE_LENGTH];
    write_be(PACK_VERSION, version_bytes, PACK_VERSION_LENGTH);
    write_pack(transport, version_bytes, PACK_VERSION_LENGTH);
    uint8_t object_count_bytes[PACK_OBJECT_COUNT_LENGTH];
    write_be(object_count, object_count_bytes, PACK_OBJECT_COUNT_LENGTH);
    write_pack(transport, object_count_bytes, PACK_OBJECT_COUNT_LENGTH);

    memset(&transport->pack_state->stream, 0, sizeof(z_stream));
    int result = deflateInit(&transport->pack_state->stream, Z_DEFAULT_COMPRESSION);
    assert(result == Z_OK);
    transport->stage = SENDING_PACK_OBJECTS;
}

void send_pack_object(
    transport_t *transport,
    object_type_t type,
    const uint8_t *contents,
    size_t length
) {
    // TODO: produce OBJ_REF_DELTA for blobs and trees
    assert(type == COMMIT || type == TREE || type == BLOB);
    assert(transport->stage == SENDING_PACK_OBJECTS);

    // The first byte contains the type and 4 bits of the length
    uint8_t byte = type << 4 | (length & 0b1111);
    size_t remaining_length = length >> 4;
    // The next bytes contain 7 bits of the length each
    while (true) {
        bool more_bytes = remaining_length > 0;
        byte |= more_bytes << 7;
        write_pack(transport, &byte, 1);
        if (!more_bytes) break;

        byte = remaining_length & 0b1111111;
        remaining_length >>= 7;
    }

    // Compress the object to a DEFLATE stream
    uint8_t deflate_chunk[PUSH_DEFLATE_CHUNK_SIZE];
    z_stream *stream = &transport->pack_state->stream;
    stream->next_in = contents;
    stream->avail_in = length;
    int result;
    while (stream->avail_in > 0) {
        stream->next_out = deflate_chunk;
        stream->avail_out = PUSH_DEFLATE_CHUNK_SIZE;
        result = deflate(stream, Z_NO_FLUSH);
        assert(result == Z_OK);
        write_pack(transport, deflate_chunk, stream->next_out - deflate_chunk);
    }
    while (result != Z_STREAM_END) {
        stream->next_out = deflate_chunk;
        stream->avail_out = PUSH_DEFLATE_CHUNK_SIZE;
        result = deflate(stream, Z_FINISH);
        assert(result == Z_OK || result == Z_STREAM_END);
        write_pack(transport, deflate_chunk, stream->next_out - deflate_chunk);
    }
    result = deflateReset(stream);
    assert(result == Z_OK);
}

void finish_pack(transport_t *transport) {
    assert(transport->stage == SENDING_PACK_OBJECTS);
    // Send hash to terminate PACK file
    pack_state_t *pack_state = transport->pack_state;
    uint8_t hash[HASH_BYTES];
    SHA1_Final(hash, &pack_state->sha1);
    write_pack(transport, hash, HASH_BYTES);
    // Close pack state
    int result = deflateEnd(&pack_state->stream);
    assert(result == Z_OK);
    free(pack_state);

    // Check that unpack was successful
    char *line = read_pkt_line_string(transport);
    assert(line != NULL);
    assert(starts_with(line, UNPACK));
    char *unpack_message = line + strlen(UNPACK);
    if (strcmp(unpack_message, UNPACK_OK)) {
        fprintf(stderr, "Unpack error: %s\n", unpack_message);
        assert(false);
    }
    free(line);
    transport->stage = CHECKING_UPDATES;
}

void check_updates(transport_t *transport, updated_ref_receiver_t receiver, void *aux) {
    assert(transport->stage == CHECKING_UPDATES);
    char *line;
    while ((line = read_pkt_line_string(transport)) != NULL) {
        bool success = starts_with(line, REF_OK);
        assert(success || starts_with(line, REF_NOT_GOOD));
        char *ref = line + strlen(success ? REF_OK : REF_NOT_GOOD);
        if (success) receiver(ref, aux);
        else {
            char *ref_end = strchr(ref, ' ');
            assert(ref_end != NULL);
            *ref_end = '\0';
            fprintf(stderr, "Error updating ref %s: %s\n", ref, ref_end + 1);
        }
        free(line);
    }
    transport->stage = TRANSPORT_DONE;
}

filename: util.c

contents: 
 #include "util.h"
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <stdlib.h>

#include "index_io.h"
#include "object_io.h"
#include "ref_io.h"

#include "linked_list.h"
#include "hash_table.h"
#include "util.h"

#include "config_io.h"
#include <ctype.h>

uint8_t from_octal(char c) {
    if (!('0' <= c && c <= '7')) {
        fprintf(stderr, "Invalid octal character: %c\n", c);
        assert(false);
    }

    return c - '0';
}
uint8_t from_decimal(char c) {
    if (!('0' <= c && c <= '9')) {
        fprintf(stderr, "Invalid decimal character: %c\n", c);
        assert(false);
    }

    return c - '0';
}
uint8_t from_hex(char c) {
    if ('0' <= c && c <= '9') return c - '0';
    if ('a' <= c && c <= 'f') return 10 + c - 'a';

    fprintf(stderr, "Invalid hex character: '%c'\n", c);
    assert(false);
}

char to_hex(uint8_t value) {
    if (value < 10) return '0' + value;
    if (value < 16) return 'a' + value - 10;

    fprintf(stderr, "Invalid hex value: '%u'\n", value);
    assert(false);
}

void hash_to_hex(const uint8_t hash_bytes[HASH_BYTES], object_hash_t hash_string) {
    for (size_t i = 0; i < HASH_BYTES; i++) {
        hash_string[i * 2] = to_hex(hash_bytes[i] >> 4);
        hash_string[i * 2 + 1] = to_hex(hash_bytes[i] & 0xF);
    }
    hash_string[HASH_STRING_LENGTH] = '\0';
}

void hex_to_hash(const object_hash_t hash_string, uint8_t hash_bytes[HASH_BYTES]) {
    for (size_t i = 0; i < HASH_BYTES; i++) {
        hash_bytes[i] = from_hex(hash_string[i * 2]) << 4 |
                        from_hex(hash_string[i * 2 + 1]);
    }
}

size_t read_be(const uint8_t *bytes, size_t length) {
    size_t value = 0;
    while (length-- > 0) value = value << 8 | *(bytes++);
    return value;
}

void write_be(size_t value, uint8_t *bytes, size_t length) {
    while (length-- > 0) {
        bytes[length] = value;
        value >>= 8;
    }
    // Ensure that the entire value fit in the bytes
    assert(value == 0);
}

bool starts_with(const char *string, const char *prefix) {
    return !strncmp(string, prefix, strlen(prefix));
}

void make_dirs(char *path) {
    char *next = path;
    while ((next = strchr(next, '/')) != NULL) {
        *next = '\0';
        mkdir(path, 0755);
        *next = '/';
        next++;
    }
}
void make_parent_dirs(char *path) {
    char *file_start = strrchr(path, '/');
    if (file_start == NULL) return;

    // we want to include the trailing slash so make_dirs works properly
    // TODO: Not sure why these methods are separate to be honest
    file_start++; // safe, moves to null terminator in worst case
    char old_file_start = *file_start;
    *file_start = '\0';
    make_dirs(path);
    *file_start = old_file_start;
}

size_t get_file_size(FILE *f) {
    fseek(f, 0, SEEK_END);
    size_t size = ftell(f);
    rewind(f);
    return size;
}


char *get_file_contents(const char *file_path) {
    FILE *file = fopen(file_path, "rb");
    if (file == NULL) {
        // printf("Failed to open file");
        return NULL;
    }

    // Get the size of the file
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    fseek(file, 0, SEEK_SET);


    // Allocate a buffer to hold the file contents
    char *buffer = malloc(file_size + 1);
    if (buffer == NULL) {
        perror("Failed to allocate memory");
        fclose(file);
        return NULL;
    }

    // Read the file into the buffer
    size_t bytes_read = fread(buffer, 1, file_size, file);
    if (bytes_read < (size_t) file_size) {
        // perror("Failed to read file");
        free(buffer);
        fclose(file);
        return NULL;
    }

    // Null-terminate the buffer
    buffer[file_size] = '\0';

    fclose(file);
    return buffer;
}


void expand_tree(object_hash_t tree_hash, hash_table_t* hash_table, char *curr_chars){
    // TODO: make not recursive cuz maybe they have a stack overflow
    tree_t *tree = read_tree(tree_hash);  // Call the read_tree function
    // printf("uhhhh\n");
    //lalallalalla

    for (size_t i = 0; i < tree->entry_count; i++) {
        tree_entry_t *entry = &tree->entries[i];
        if (entry->mode == MODE_DIRECTORY){
            // it's another tree object
            char *path = malloc(sizeof(char) * (strlen(entry->name) + strlen(curr_chars) + 2));
            strcpy(path, curr_chars);
            strcat(path, entry->name);
            strcat(path, "/");
            // printf("path: %s\n", path);
            // printf("TREE HASH: %s\n", entry->hash);
            expand_tree(entry->hash, hash_table, path);
            free(path);

        } else {
            char *path = malloc(sizeof(char) * (strlen(entry->name) + strlen(curr_chars) + 1));
            strcpy(path, curr_chars);
            strcat(path, entry->name);
            char *hash_copy = strdup(entry->hash);
            if (hash_copy == NULL) {
                // Handle error
            } else {
                hash_table_add(hash_table, path, hash_copy);
            }
            free(path);
        }
    }
    free_tree(tree);
}


bool is_valid_commit_hash(const char *hash) {
    // Check if the hash is 40 characters long
    if (strlen(hash) != 40) {
        return false;
    }

    // Check if all characters are hexadecimal
    for (int i = 0; i < 40; i++) {
        if (!isxdigit(hash[i])) {
            return false;
        }
    }

    return true;
}
    

char *get_url(config_section_t *remote) {
    for (size_t i = 0; i < remote->property_count; i++) {
        config_property_t property = remote->properties[i];
        if (strcmp(property.key, "url") == 0) {
            char *url = malloc(strlen(property.value) + 1);
            if (url == NULL) {
                fprintf(stderr, "Failed to allocate memory for URL.\n");
                return NULL;
            }
            strcpy(url, property.value);
            return url;
        }
    }
    return NULL;
}

char **split_path_into_directories(char *path) {
    // Count the number of directories in the path
    int count = 0;
    for (int i = 0; path[i]; i++) {
        if (path[i] == '/') {
            count++;
        }
    }

    // Allocate memory for the array of directory names
    char **directories = malloc((count + 2) * sizeof(char *));
    if (directories == NULL) {
        fprintf(stderr, "Failed to allocate memory.\n");
        return NULL;
    }

    // Split the path into directory names
    int index = 0;
    char *token = strtok(path, "/");
    while (token != NULL) {
        directories[index] = token;
        token = strtok(NULL, "/");
        index++;
    }
    directories[index] = NULL;  // Null-terminate the array

    return directories;
}

char *get_last_dir(char *file_dir_name){

    char * full_name = strdup(file_dir_name);     
    char ** full_name_splitted= split_path_into_directories(full_name);
    int count = 0;

    while (full_name_splitted[count] != NULL) {
        count++;
    }
    char *last_dir;
    if (count != 0){
        last_dir = strdup(full_name_splitted[count-1]);
    } else {
        last_dir = strdup(full_name);
    }
    free(full_name_splitted);
    free(full_name);
    return last_dir;
}


filename: writer.c

contents: 
 #include "add.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "index_io.h"
#include "object_io.h"
#include "util.h"
#include <sys/stat.h>


#include <string.h>
#include <unistd.h>



struct list_node {
   list_node_t *next;
   void *value;
};
struct linked_list {
    list_node_t *head;
    list_node_t **tail;
};
//

typedef struct index_header_t{
    char signature[4];
    uint32_t version_number;
    uint32_t number_of_entries;
}index_header_t;

typedef struct index_entry_full_t{
    uint32_t ctime_seconds;
    uint32_t ctime_nanoseconds;
    uint32_t mtime_seconds;
    uint32_t mtime_nanoseconds;
    uint32_t dev;
    uint32_t ino;
    // mode consists of unused (16 bits), object type (4 bits),
    // unused (3 bits), and UNIX perms (9 bits 0644 nonexecuteable, 0755 executeable)
    uint32_t mode;
    uint32_t uid;
    uint32_t gid;
    uint32_t file_size;
    char sha1_hash[HASH_BYTES];
    
    uint16_t flags;

    char *file_name;
    char null_byte;
}index_entry_full_t;

uint16_t get_flags(uint32_t fsize){
    if (fsize >= 0xfff){
        return 0xfff;
    }
    return (uint16_t) fsize;
}

index_entry_full_t *make_full_index_entry(index_entry_t *index_entry_temp){
    index_entry_full_t *index_entry = malloc(sizeof(index_entry_full_t));

    index_entry->ctime_seconds = 0;
    index_entry->ctime_nanoseconds = 0;

    struct stat file_stat;
    bool executable = false;
    // TODO: Should this be recalculated???
    if (stat(index_entry_temp->fname, &file_stat) == 0) {
        index_entry->mtime_seconds = (uint32_t)file_stat.st_mtime;

        if (file_stat.st_mode & S_IXUSR || file_stat.st_mode & S_IXGRP || file_stat.st_mode & S_IXOTH) {
            executable = true;
        } else {
            executable = false;
        }
    } else {
        // Handle error
        printf("something wrong with stat");
    }

    index_entry->mtime_nanoseconds = 0;
    index_entry->dev = 0;
    index_entry->ino = 0;
    
    index_entry->mode = 0b10000000000000000000000000000000;

    if (executable){
        index_entry->mode += 0b00000000000000000000000000000000110100100;
    } else {
        index_entry->mode += 0b00000000000000000000000000000000111101101;
    }
    
    index_entry->uid = 0;
    index_entry->gid = 0;

    index_entry->file_size = index_entry_temp->size;

    // copy the sha1 hash and file_name
    // index_entry->sha1_hash = malloc(sizeof(char) * HASH_BYTES);

    memcpy(index_entry->sha1_hash, index_entry_temp->sha1, HASH_BYTES);

    index_entry->flags = get_flags(index_entry_temp->fname_length);
    index_entry->file_name = malloc(sizeof(char)*(index_entry_temp->fname_length + 1));
    strncpy(index_entry->file_name, index_entry_temp->fname, index_entry_temp->fname_length);
    index_entry->file_name[index_entry_temp->fname_length] = '\0';

    index_entry->null_byte = '\0';

    return index_entry;
}

void free_full_index_entry(index_entry_full_t *index_entry){
    free(index_entry->file_name);
    free(index_entry);
}

size_t get_index_size(index_entry_full_t *index_entry){
    // Account for the fact that it's a char pointer, and we just store the 
    size_t index_size =  sizeof(index_entry_full_t) - sizeof(char *) - 
    sizeof(size_t) + strlen(index_entry->file_name);
    
    size_t padding;
    if (index_size % 8 == 0){
        padding = 0;
    } else {
        padding = 8 - (index_size % 8);
    }
    return index_size + padding;
}


void write_index(FILE *f, index_entry_full_t *index_entry){
    size_t index_size = get_index_size(index_entry);

    fwrite(&index_entry->ctime_seconds, sizeof(uint32_t), 1, f);
    fwrite(&index_entry->ctime_nanoseconds, sizeof(uint32_t), 1, f);

    uint8_t mtime_seconds[4];
    printf("mtime: %u", index_entry->mtime_seconds);
    write_be(index_entry->mtime_seconds, mtime_seconds, 4);
    fwrite(&mtime_seconds, sizeof(uint32_t), 1, f);

    fwrite(&index_entry->mtime_nanoseconds, sizeof(uint32_t), 1, f);

    fwrite(&index_entry->dev, sizeof(uint32_t), 1, f);
    fwrite(&index_entry->ino, sizeof(uint32_t), 1, f);

    uint8_t mode[4];
    write_be(index_entry->mode, mode, 4);
    fwrite(&mode, sizeof(uint32_t), 1, f);
    
    // fwrite(&index_entry->mode, sizeof(uint32_t), 1, f);
    fwrite(&index_entry->uid, sizeof(uint32_t), 1, f);
    fwrite(&index_entry->gid, sizeof(uint32_t), 1, f);

    uint8_t file_size[4];
    write_be(index_entry->file_size, file_size, 4);
    fwrite(&file_size, sizeof(uint32_t), 1, f);

    // fwrite(&index_entry->file_size, sizeof(uint32_t), 1, f);
    
    uint8_t sha1_hash[HASH_BYTES];
    write_be(index_entry->sha1_hash, sha1_hash, HASH_BYTES);
    fwrite(&sha1_hash, sizeof(char), HASH_BYTES, f);

    // fwrite(&index_entry->sha1_hash, sizeof(char), HASH_BYTES, f);

    uint8_t flags[2];
    write_be(index_entry->flags, flags, 2);
    // fwrite(&flags, sizeof(char), HASH_BYTES, f);
    fwrite(&flags, sizeof(uint16_t), 1, f);


    // fwrite(index_entry->file_name, sizeof(char), strlen(index_entry->file_name), f);

}

index_entry_t *make_index_entry(size_t size, object_hash_t sha1, char *fname, uint32_t fname_length, time_t mtime){
    index_entry_t *index_entry = malloc(sizeof(index_entry_t));
    index_entry->size = size;
    // need to copy the sha1 hash
    memcpy(index_entry->sha1, sha1, sizeof(object_hash_t));
    strncpy(index_entry->fname, fname, fname_length);
    index_entry->fname[fname_length] = '\0';
    index_entry->mtime = mtime;
    return index_entry;
}


char *get_contents(const char *file_path){
    FILE *file = fopen(file_path, "rb");
    if (file == NULL){
        perror("Could not open file");
    }

    // Get the size of the file
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    fseek(file, 0, SEEK_SET);

    char *buffer = malloc(file_size);
    if (buffer == NULL) {
        fprintf(stderr, "Failed to allocate memory\n");
        fclose(file);
    }

    size_t bytes_read = fread(buffer, 1, file_size, file);
    if (bytes_read < (size_t) file_size) {
        fprintf(stderr, "Failed to read file %s\n", file_path);
        free(buffer);
        fclose(file);
    }

    fclose(file);

    return buffer;
}

void write_index_header(FILE *f, uint32_t num_entries){
    // for the null character
    fwrite("DIRC", sizeof(char), 4, f);
    uint32_t version_number = 2;
    uint8_t bytes[4];
    write_be(version_number, bytes, 4);
    fwrite(&bytes, sizeof(uint32_t), 1, f);

    uint8_t num_entry_bytes[4];
    write_be(num_entries, num_entry_bytes, 4);
    fwrite(&num_entry_bytes, sizeof(uint32_t), 1, f);
}


uint32_t get_idx_file_cnts(const char **file_paths, size_t file_count, hash_table_t *index_table){
    uint32_t index_file_cnts = hash_table_size(index_table);
    for (size_t i=0; i < file_count; i++){
        const char *file_path = file_paths[i];
        printf("filename: %s\n", file_path);
        // hash_table_add(index_table, file_path, "bruh");
        if (hash_table_contains(index_table, file_path)){
            printf("table contains %s", file_path);
            if (access(file_path, F_OK) == -1){
                // file was deleted
                printf("not here\n");
                index_file_cnts--;
            } else{
                // file is still there
                printf("its here\n");
                index_file_cnts++;
            }
        }
    }
    return index_file_cnts;
}



void add_files(const char **file_paths, size_t file_count)
{
    index_file_t * index_file = read_index_file();

    hash_table_t *index_table = index_file->entries;


    uint32_t index_cnts = get_idx_file_cnts(file_paths, file_count, index_table);
    printf("index_cnts: %u\n", index_cnts);
    FILE *new_index_file = fopen("temp_idx_file", "wb");

    write_index_header(new_index_file, index_cnts);


    uint32_t index_file_cnts = hash_table_size(index_table);
    for (size_t i=0; i < file_count; i++){
        const char *file_path = file_paths[i];
        printf("filename: %s\n", file_path);
        // hash_table_add(index_table, file_path, "bruh");
        if (hash_table_contains(index_table, file_path)){
            if (access(file_path, F_OK) == -1){
                // file was deleted
                printf("not here\n");
                index_file_cnts--;
            } else{
                // file is still there
                printf("its here\n");
                index_file_cnts++;
                index_entry_full_t *full_idx = (hash_table_get(index_table, file_path));

                char *file_contents = get_file_contents(file_path);

                write_index(new_index_file, full_idx);

                object_hash_t hash;
                write_object(BLOB, file_contents, strlen(file_contents), hash);
            }
        } else {
            // new file
            if (access(file_path, F_OK) == -1){
                // file was deleted
                printf("not here\n");
                index_file_cnts--;
            } else{

                char *file_contents = get_file_contents(file_path);

                object_hash_t hash;
                write_object(BLOB, file_contents, strlen(file_contents), hash);
            }
        }
    }

    printf("yoooo what is up guys\n");
    
    exit(1);
}

filename: yoooo

contents: 
 vvvv>
filename: temp2

contents: 
 bbbï¿½>
filename: temp3

contents: 
 `ï¿½ï¿½>
filename: temp_idx_file

contents: 
 DIRC
filename: temp_idx_file2

contents: 
 DIRC
filename: temp_lolski

contents: 
 version: 2
n_entries: 44
hash ec17f0ef9a3c55b1cb1be43f838d8a8b06fecf43
file:.gitignore
size:29
sha1:ec17f0ef9a3c55b1cb1be43f838d8a8b06fecf43
mtime:1714454921
stage:0

padding length: 7
hash 2b1eecb1823083550dc3205773d6761fb847d58a
file:.gitlab-ci.yml
size:104
sha1:2b1eecb1823083550dc3205773d6761fb847d58a
mtime:1714454921
stage:0

padding length: 3
hash fd1b7e93724b52179d5db87a206d3142ebb5ac01
file:Makefile
size:784
sha1:fd1b7e93724b52179d5db87a206d3142ebb5ac01
mtime:1714939867
stage:0

padding length: 1
hash e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
file:bin/.gitkeep
size:0
sha1:e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
mtime:1714454921
stage:0

padding length: 5
hash 642353c2b4c4b5a1dec697d11eb18d96e152343c
file:expand-all-packfiles
size:777
sha1:642353c2b4c4b5a1dec697d11eb18d96e152343c
mtime:1714894412
stage:0

padding length: 5
hash 661e87d55a4c835c68ec92594c4c0a5c36595813
file:include/add.h
size:183
sha1:661e87d55a4c835c68ec92594c4c0a5c36595813
mtime:1714889262
stage:0

padding length: 4
hash b950eeae8aea44e7eb85c11dfcdcb0904c8b90bd
file:include/checkout.h
size:137
sha1:b950eeae8aea44e7eb85c11dfcdcb0904c8b90bd
mtime:1714454921
stage:0

padding length: 7
hash 979cc48faea9e8407f4858d69b37239c7a509066
file:include/commit.h
size:90
sha1:979cc48faea9e8407f4858d69b37239c7a509066
mtime:1714454921
stage:0

padding length: 1
hash 21dc5a14662beb2212e6721db17d95adae367185
file:include/config_io.h
size:1298
sha1:21dc5a14662beb2212e6721db17d95adae367185
mtime:1714454921
stage:0

padding length: 6
hash a5b8e44f9eba70b73bdcd4d34ac35f49546390fe
file:include/constants.h
size:356
sha1:a5b8e44f9eba70b73bdcd4d34ac35f49546390fe
mtime:1714951235
stage:0

padding length: 6
hash 648f7b51fd6e2d13d00ac0a3f4da4cbc7a461317
file:include/fetch.h
size:126
sha1:648f7b51fd6e2d13d00ac0a3f4da4cbc7a461317
mtime:1714454921
stage:0

padding length: 2
hash 8fd07fb39a8783db3050b9162327f76fdb6364df
file:include/hash_table.h
size:707
sha1:8fd07fb39a8783db3050b9162327f76fdb6364df
mtime:1714895303
stage:0

padding length: 5
hash 676c7e721706e252853d2eae9cd8a79d8793e0d2
file:include/index_io.h
size:604
sha1:676c7e721706e252853d2eae9cd8a79d8793e0d2
mtime:1714944475
stage:0

padding length: 7
hash 28a562e9d8ab2917df07178794d4a6f003b73d5f
file:include/linked_list.h
size:651
sha1:28a562e9d8ab2917df07178794d4a6f003b73d5f
mtime:1714784807
stage:0

padding length: 4
hash 195ae2200c35b38b10e2bae2813c2ed4d68c7f46
file:include/log.h
size:93
sha1:195ae2200c35b38b10e2bae2813c2ed4d68c7f46
mtime:1714454921
stage:0

padding length: 4
hash 6d94a2d89d0699364f438fb595c74daa97f4460c
file:include/object_io.h
size:1483
sha1:6d94a2d89d0699364f438fb595c74daa97f4460c
mtime:1714900462
stage:0

padding length: 6
hash 95db7f58650f75d190ee5f2c9f54ccb34e1014e3
file:include/push.h
size:527
sha1:95db7f58650f75d190ee5f2c9f54ccb34e1014e3
mtime:1714454921
stage:0

padding length: 3
hash c5083f3806b00198d0eba4c66551f2cd1fe36962
file:include/ref_io.h
size:654
sha1:c5083f3806b00198d0eba4c66551f2cd1fe36962
mtime:1714892361
stage:0

padding length: 1
hash 2e7699cc5b1f9debd233cee24b4d014ad94b91b5
file:include/status.h
size:88
sha1:2e7699cc5b1f9debd233cee24b4d014ad94b91b5
mtime:1714454921
stage:0

padding length: 1
hash d2e8378dce98eb67cdaa9b41eb3fac0e0747b336
file:include/transport.h
size:8243
sha1:d2e8378dce98eb67cdaa9b41eb3fac0e0747b336
mtime:1714939654
stage:0

padding length: 6
hash 5f121ca1de30c34f6789ccd7326c127165851dd8
file:include/util.h
size:916
sha1:5f121ca1de30c34f6789ccd7326c127165851dd8
mtime:1714889301
stage:0

padding length: 3
hash e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
file:out/.gitkeep
size:0
sha1:e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
mtime:1714454921
stage:0

padding length: 5
hash 66131a1aec518768b0ca7c48fdac117af63f70aa
file:src/add.c
size:11449
sha1:66131a1aec518768b0ca7c48fdac117af63f70aa
mtime:1714956092
stage:0

padding length: 8
hash c855383c5babedd70eebec59e020c9bc436462ff
file:src/checkout.c
size:232
sha1:c855383c5babedd70eebec59e020c9bc436462ff
mtime:1714454921
stage:0

padding length: 3
hash 74c6e14eb17acceaee8b61b78a4f2aa1d302e6fd
file:src/commit.c
size:384
sha1:74c6e14eb17acceaee8b61b78a4f2aa1d302e6fd
mtime:1714900390
stage:0

padding length: 5
hash b549117398f36f979a65c013363b0157910df31d
file:src/config_io.c
size:10556
sha1:b549117398f36f979a65c013363b0157910df31d
mtime:1714454921
stage:0

padding length: 2
hash c3fb8e67ac0495c613ac3993f24ec7918e8ef4ae
file:src/fetch.c
size:1140
sha1:c3fb8e67ac0495c613ac3993f24ec7918e8ef4ae
mtime:1714454921
stage:0

padding length: 6
hash 75a503923dfa1abed2171ecf296768b2438e6334
file:src/hash_table.c
size:3970
sha1:75a503923dfa1abed2171ecf296768b2438e6334
mtime:1714955394
stage:0

padding length: 1
hash 9b5067475b526c3050f663971d1f0828f0a383db
file:src/index_io.c
size:6502
sha1:9b5067475b526c3050f663971d1f0828f0a383db
mtime:1714956305
stage:0

padding length: 3
hash 27e327a8d2dcebbb9d4e31dd0649b480231c6829
file:src/linked_list.c
size:3554
sha1:27e327a8d2dcebbb9d4e31dd0649b480231c6829
mtime:1714784813
stage:0

padding length: 8
hash 3e3c3cd5093ab5791a6786d4790618ec99fa91bc
file:src/log.c
size:272
sha1:3e3c3cd5093ab5791a6786d4790618ec99fa91bc
mtime:1714454921
stage:0

padding length: 8
hash 32a0fd8c85253a2334d7f74d814bae566b4936ba
file:src/main.c
size:345
sha1:32a0fd8c85253a2334d7f74d814bae566b4936ba
mtime:1714777237
stage:0

padding length: 7
hash 886e85f8561faa5cee803eda7043f22d5403c29e
file:src/main.exe
size:252912
sha1:886e85f8561faa5cee803eda7043f22d5403c29e
mtime:1714777232
stage:0

padding length: 5
hash ae4a7ac7c8292cc9f59a72b7afa1bdf4110b7bdd
file:src/mygit.c
size:7029
sha1:ae4a7ac7c8292cc9f59a72b7afa1bdf4110b7bdd
mtime:1714454921
stage:0

padding length: 6
hash 42f0cbec501fdfc3b3481416f582f1eb9d19852d
file:src/object_io.c
size:16478
sha1:42f0cbec501fdfc3b3481416f582f1eb9d19852d
mtime:1714900885
stage:0

padding length: 2
hash dd3435e5c0e40a967dbef4dd26e8d3b95b7c580f
file:src/push.c
size:479
sha1:dd3435e5c0e40a967dbef4dd26e8d3b95b7c580f
mtime:1714454921
stage:0

padding length: 7
hash 3c14d2b83578aebc9c4d880d70b460e73f55045e
file:src/ref_io.c
size:4803
sha1:3c14d2b83578aebc9c4d880d70b460e73f55045e
mtime:1714890132
stage:0

padding length: 5
hash ef2c8cbf02310504e30bc8a92f4aa2b0834fd991
file:src/status.c
size:7893
sha1:ef2c8cbf02310504e30bc8a92f4aa2b0834fd991
mtime:1714900836
stage:0

padding length: 5
hash 5637785d7573777f1c8360afa212ff8a076dbd08
file:src/transport.c
size:33282
sha1:5637785d7573777f1c8360afa212ff8a076dbd08
mtime:1714454921
stage:0

padding length: 2
hash 3bfb963f6fd9e5b7629c2092c805519bf9a337ba
file:src/util.c
size:3683
sha1:3bfb963f6fd9e5b7629c2092c805519bf9a337ba
mtime:1714954349
stage:0

padding length: 7
hash 68c081c76a5cde5ecfe156821bf184605f2fc8b3
file:src/writer.c
size:9553
sha1:68c081c76a5cde5ecfe156821bf184605f2fc8b3
mtime:1714944309
stage:0

padding length: 5
hash 6f228660950961980e48944cb0e36f10d7cb93f3
file:temp_idx_file
size:3652
sha1:6f228660950961980e48944cb0e36f10d7cb93f3
mtime:1714956377
stage:0

padding length: 4
hash f51850d1a314a61f760e653c1db54a21c2be37f1
file:temp_lolski
size:13438
sha1:f51850d1a314a61f760e653c1db54a21c2be37f1
mtime:1714956377
stage:0

padding length: 6
hash e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
file:testtest
size:0
sha1:e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
mtime:1714895067
stage:0

padding length: 1
file size  29
sha hash  ec17f0ef9a3c55b1cb1be43f838d8a8b06fecf43
file path: .gitignore
mtime: 1714454921
your silly padding; 7
file size  104
sha hash  2b1eecb1823083550dc3205773d6761fb847d58a
file path: .gitlab-ci.yml
mtime: 1714454921
your silly padding; 3
file size  784
sha hash  fd1b7e93724b52179d5db87a206d3142ebb5ac01
file path: Makefile
mtime: 1714939867
your silly padding; 1
file size  0
sha hash  e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
file path: bin/.gitkeep
mtime: 1714454921
your silly padding; 5
file size  777
sha hash  642353c2b4c4b5a1dec697d11eb18d96e152343c
file path: expand-all-packfiles
mtime: 1714894412
your silly padding; 5
file size  183
sha hash  661e87d55a4c835c68ec92594c4c0a5c36595813
file path: include/add.h
mtime: 1714889262
your silly padding; 4
file size  137
sha hash  b950eeae8aea44e7eb85c11dfcdcb0904c8b90bd
file path: include/checkout.h
mtime: 1714454921
your silly padding; 7
file size  90
sha hash  979cc48faea9e8407f4858d69b37239c7a509066
file path: include/commit.h
mtime: 1714454921
your silly padding; 1
file size  1298
sha hash  21dc5a14662beb2212e6721db17d95adae367185
file path: include/config_io.h
mtime: 1714454921
your silly padding; 6
file size  356
sha hash  a5b8e44f9eba70b73bdcd4d34ac35f49546390fe
file path: include/constants.h
mtime: 1714951235
your silly padding; 6
file size  126
sha hash  648f7b51fd6e2d13d00ac0a3f4da4cbc7a461317
file path: include/fetch.h
mtime: 1714454921
your silly padding; 2
file size  707
sha hash  8fd07fb39a8783db3050b9162327f76fdb6364df
file path: include/hash_table.h
mtime: 1714895303
your silly padding; 5
file size  604
sha hash  676c7e721706e252853d2eae9cd8a79d8793e0d2
file path: include/index_io.h
mtime: 1714944475
your silly padding; 7
file size  651
sha hash  28a562e9d8ab2917df07178794d4a6f003b73d5f
file path: include/linked_list.h
mtime: 1714784807
your silly padding; 4
file size  93
sha hash  195ae2200c35b38b10e2bae2813c2ed4d68c7f46
file path: include/log.h
mtime: 1714454921
your silly padding; 4
file size  1483
sha hash  6d94a2d89d0699364f438fb595c74daa97f4460c
file path: include/object_io.h
mtime: 1714900462
your silly padding; 6
file size  527
sha hash  95db7f58650f75d190ee5f2c9f54ccb34e1014e3
file path: include/push.h
mtime: 1714454921
your silly padding; 3
file size  654
sha hash  c5083f3806b00198d0eba4c66551f2cd1fe36962
file path: include/ref_io.h
mtime: 1714892361
your silly padding; 1
file size  88
sha hash  2e7699cc5b1f9debd233cee24b4d014ad94b91b5
file path: include/status.h
mtime: 1714454921
your silly padding; 1
file size  8243
sha hash  d2e8378dce98eb67cdaa9b41eb3fac0e0747b336
file path: include/transport.h
mtime: 1714939654
your silly padding; 6
file size  916
sha hash  5f121ca1de30c34f6789ccd7326c127165851dd8
file path: include/util.h
mtime: 1714889301
your silly padding; 3
file size  0
sha hash  e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
file path: out/.gitkeep
mtime: 1714454921
your silly padding; 5
file size  11449
sha hash  66131a1aec518768b0ca7c48fdac117af63f70aa
file path: src/add.c
mtime: 1714956666
your silly padding; 8
file size  232
sha hash  c855383c5babedd70eebec59e020c9bc436462ff
file path: src/checkout.c
mtime: 1714454921
your silly padding; 3
file size  384
sha hash  74c6e14eb17acceaee8b61b78a4f2aa1d302e6fd
file path: src/commit.c
mtime: 1714900390
your silly padding; 5
file size  10556
sha hash  b549117398f36f979a65c013363b0157910df31d
file path: src/config_io.c
mtime: 1714454921
your silly padding; 2
file size  1140
sha hash  c3fb8e67ac0495c613ac3993f24ec7918e8ef4ae
file path: src/fetch.c
mtime: 1714454921
your silly padding; 6
file size  3970
sha hash  75a503923dfa1abed2171ecf296768b2438e6334
file path: src/hash_table.c
mtime: 1714955394
your silly padding; 1
file size  6502
sha hash  9b5067475b526c3050f663971d1f0828f0a383db
file path: src/index_io.c
mtime: 1714956547
your silly padding; 3
file size  3554
sha hash  27e327a8d2dcebbb9d4e31dd0649b480231c6829
file path: src/linked_list.c
mtime: 1714784813
your silly padding; 8
file size  272
sha hash  3e3c3cd5093ab5791a6786d4790618ec99fa91bc
file path: src/log.c
mtime: 1714454921
your silly padding; 8
file size  345
sha hash  32a0fd8c85253a2334d7f74d814bae566b4936ba
file path: src/main.c
mtime: 1714777237
your silly padding; 7
file size  252912
sha hash  886e85f8561faa5cee803eda7043f22d5403c29e
file path: src/main.exe
mtime: 1714777232
your silly padding; 5
file size  7029
sha hash  ae4a7ac7c8292cc9f59a72b7afa1bdf4110b7bdd
file path: src/mygit.c
mtime: 1714454921
your silly padding; 6
file size  16478
sha hash  42f0cbec501fdfc3b3481416f582f1eb9d19852d
file path: src/object_io.c
mtime: 1714900885
your silly padding; 2
file size  479
sha hash  dd3435e5c0e40a967dbef4dd26e8d3b95b7c580f
file path: src/push.c
mtime: 1714454921
your silly padding; 7
file size  4803
sha hash  3c14d2b83578aebc9c4d880d70b460e73f55045e
file path: src/ref_io.c
mtime: 1714890132
your silly padding; 5
file size  7893
sha hash  ef2c8cbf02310504e30bc8a92f4aa2b0834fd991
file path: src/status.c
mtime: 1714900836
your silly padding; 5
file size  33282
sha hash  5637785d7573777f1c8360afa212ff8a076dbd08
file path: src/transport.c
mtime: 1714454921
your silly padding; 2
file size  3683
sha hash  3bfb963f6fd9e5b7629c2092c805519bf9a337ba
file path: src/util.c
mtime: 1714954349
your silly padding; 7
file size  9553
sha hash  68c081c76a5cde5ecfe156821bf184605f2fc8b3
file path: src/writer.c
mtime: 1714944309
your silly padding; 5
file size  3652
sha hash  6f228660950961980e48944cb0e36f10d7cb93f3
file path: temp_idx_file
mtime: 1714956670
your silly padding; 4
file size  13438
sha hash  f51850d1a314a61f760e653c1db54a21c2be37f1
file path: temp_lolski
mtime: 1714956670
your silly padding; 6
file size  0
sha hash  e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
file path: testtest
mtime: 1714956599
your silly padding; 1
file size  0
sha hash  e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
file path: testtest2
mtime: 1714956600
your silly padding; 8
yoooo what is up guys
ï¿½O
filename: test_commit_2

contents: 
 @ï¿½ï¿½>
filename: testtest2

contents: 
  ï¿½ï¿½>
filename: tet

contents: 
 
filename: theirs

contents: 
 tree ea87728e7fd9b705c7fb1fdd941a43415ece34a9
parent 16dd1267253415f351274379aeb04ce5a85550f3
author kevin <kdo@caltech.edu> 1715384333 -0700
committer kevin <kdo@caltech.edu> 1715384333 -0700

bruh

filename: theysrc

contents: 
 100755 blob 903677c6117bc7ae96e3957fe50e3131c13ac04b	add.c
040000 tree f0df58b11f08722aca058aaa8478654a00cb9615	brodie
040000 tree b60a2346f002650b8dc7db1dda3d65276be939b2	brodie2
100755 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	bvasdfv
100755 blob c855383c5babedd70eebec59e020c9bc436462ff	checkout.c
100755 blob bd5e00489ea83f8814186141e36f315b883e0157	commit.c
100755 blob b549117398f36f979a65c013363b0157910df31d	config_io.c
100755 blob c3fb8e67ac0495c613ac3993f24ec7918e8ef4ae	fetch.c
100755 blob dce7d7d36a3ce4adcb1f59da9dc1a990aba70f42	hash_table.c
100755 blob c3d6b98b186971edff511b5118ff13d55494f25b	index_io.c
100755 blob 27e327a8d2dcebbb9d4e31dd0649b480231c6829	linked_list.c
100755 blob 3e3c3cd5093ab5791a6786d4790618ec99fa91bc	log.c
100755 blob 0ae6abf89b8152b323c5196a85e1a20291703a9d	main.c
100755 blob 0b64d05ddc8789177dbb855b12f73924f45f9a78	main.exe
100755 blob ae4a7ac7c8292cc9f59a72b7afa1bdf4110b7bdd	mygit.c
100755 blob 27516adb83046a433fc81cfbcf908a860f5f03ab	object_io.c
100755 blob dd3435e5c0e40a967dbef4dd26e8d3b95b7c580f	push.c
100755 blob 74b8416bc59144fd0084c6d25759e96cefdc8e25	ref_io.c
100755 blob c8f8e952ee12cb6ea1c008853903c8d885a260a6	status.c
100755 blob 5637785d7573777f1c8360afa212ff8a076dbd08	transport.c
100755 blob f5f803f928f16d6ebfad595086169958fe8feb1c	util.c
100755 blob 081f5567a63d78013f81242f39df9b5c04464e24	yoooo

filename: trippin

contents: 
 aaaï¿½>
filename: try4asdfas

contents: 
 vvvvvvvvvvvvvvvvvvvvvvvvvvvvZï¿½ï¿½ï¿½Sï¿½
filename: uhhhh

contents: 
 0ï¿½ï¿½>
filename: yodie

contents: 
 00000000  63 6f 6d 6d 69 74 20 32  30 30 00 74 72 65 65 20  |commit 200.tree |
00000010  61 63 39 39 66 31 64 63  38 63 33 66 31 34 31 64  |ac99f1dc8c3f141d|
00000020  61 37 38 33 65 37 31 33  37 30 38 38 39 33 31 66  |a783e7137088931f|
00000030  62 39 33 32 64 66 38 33  0a 70 61 72 65 6e 74 20  |b932df83.parent |
00000040  61 30 35 35 63 64 65 62  61 37 37 64 61 32 63 30  |a055cdeba77da2c0|
00000050  35 63 30 38 64 39 37 37  33 38 39 64 61 66 34 33  |5c08d977389daf43|
00000060  34 65 31 65 37 64 63 30  0a 61 75 74 68 6f 72 20  |4e1e7dc0.author |
00000070  6b 65 76 69 6e 20 3c 6b  64 6f 40 63 61 6c 74 65  |kevin <kdo@calte|
00000080  63 68 2e 65 64 75 3e 20  31 37 31 35 34 30 35 38  |ch.edu> 17154058|
00000090  39 33 20 2d 30 37 30 30  0a 63 6f 6d 6d 69 74 74  |93 -0700.committ|
000000a0  65 72 20 6b 65 76 69 6e  20 3c 6b 64 6f 40 63 61  |er kevin <kdo@ca|
000000b0  6c 74 65 63 68 2e 65 64  75 3e 20 31 37 31 35 34  |ltech.edu> 17154|
000000c0  30 35 38 39 33 20 2d 30  37 30 30 0a 0a 79 6f 64  |05893 -0700..yod|
000000d0  69 65 0a                                          |ie.|
000000d3
F
filename: yodie2

contents: 
 <<<<<<< HEAD
00000000  63 6f 6d 6d 69 74 20 32  30 30 00 74 72 65 65 20  |commit 200.tree |
00000010  61 63 39 39 66 31 64 63  38 63 33 66 31 34 31 64  |ac99f1dc8c3f141d|
00000020  61 37 38 33 65 37 31 33  37 30 38 38 39 33 31 66  |a783e7137088931f|
00000030  62 39 33 32 64 66 38 33  0a 70 61 72 65 6e 74 20  |b932df83.parent |
00000040  32 38 39 66 38 64 65 39  66 39 34 61 34 39 35 62  |289f8de9f94a495b|
00000050  66 38 34 35 64 65 34 35  66 63 32 66 31 39 66 63  |f845de45fc2f19fc|
00000060  37 62 64 35 62 65 63 39  0a 61 75 74 68 6f 72 20  |7bd5bec9.author |
00000070  6b 65 76 69 6e 20 3c 6b  64 6f 40 63 61 6c 74 65  |kevin <kdo@calte|
00000080  63 68 2e 65 64 75 3e 20  31 37 31 35 34 30 35 38  |ch.edu> 17154058|
00000090  36 35 20 2d 30 37 30 30  0a 63 6f 6d 6d 69 74 74  |65 -0700.committ|
000000a0  65 72 20 6b 65 76 69 6e  20 3c 6b 64 6f 40 63 61  |er kevin <kdo@ca|
000000b0  6c 74 65 63 68 2e 65 64  75 3e 20 31 37 31 35 34  |ltech.edu> 17154|
000000c0  30 35 38 36 35 20 2d 30  37 30 30 0a 0a 79 6f 64  |05865 -0700..yod|
000000d0  69 65 0a                                          |ie.|
000000d3
=======
00000000  63 6f 6d 6d 69 74 20 32  30 30 00 74 72 65 65 20  |commit 200.tree |
00000010  61 63 39 39 66 31 64 63  38 63 33 66 31 34 31 64  |ac99f1dc8c3f141d|
00000020  61 37 38 33 65 37 31 33  37 30 38 38 39 33 31 66  |a783e7137088931f|
00000030  62 39 33 32 64 66 38 33  0a 70 61 72 65 6e 74 20  |b932df83.parent |
00000040  32 38 39 66 38 64 65 39  66 39 34 61 34 39 35 62  |289f8de9f94a495b|
00000050  66 38 34 35 64 65 34 35  66 63 32 66 31 39 66 63  |f845de45fc2f19fc|
00000060  37 62 64 35 62 65 63 39  0a 61 75 74 68 6f 72 20  |7bd5bec9.author |
00000070  6b 65 76 69 6e 20 3c 6b  64 6f 40 63 61 6c 74 65  |kevin <kdo@calte|
00000080  63 68 2e 65 64 75 3e 20  31 37 31 35 34 30 35 38  |ch.edu> 17154058|
00000090  36 35 20 2d 30 37 30 30  0a 63 6f 6d 6d 69 74 74  |65 -0700.committ|
000000a0  65 72 20 6b 65 76 69 6e  20 3c 6b 64 6f 40 63 61  |er kevin <kdo@ca|
000000b0  6c 74 65 63 68 2e 65 64  75 3e 20 31 37 31 35 34  |ltech.edu> 17154|
000000c0  30 35 38 36 35 20 2d 30 